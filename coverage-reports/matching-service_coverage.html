
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rideshare-platform/services/matching-service/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/rideshare-platform/services/matching-service/internal/handler/matching_handler.go (0.0%)</option>
				
				<option value="file2">github.com/rideshare-platform/services/matching-service/internal/repository/trip_repository.go (0.0%)</option>
				
				<option value="file3">github.com/rideshare-platform/services/matching-service/internal/service/matching_service.go (0.0%)</option>
				
				<option value="file4">github.com/rideshare-platform/services/matching-service/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "os"
        "strconv"
)

// Config holds all configuration for the matching service
type Config struct {
        HTTPPort    string
        Environment string
        LogLevel    string

        // Database config
        DatabaseHost     string
        DatabasePort     int
        DatabaseName     string
        DatabaseUser     string
        DatabasePassword string

        // MongoDB config
        MongoURI      string
        MongoDatabase string

        // Redis config
        RedisHost     string
        RedisPort     int
        RedisPassword string
        RedisDatabase int

        // Matching algorithm parameters
        MaxSearchRadius       float64 // km
        MaxMatchingTimeout    int     // seconds
        MaxDriversToConsider  int     // number of drivers
        DriverResponseTimeout int     // seconds
        PriorityBoostRadius   float64 // km
        PremiumPriorityBoost  float64 // multiplier
        MaxConcurrentMatches  int     // concurrent processing limit
        MatchingRetryAttempts int     // retry attempts
        MatchingRetryDelayMs  int     // ms between retries
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        return &amp;Config{
                HTTPPort:    getEnv("HTTP_PORT", "8084"),
                Environment: getEnv("ENVIRONMENT", "development"),
                LogLevel:    getEnv("LOG_LEVEL", "info"),

                // Database config
                DatabaseHost:     getEnv("DB_HOST", "localhost"),
                DatabasePort:     getEnvInt("DB_PORT", 5432),
                DatabaseName:     getEnv("DB_NAME", "rideshare"),
                DatabaseUser:     getEnv("DB_USER", "postgres"),
                DatabasePassword: getEnv("DB_PASSWORD", "postgres"),

                // MongoDB config
                MongoURI:      getEnv("MONGO_URI", "mongodb://localhost:27017"),
                MongoDatabase: getEnv("MONGO_DB", "rideshare"),

                // Redis config
                RedisHost:     getEnv("REDIS_HOST", "localhost"),
                RedisPort:     getEnvInt("REDIS_PORT", 6379),
                RedisPassword: getEnv("REDIS_PASSWORD", ""),
                RedisDatabase: getEnvInt("REDIS_DB", 0),

                // Matching parameters
                MaxSearchRadius:       getEnvFloat("MAX_SEARCH_RADIUS", 10.0),
                MaxMatchingTimeout:    getEnvInt("MAX_MATCHING_TIMEOUT", 30),
                MaxDriversToConsider:  getEnvInt("MAX_DRIVERS_TO_CONSIDER", 20),
                DriverResponseTimeout: getEnvInt("DRIVER_RESPONSE_TIMEOUT", 30),
                PriorityBoostRadius:   getEnvFloat("PRIORITY_BOOST_RADIUS", 2.0),
                PremiumPriorityBoost:  getEnvFloat("PREMIUM_PRIORITY_BOOST", 1.5),
                MaxConcurrentMatches:  getEnvInt("MAX_CONCURRENT_MATCHES", 100),
                MatchingRetryAttempts: getEnvInt("MATCHING_RETRY_ATTEMPTS", 3),
                MatchingRetryDelayMs:  getEnvInt("MATCHING_RETRY_DELAY_MS", 1000),
        }, nil
}</span>

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        // Add validation logic here if needed
        return nil
}</span>

// getEnv gets an environment variable with a default value
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvInt gets an environment variable as int with a default value
func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvFloat gets an environment variable as float64 with a default value
func getEnvFloat(key string, defaultValue float64) float64 <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "context"
        "net/http"

        "github.com/gin-gonic/gin"
        "github.com/rideshare-platform/services/matching-service/internal/service"
)

// MatchingServiceInterface defines the interface for matching services
type MatchingServiceInterface interface {
        FindMatch(ctx context.Context, request *service.MatchingRequest) (*service.MatchingResult, error)
        CancelMatching(ctx context.Context, tripID string) error
        GetMatchingMetrics(ctx context.Context) (map[string]interface{}, error)
        GetMatchingStatus(ctx context.Context, tripID string) (map[string]interface{}, error)
}

// MatchingHandler handles HTTP requests for the matching service
type MatchingHandler struct {
        service MatchingServiceInterface
}

// NewMatchingHandler creates a new matching handler
func NewMatchingHandler(service MatchingServiceInterface) *MatchingHandler <span class="cov0" title="0">{
        return &amp;MatchingHandler{
                service: service,
        }
}</span>

// RegisterRoutes registers all routes for the matching service
func (h *MatchingHandler) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Health check
                api.GET("/health", h.healthCheck)

                // Matching endpoints
                api.POST("/match", h.findMatch)
                api.GET("/match/:trip_id/status", h.getMatchingStatus)
                api.DELETE("/match/:trip_id", h.cancelMatching)

                // Driver finding endpoints
                matching := api.Group("/matching")
                </span><span class="cov0" title="0">{
                        matching.POST("/find-drivers", h.findDrivers)
                }</span>

                // Metrics
                <span class="cov0" title="0">api.GET("/metrics", h.getMetrics)</span>
        }
}

// healthCheck returns the health status of the service
func (h *MatchingHandler) healthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":  "healthy",
                "service": "matching-service",
                "version": "1.0.0",
        })
}</span>

// findMatch handles trip matching requests
func (h *MatchingHandler) findMatch(c *gin.Context) <span class="cov0" title="0">{
        var request service.MatchingRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Validate required fields
        <span class="cov0" title="0">if request.TripID == "" || request.RiderID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Missing required fields: trip_id, rider_id",
                })
                return
        }</span>

        <span class="cov0" title="0">result, err := h.service.FindMatch(c.Request.Context(), &amp;request)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to find match",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">if result.Success </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, result)
        }</span> else<span class="cov0" title="0"> {
                c.JSON(http.StatusNotFound, result)
        }</span>
}

// getMatchingStatus returns the status of a matching request
func (h *MatchingHandler) getMatchingStatus(c *gin.Context) <span class="cov0" title="0">{
        tripID := c.Param("trip_id")
        if tripID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Missing trip_id parameter",
                })
                return
        }</span>

        <span class="cov0" title="0">status, err := h.service.GetMatchingStatus(c.Request.Context(), tripID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to get matching status",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, status)</span>
}

// cancelMatching cancels an ongoing matching request
func (h *MatchingHandler) cancelMatching(c *gin.Context) <span class="cov0" title="0">{
        tripID := c.Param("trip_id")
        if tripID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Missing trip_id parameter",
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.service.CancelMatching(c.Request.Context(), tripID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to cancel matching",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Matching cancelled successfully",
                "trip_id": tripID,
        })</span>
}

// getMetrics returns matching service metrics
func (h *MatchingHandler) getMetrics(c *gin.Context) <span class="cov0" title="0">{
        metrics, err := h.service.GetMatchingMetrics(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to get metrics",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, metrics)</span>
}

// FindDriversRequest represents a request to find available drivers
type FindDriversRequest struct {
        RiderLocation struct {
                Lat float64 `json:"lat" binding:"required"`
                Lng float64 `json:"lng" binding:"required"`
        } `json:"rider_location" binding:"required"`
        Destination struct {
                Lat float64 `json:"lat" binding:"required"`
                Lng float64 `json:"lng" binding:"required"`
        } `json:"destination" binding:"required"`
        RideType string `json:"ride_type" binding:"required"`
}

// findDrivers handles requests to find available drivers
func (h *MatchingHandler) findDrivers(c *gin.Context) <span class="cov0" title="0">{
        var request FindDriversRequest
        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request format",
                        "details": err.Error(),
                })
                return
        }</span>

        // Mock response for now - return sample drivers
        <span class="cov0" title="0">drivers := []map[string]interface{}{
                {
                        "driver_id":    "driver-001",
                        "vehicle_type": "sedan",
                        "distance_km":  1.2,
                        "eta_minutes":  5,
                        "rating":       4.8,
                },
                {
                        "driver_id":    "driver-002",
                        "vehicle_type": "suv",
                        "distance_km":  2.1,
                        "eta_minutes":  8,
                        "rating":       4.6,
                },
        }

        c.JSON(http.StatusOK, gin.H{
                "drivers":       drivers,
                "total_found":   len(drivers),
                "ride_type":     request.RideType,
                "search_radius": 5.0,
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
)

// TripRepository handles trip data operations
type TripRepository struct {
        collection *mongo.Collection
        logger     *logger.Logger
}

// NewTripRepository creates a new trip repository
func NewTripRepository(db *mongo.Database, logger *logger.Logger) *TripRepository <span class="cov0" title="0">{
        return &amp;TripRepository{
                collection: db.Collection("trips"),
                logger:     logger,
        }
}</span>

// CreateTrip creates a new trip
func (r *TripRepository) CreateTrip(ctx context.Context, trip *models.Trip) error <span class="cov0" title="0">{
        trip.RequestedAt = time.Now()
        trip.Status = models.TripStatusRequested

        _, err := r.collection.InsertOne(ctx, trip)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to create trip")
                return fmt.Errorf("failed to create trip: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.WithField("trip_id", trip.ID).Info("Trip created successfully")
        return nil</span>
}

// GetTrip retrieves a trip by ID
func (r *TripRepository) GetTrip(ctx context.Context, tripID string) (*models.Trip, error) <span class="cov0" title="0">{
        var trip models.Trip
        err := r.collection.FindOne(ctx, bson.M{"id": tripID}).Decode(&amp;trip)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("trip not found: %s", tripID)
                }</span>
                <span class="cov0" title="0">r.logger.WithError(err).WithField("trip_id", tripID).Error("Failed to get trip")
                return nil, fmt.Errorf("failed to get trip: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;trip, nil</span>
}

// UpdateTripStatus updates the status of a trip
func (r *TripRepository) UpdateTripStatus(ctx context.Context, tripID string, status models.TripStatus) error <span class="cov0" title="0">{
        update := bson.M{"$set": bson.M{"status": status}}

        // Add timestamp based on status
        switch status </span>{
        case models.TripStatusMatched:<span class="cov0" title="0">
                now := time.Now()
                update["$set"].(bson.M)["matched_at"] = now</span>
        case models.TripStatusDriverAssigned:<span class="cov0" title="0">
                now := time.Now()
                update["$set"].(bson.M)["driver_assigned_at"] = now</span>
        case models.TripStatusDriverArrived:<span class="cov0" title="0">
                now := time.Now()
                update["$set"].(bson.M)["driver_arrived_at"] = now</span>
        case models.TripStatusTripStarted:<span class="cov0" title="0">
                now := time.Now()
                update["$set"].(bson.M)["started_at"] = now</span>
        case models.TripStatusCompleted:<span class="cov0" title="0">
                now := time.Now()
                update["$set"].(bson.M)["completed_at"] = now</span>
        }

        <span class="cov0" title="0">result, err := r.collection.UpdateOne(ctx, bson.M{"id": tripID}, update)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).WithFields(logger.Fields{
                        "trip_id": tripID,
                        "status":  status,
                }).Error("Failed to update trip status")
                return fmt.Errorf("failed to update trip status: %w", err)
        }</span>

        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("trip not found: %s", tripID)
        }</span>

        <span class="cov0" title="0">r.logger.WithFields(logger.Fields{
                "trip_id": tripID,
                "status":  status,
        }).Info("Trip status updated successfully")

        return nil</span>
}

// AssignDriver assigns a driver to a trip
func (r *TripRepository) AssignDriver(ctx context.Context, tripID, driverID, vehicleID string) error <span class="cov0" title="0">{
        update := bson.M{
                "$set": bson.M{
                        "driver_id":          driverID,
                        "vehicle_id":         vehicleID,
                        "status":             models.TripStatusDriverAssigned,
                        "driver_assigned_at": time.Now(),
                },
        }

        result, err := r.collection.UpdateOne(ctx, bson.M{"id": tripID}, update)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).WithFields(logger.Fields{
                        "trip_id":    tripID,
                        "driver_id":  driverID,
                        "vehicle_id": vehicleID,
                }).Error("Failed to assign driver to trip")
                return fmt.Errorf("failed to assign driver to trip: %w", err)
        }</span>

        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("trip not found: %s", tripID)
        }</span>

        <span class="cov0" title="0">r.logger.WithFields(logger.Fields{
                "trip_id":    tripID,
                "driver_id":  driverID,
                "vehicle_id": vehicleID,
        }).Info("Driver assigned to trip successfully")

        return nil</span>
}

// GetPendingTrips retrieves all trips that are pending matching
func (r *TripRepository) GetPendingTrips(ctx context.Context, limit int) ([]*models.Trip, error) <span class="cov0" title="0">{
        filter := bson.M{"status": models.TripStatusRequested}
        opts := options.Find().SetLimit(int64(limit)).SetSort(bson.M{"requested_at": 1})

        cursor, err := r.collection.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to get pending trips")
                return nil, fmt.Errorf("failed to get pending trips: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var trips []*models.Trip
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var trip models.Trip
                if err := cursor.Decode(&amp;trip); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode trip")
                        continue</span>
                }
                <span class="cov0" title="0">trips = append(trips, &amp;trip)</span>
        }

        <span class="cov0" title="0">if err := cursor.Err(); err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Cursor error while getting pending trips")
                return nil, fmt.Errorf("cursor error: %w", err)
        }</span>

        <span class="cov0" title="0">return trips, nil</span>
}

// GetActiveTripsForDriver retrieves all active trips for a driver
func (r *TripRepository) GetActiveTripsForDriver(ctx context.Context, driverID string) ([]*models.Trip, error) <span class="cov0" title="0">{
        filter := bson.M{
                "driver_id": driverID,
                "status": bson.M{"$in": []models.TripStatus{
                        models.TripStatusDriverAssigned,
                        models.TripStatusDriverArriving,
                        models.TripStatusDriverArrived,
                        models.TripStatusTripStarted,
                        models.TripStatusInProgress,
                }},
        }

        cursor, err := r.collection.Find(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).WithField("driver_id", driverID).Error("Failed to get active trips for driver")
                return nil, fmt.Errorf("failed to get active trips for driver: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var trips []*models.Trip
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var trip models.Trip
                if err := cursor.Decode(&amp;trip); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode trip")
                        continue</span>
                }
                <span class="cov0" title="0">trips = append(trips, &amp;trip)</span>
        }

        <span class="cov0" title="0">return trips, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "context"
        "fmt"
        "math"
        "sort"
        "strings"
        "time"

        "github.com/redis/go-redis/v9"
        "go.mongodb.org/mongo-driver/mongo"

        "github.com/rideshare-platform/services/matching-service/internal/config"
        "github.com/rideshare-platform/services/matching-service/internal/repository"
        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
)

// AdvancedMatchingService handles trip matching with sophisticated algorithms
type AdvancedMatchingService struct {
        config     *config.Config
        logger     *logger.Logger
        tripRepo   *repository.TripRepository
        redis      *redis.Client
        mongo      *mongo.Client
        geoService GeoServiceClient // Interface for geo-service gRPC calls
}

// GeoServiceClient interface for geo-service integration
type GeoServiceClient interface {
        CalculateDistance(ctx context.Context, origin, destination *models.Location) (*DistanceResult, error)
        CalculateETA(ctx context.Context, origin, destination *models.Location, vehicleType string) (*ETAResult, error)
        FindNearbyDrivers(ctx context.Context, center *models.Location, radiusKm float64, limit int) ([]*DriverLocation, error)
}

// DistanceResult represents distance calculation result from geo-service
type DistanceResult struct {
        DistanceMeters float64
        DistanceKm     float64
        BearingDegrees float64
}

// ETAResult represents ETA calculation result from geo-service
type ETAResult struct {
        DurationSeconds int
        DistanceMeters  float64
        RouteSummary    string
}

// DriverLocation represents a driver's location from geo-service
type DriverLocation struct {
        DriverID           string
        VehicleID          string
        Location           *models.Location
        DistanceFromCenter float64
        Status             string
        VehicleType        string
        Rating             float64
}

// MatchingRequest represents a comprehensive trip matching request
type MatchingRequest struct {
        TripID         string            `json:"trip_id"`
        RiderID        string            `json:"rider_id"`
        PickupLocation *models.Location  `json:"pickup_location"`
        Destination    *models.Location  `json:"destination"`
        PassengerCount int               `json:"passenger_count"`
        VehicleType    string            `json:"vehicle_type"`
        RequestedAt    time.Time         `json:"requested_at"`
        SpecialNeeds   []string          `json:"special_needs,omitempty"`
        PriorityLevel  int               `json:"priority_level"` // 1=normal, 2=premium, 3=emergency
        MaxWaitTime    time.Duration     `json:"max_wait_time"`
        Preferences    *RiderPreferences `json:"preferences,omitempty"`
}

// RiderPreferences represents rider preferences for matching
type RiderPreferences struct {
        MinDriverRating    float64  `json:"min_driver_rating"`
        PreferredGender    string   `json:"preferred_gender,omitempty"`
        AllowSharedRides   bool     `json:"allow_shared_rides"`
        MaxDetourTime      int      `json:"max_detour_time"` // minutes
        PreferQuietRide    bool     `json:"prefer_quiet_ride"`
        AccessibilityNeeds []string `json:"accessibility_needs,omitempty"`
}

// MatchingResult represents comprehensive matching result
type MatchingResult struct {
        TripID             string               `json:"trip_id"`
        Success            bool                 `json:"success"`
        MatchedDriver      *MatchedDriverInfo   `json:"matched_driver,omitempty"`
        EstimatedETA       int                  `json:"estimated_eta,omitempty"` // seconds
        EstimatedFare      *FareEstimate        `json:"estimated_fare,omitempty"`
        Reason             string               `json:"reason,omitempty"`
        AlternativeOptions []*MatchedDriverInfo `json:"alternative_options,omitempty"`
        MatchingScore      float64              `json:"matching_score,omitempty"`
        ProcessingTime     time.Duration        `json:"processing_time"`
        RetryCount         int                  `json:"retry_count"`
}

// MatchedDriverInfo represents detailed matched driver information
type MatchedDriverInfo struct {
        DriverID        string           `json:"driver_id"`
        VehicleID       string           `json:"vehicle_id"`
        DriverName      string           `json:"driver_name"`
        DriverPhoto     string           `json:"driver_photo,omitempty"`
        Rating          float64          `json:"rating"`
        TripCount       int              `json:"trip_count"`
        CurrentLocation *models.Location `json:"current_location"`
        VehicleInfo     *VehicleDetails  `json:"vehicle_info"`
        Distance        float64          `json:"distance"` // km from pickup
        ETA             int              `json:"eta"`      // seconds to pickup
        MatchScore      float64          `json:"match_score"`
        Status          string           `json:"status"`
}

// VehicleDetails represents detailed vehicle information
type VehicleDetails struct {
        Make         string   `json:"make"`
        Model        string   `json:"model"`
        Year         int      `json:"year"`
        Color        string   `json:"color"`
        LicensePlate string   `json:"license_plate"`
        VehicleType  string   `json:"vehicle_type"`
        Capacity     int      `json:"capacity"`
        Features     []string `json:"features,omitempty"` // e.g., "air_conditioning", "wifi", "phone_charger"
}

// FareEstimate represents estimated fare for the trip
type FareEstimate struct {
        BaseFare      float64 `json:"base_fare"`
        DistanceFare  float64 `json:"distance_fare"`
        TimeFare      float64 `json:"time_fare"`
        SurgeFare     float64 `json:"surge_fare"`
        TotalEstimate float64 `json:"total_estimate"`
        Currency      string  `json:"currency"`
}

// NewAdvancedMatchingService creates a new advanced matching service
func NewAdvancedMatchingService(
        cfg *config.Config,
        logger *logger.Logger,
        tripRepo *repository.TripRepository,
        redis *redis.Client,
        mongo *mongo.Client,
        geoService GeoServiceClient,
) *AdvancedMatchingService <span class="cov0" title="0">{
        return &amp;AdvancedMatchingService{
                config:     cfg,
                logger:     logger,
                tripRepo:   tripRepo,
                redis:      redis,
                mongo:      mongo,
                geoService: geoService,
        }
}</span>

// NewSimpleMatchingService creates a basic matching service for testing
func NewSimpleMatchingService(cfg *config.Config) *AdvancedMatchingService <span class="cov0" title="0">{
        // Create a simple version without external dependencies for basic functionality
        return &amp;AdvancedMatchingService{
                config: cfg,
                // Other fields will be nil - need to handle this in methods
        }
}</span>

// FindMatch implements sophisticated driver matching algorithm
func (s *AdvancedMatchingService) FindMatch(ctx context.Context, request *MatchingRequest) (*MatchingResult, error) <span class="cov0" title="0">{
        startTime := time.Now()

        // Basic safety check for nil dependencies - return mock response
        if s.geoService == nil </span><span class="cov0" title="0">{
                return s.generateMockResult(request, startTime), nil
        }</span>

        <span class="cov0" title="0">if s.logger != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).WithFields(logger.Fields{
                        "trip_id":      request.TripID,
                        "rider_id":     request.RiderID,
                        "vehicle_type": request.VehicleType,
                        "pickup_lat":   request.PickupLocation.Latitude,
                        "pickup_lng":   request.PickupLocation.Longitude,
                }).Info("Starting advanced trip matching")
        }</span> // Phase 1: Find nearby drivers using geo-service
        <span class="cov0" title="0">nearbyDrivers, err := s.findNearbyDrivers(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;MatchingResult{
                        TripID:         request.TripID,
                        Success:        false,
                        Reason:         fmt.Sprintf("Failed to find nearby drivers: %v", err),
                        ProcessingTime: time.Since(startTime),
                }, err
        }</span>

        <span class="cov0" title="0">if len(nearbyDrivers) == 0 </span><span class="cov0" title="0">{
                return &amp;MatchingResult{
                        TripID:         request.TripID,
                        Success:        false,
                        Reason:         "No available drivers found in the area",
                        ProcessingTime: time.Since(startTime),
                }, nil
        }</span>

        // Phase 2: Filter drivers based on requirements
        <span class="cov0" title="0">eligibleDrivers := s.filterEligibleDrivers(ctx, nearbyDrivers, request)
        if len(eligibleDrivers) == 0 </span><span class="cov0" title="0">{
                return &amp;MatchingResult{
                        TripID:         request.TripID,
                        Success:        false,
                        Reason:         "No eligible drivers match the requirements",
                        ProcessingTime: time.Since(startTime),
                }, nil
        }</span>

        // Phase 3: Score and rank drivers
        <span class="cov0" title="0">scoredDrivers, err := s.scoreAndRankDrivers(ctx, eligibleDrivers, request)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;MatchingResult{
                        TripID:         request.TripID,
                        Success:        false,
                        Reason:         fmt.Sprintf("Failed to score drivers: %v", err),
                        ProcessingTime: time.Since(startTime),
                }, err
        }</span>

        // Phase 4: Select best match and alternatives
        <span class="cov0" title="0">bestMatch := scoredDrivers[0]
        var alternatives []*MatchedDriverInfo
        if len(scoredDrivers) &gt; 1 </span><span class="cov0" title="0">{
                maxAlternatives := 3
                if len(scoredDrivers) &lt; maxAlternatives+1 </span><span class="cov0" title="0">{
                        maxAlternatives = len(scoredDrivers) - 1
                }</span>
                <span class="cov0" title="0">alternatives = scoredDrivers[1 : maxAlternatives+1]</span>
        }

        // Phase 5: Calculate fare estimate
        <span class="cov0" title="0">fareEstimate, err := s.calculateFareEstimate(ctx, request, bestMatch)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Warn("Failed to calculate fare estimate")
        }</span>

        // Phase 6: Reserve the driver
        <span class="cov0" title="0">err = s.reserveDriver(ctx, bestMatch.DriverID, request.TripID)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to reserve driver")
                return &amp;MatchingResult{
                        TripID:         request.TripID,
                        Success:        false,
                        Reason:         "Driver reservation failed",
                        ProcessingTime: time.Since(startTime),
                }, err
        }</span>

        <span class="cov0" title="0">result := &amp;MatchingResult{
                TripID:             request.TripID,
                Success:            true,
                MatchedDriver:      bestMatch,
                EstimatedETA:       bestMatch.ETA,
                EstimatedFare:      fareEstimate,
                Reason:             "Successfully matched with optimal driver",
                AlternativeOptions: alternatives,
                MatchingScore:      bestMatch.MatchScore,
                ProcessingTime:     time.Since(startTime),
                RetryCount:         0,
        }

        s.logger.WithContext(ctx).WithFields(logger.Fields{
                "trip_id":        request.TripID,
                "matched_driver": bestMatch.DriverID,
                "match_score":    bestMatch.MatchScore,
                "processing_ms":  time.Since(startTime).Milliseconds(),
        }).Info("Trip matching completed successfully")

        return result, nil</span>
}

// findNearbyDrivers gets nearby drivers from geo-service
func (s *AdvancedMatchingService) findNearbyDrivers(ctx context.Context, request *MatchingRequest) ([]*DriverLocation, error) <span class="cov0" title="0">{
        // Start with a smaller radius and expand if needed
        radiusKm := 5.0
        maxRadius := 20.0
        limit := 50

        for radiusKm &lt;= maxRadius </span><span class="cov0" title="0">{
                drivers, err := s.geoService.FindNearbyDrivers(ctx, request.PickupLocation, radiusKm, limit)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if len(drivers) &gt;= 5 </span><span class="cov0" title="0">{ // Minimum drivers to consider
                        return drivers, nil
                }</span>

                <span class="cov0" title="0">radiusKm += 5.0</span> // Expand search radius
        }

        // Return whatever we found, even if less than ideal
        <span class="cov0" title="0">return s.geoService.FindNearbyDrivers(ctx, request.PickupLocation, maxRadius, limit)</span>
}

// filterEligibleDrivers filters drivers based on requirements
func (s *AdvancedMatchingService) filterEligibleDrivers(ctx context.Context, drivers []*DriverLocation, request *MatchingRequest) []*DriverLocation <span class="cov0" title="0">{
        var eligible []*DriverLocation

        for _, driver := range drivers </span><span class="cov0" title="0">{
                // Check basic availability
                if driver.Status != "available" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check vehicle type match
                <span class="cov0" title="0">if request.VehicleType != "" &amp;&amp; driver.VehicleType != request.VehicleType </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check minimum rating requirement
                <span class="cov0" title="0">if request.Preferences != nil &amp;&amp; driver.Rating &lt; request.Preferences.MinDriverRating </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check maximum distance (15km for now)
                <span class="cov0" title="0">if driver.DistanceFromCenter &gt; 15.0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">eligible = append(eligible, driver)</span>
        }

        <span class="cov0" title="0">return eligible</span>
}

// scoreAndRankDrivers scores drivers based on multiple factors
func (s *AdvancedMatchingService) scoreAndRankDrivers(ctx context.Context, drivers []*DriverLocation, request *MatchingRequest) ([]*MatchedDriverInfo, error) <span class="cov0" title="0">{
        var scoredDrivers []*MatchedDriverInfo

        for _, driver := range drivers </span><span class="cov0" title="0">{
                // Calculate ETA
                eta, err := s.geoService.CalculateETA(ctx, driver.Location, request.PickupLocation, driver.VehicleType)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Warn("Failed to calculate ETA for driver", driver.DriverID)
                        continue</span>
                }

                // Create matched driver info
                <span class="cov0" title="0">matchedDriver := &amp;MatchedDriverInfo{
                        DriverID:        driver.DriverID,
                        VehicleID:       driver.VehicleID,
                        Rating:          driver.Rating,
                        CurrentLocation: driver.Location,
                        Distance:        driver.DistanceFromCenter,
                        ETA:             eta.DurationSeconds,
                        Status:          driver.Status,
                        VehicleInfo: &amp;VehicleDetails{
                                VehicleType: driver.VehicleType,
                                // Additional vehicle details would be fetched from vehicle service
                        },
                }

                // Calculate composite matching score
                score := s.calculateMatchingScore(matchedDriver, request)
                matchedDriver.MatchScore = score

                scoredDrivers = append(scoredDrivers, matchedDriver)</span>
        }

        // Sort by score (descending)
        <span class="cov0" title="0">sort.Slice(scoredDrivers, func(i, j int) bool </span><span class="cov0" title="0">{
                return scoredDrivers[i].MatchScore &gt; scoredDrivers[j].MatchScore
        }</span>)

        <span class="cov0" title="0">return scoredDrivers, nil</span>
}

// calculateMatchingScore calculates a composite score for driver matching
func (s *AdvancedMatchingService) calculateMatchingScore(driver *MatchedDriverInfo, request *MatchingRequest) float64 <span class="cov0" title="0">{
        score := 0.0

        // Distance factor (closer is better) - 40% weight
        maxDistance := 15.0 // km
        distanceScore := math.Max(0, (maxDistance-driver.Distance)/maxDistance) * 40

        // ETA factor (faster pickup is better) - 30% weight
        maxETA := 20.0 * 60 // 20 minutes in seconds
        etaScore := math.Max(0, (maxETA-float64(driver.ETA))/maxETA) * 30

        // Rating factor (higher rating is better) - 20% weight
        ratingScore := (driver.Rating / 5.0) * 20

        // Availability factor - 10% weight
        availabilityScore := 10.0 // Full score for available drivers

        score = distanceScore + etaScore + ratingScore + availabilityScore

        // Apply priority bonuses
        if request.PriorityLevel &gt; 1 </span><span class="cov0" title="0">{
                score += float64(request.PriorityLevel-1) * 5 // Bonus for premium/emergency
        }</span>

        <span class="cov0" title="0">return math.Min(100.0, score)</span> // Cap at 100
}

// calculateFareEstimate estimates the fare for the trip
func (s *AdvancedMatchingService) calculateFareEstimate(ctx context.Context, request *MatchingRequest, driver *MatchedDriverInfo) (*FareEstimate, error) <span class="cov0" title="0">{
        // Calculate trip distance and duration
        distanceResult, err := s.geoService.CalculateDistance(ctx, request.PickupLocation, request.Destination)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">etaResult, err := s.geoService.CalculateETA(ctx, request.PickupLocation, request.Destination, driver.VehicleInfo.VehicleType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Base fare calculation (simplified)
        <span class="cov0" title="0">baseFare := 3.00                                           // Base fare
        distanceFare := distanceResult.DistanceKm * 1.50           // $1.50 per km
        timeFare := float64(etaResult.DurationSeconds) / 60 * 0.25 // $0.25 per minute

        // Surge pricing (simplified - could be more sophisticated)
        surgeFare := 0.0
        if request.PriorityLevel &gt; 1 </span><span class="cov0" title="0">{
                surgeFare = (baseFare + distanceFare + timeFare) * 0.5 // 50% surge for premium
        }</span>

        <span class="cov0" title="0">total := baseFare + distanceFare + timeFare + surgeFare

        return &amp;FareEstimate{
                BaseFare:      baseFare,
                DistanceFare:  distanceFare,
                TimeFare:      timeFare,
                SurgeFare:     surgeFare,
                TotalEstimate: total,
                Currency:      "USD",
        }, nil</span>
}

// reserveDriver temporarily reserves a driver for the trip
func (s *AdvancedMatchingService) reserveDriver(ctx context.Context, driverID, tripID string) error <span class="cov0" title="0">{
        // Safety check for nil Redis dependency
        if s.redis == nil </span><span class="cov0" title="0">{
                if s.logger != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Warn("Redis client not available - driver reservation skipped")
                }</span>
                <span class="cov0" title="0">return nil</span> // Return success for testing without Redis
        }

        // Set a reservation in Redis with TTL
        <span class="cov0" title="0">key := fmt.Sprintf("driver_reservation:%s", driverID)
        value := fmt.Sprintf("trip:%s:reserved_at:%d", tripID, time.Now().Unix())

        return s.redis.SetEx(ctx, key, value, 5*time.Minute).Err()</span>
} // GetMatchingStatus returns the status of ongoing matching processes
func (s *AdvancedMatchingService) GetMatchingStatus(ctx context.Context, tripID string) (map[string]interface{}, error) <span class="cov0" title="0">{
        status := "not_found"
        startedAt := time.Now().Add(-30 * time.Second) // Default fallback

        // Safety check for nil Redis dependency
        if s.redis != nil </span><span class="cov0" title="0">{
                // Check if there's an active reservation for this trip
                pattern := "driver_reservation:*"
                keys, err := s.redis.Keys(ctx, pattern).Result()
                if err != nil &amp;&amp; s.logger != nil </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Warn("Failed to check driver reservations")
                }</span>

                <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                        value, err := s.redis.Get(ctx, key).Result()
                        if err == nil &amp;&amp; strings.Contains(value, tripID) </span><span class="cov0" title="0">{
                                status = "searching"
                                // Extract timestamp from reservation value if possible
                                break</span>
                        }
                }
        } else<span class="cov0" title="0"> if s.logger != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).Warn("Redis client not available - using mock status")
                status = "searching" // Mock status for testing
        }</span>

        <span class="cov0" title="0">return map[string]interface{}{
                "trip_id":      tripID,
                "status":       status,
                "started_at":   startedAt,
                "attempts":     1,
                "max_attempts": 3,
        }, nil</span>
}

// CancelMatching cancels an ongoing matching process
func (s *AdvancedMatchingService) CancelMatching(ctx context.Context, tripID string) error <span class="cov0" title="0">{
        // Safety check for nil Redis dependency
        if s.redis == nil </span><span class="cov0" title="0">{
                if s.logger != nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).WithField("trip_id", tripID).Info("Matching cancelled (Redis not available)")
                }</span>
                <span class="cov0" title="0">return nil</span> // Return success for testing without Redis
        }

        // Remove any driver reservations for this trip
        <span class="cov0" title="0">pattern := "driver_reservation:*"
        keys, err := s.redis.Keys(ctx, pattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, key := range keys </span><span class="cov0" title="0">{
                value, err := s.redis.Get(ctx, key).Result()
                if err == nil &amp;&amp; contains(value, tripID) </span><span class="cov0" title="0">{
                        s.redis.Del(ctx, key)
                }</span>
        }

        <span class="cov0" title="0">if s.logger != nil </span><span class="cov0" title="0">{
                s.logger.WithContext(ctx).WithField("trip_id", tripID).Info("Matching cancelled")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetMatchingMetrics returns comprehensive matching metrics
func (s *AdvancedMatchingService) GetMatchingMetrics(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        // In a real implementation, these would come from monitoring systems
        return map[string]interface{}{
                "total_requests":      1234,
                "successful_matches":  1089,
                "success_rate":        88.2,
                "avg_match_time":      "15.3s",
                "avg_match_score":     85.7,
                "active_searches":     5,
                "avg_driver_distance": "2.3km",
                "avg_eta":             "8.5min",
                "surge_active":        false,
                "available_drivers":   245,
                "active_trips":        123,
        }, nil
}</span>

// Helper function
func contains(s, substr string) bool <span class="cov0" title="0">{
        return strings.Contains(s, substr)
}</span>

// generateMockResult creates a mock matching result for testing purposes
func (s *AdvancedMatchingService) generateMockResult(request *MatchingRequest, startTime time.Time) *MatchingResult <span class="cov0" title="0">{
        mockDriver := &amp;MatchedDriverInfo{
                DriverID:   "mock-driver-123",
                VehicleID:  "mock-vehicle-456",
                DriverName: "Mock Driver",
                Rating:     4.8,
                TripCount:  150,
                CurrentLocation: &amp;models.Location{
                        Latitude:  request.PickupLocation.Latitude,
                        Longitude: request.PickupLocation.Longitude,
                },
                VehicleInfo: &amp;VehicleDetails{
                        Make:         "Test",
                        Model:        "Vehicle",
                        Year:         2023,
                        Color:        "Blue",
                        LicensePlate: "MOCK123",
                        VehicleType:  request.VehicleType,
                        Capacity:     4,
                },
                Distance:   1.2,
                ETA:        300, // 5 minutes
                MatchScore: 85.5,
                Status:     "available",
        }

        mockFare := &amp;FareEstimate{
                BaseFare:      3.00,
                DistanceFare:  6.00,
                TimeFare:      2.50,
                SurgeFare:     0.00,
                TotalEstimate: 11.50,
                Currency:      "USD",
        }

        return &amp;MatchingResult{
                TripID:             request.TripID,
                Success:            true,
                MatchedDriver:      mockDriver,
                EstimatedETA:       300,
                EstimatedFare:      mockFare,
                Reason:             "Mock match for testing",
                AlternativeOptions: []*MatchedDriverInfo{},
                MatchingScore:      85.5,
                ProcessingTime:     time.Since(startTime),
                RetryCount:         0,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rideshare-platform/services/matching-service/internal/config"
        "github.com/rideshare-platform/services/matching-service/internal/handler"
        "github.com/rideshare-platform/services/matching-service/internal/service"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Starting Matching Service on port %s", cfg.HTTPPort)

        // Initialize services
        matchingService := service.NewSimpleMatchingService(cfg)

        // Initialize HTTP handler
        matchingHandler := handler.NewMatchingHandler(matchingService)

        // Setup HTTP server
        gin.SetMode(gin.ReleaseMode)
        router := gin.New()
        router.Use(gin.Recovery())

        // Register routes
        matchingHandler.RegisterRoutes(router)

        server := &amp;http.Server{
                Addr:    ":" + cfg.HTTPPort,
                Handler: router,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("HTTP server listening on port %s", cfg.HTTPPort)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start HTTP server: %v", err)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sigChan

        log.Println("Received interrupt signal, starting graceful shutdown...")

        // Graceful shutdown
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to shutdown HTTP server gracefully: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("Matching Service stopped gracefully")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

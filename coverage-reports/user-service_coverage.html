
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rideshare-platform/services/user-service/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/rideshare-platform/services/user-service/internal/handler/user_handler.go (0.0%)</option>
				
				<option value="file2">github.com/rideshare-platform/services/user-service/internal/metrics/metrics.go (0.0%)</option>
				
				<option value="file3">github.com/rideshare-platform/services/user-service/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file4">github.com/rideshare-platform/services/user-service/internal/service/user_service.go (0.0%)</option>
				
				<option value="file5">github.com/rideshare-platform/services/user-service/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "os"
        "strconv"
)

// Config holds all configuration for the user service
type Config struct {
        HTTPPort    string
        Environment string
        LogLevel    string

        // Database configuration
        DatabaseHost     string
        DatabasePort     string
        DatabaseUser     string
        DatabasePassword string
        DatabaseName     string
        DatabaseSSLMode  string
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        return &amp;Config{
                HTTPPort:    getEnv("HTTP_PORT", "8081"),
                Environment: getEnv("ENVIRONMENT", "development"),
                LogLevel:    getEnv("LOG_LEVEL", "info"),

                // Database configuration
                DatabaseHost:     getEnv("DATABASE_HOST", "localhost"),
                DatabasePort:     getEnv("DATABASE_PORT", "5432"),
                DatabaseUser:     getEnv("DATABASE_USER", "rideshare_user"),
                DatabasePassword: getEnv("DATABASE_PASSWORD", "rideshare_password"),
                DatabaseName:     getEnv("DATABASE_NAME", "rideshare"),
                DatabaseSSLMode:  getEnv("DATABASE_SSL_MODE", "disable"),
        }, nil
}</span>

// getEnv gets an environment variable with a default value
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvAsInt gets an environment variable as integer with a default value
func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvAsBool gets an environment variable as boolean with a default value
func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "net/http"
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rideshare-platform/services/user-service/internal/metrics"
        "github.com/rideshare-platform/services/user-service/internal/service"
        "github.com/rideshare-platform/shared/models"
)

// UserHandler handles HTTP requests for user operations
type UserHandler struct {
        userService *service.UserService
}

// NewUserHandler creates a new user handler
func NewUserHandler(userService *service.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                userService: userService,
        }
}</span>

// RegisterRoutes registers user routes
func (h *UserHandler) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Health check endpoint
        router.GET("/health", h.healthCheck)

        users := router.Group("/api/v1/users")
        </span><span class="cov0" title="0">{
                users.POST("/", h.CreateUser)
                users.GET("/:id", h.GetUser)
                users.PUT("/:id", h.UpdateUser)
                users.DELETE("/:id", h.DeleteUser)
                users.GET("/", h.ListUsers)
                users.POST("/auth", h.AuthenticateUser)
        }</span>
}

// CreateUserRequest represents the request to create a user
type CreateUserRequest struct {
        Email     string          `json:"email" binding:"required"`
        Phone     string          `json:"phone" binding:"required"`
        FirstName string          `json:"first_name" binding:"required"`
        LastName  string          `json:"last_name" binding:"required"`
        UserType  models.UserType `json:"user_type" binding:"required"`
        Password  string          `json:"password" binding:"required"`
}

// UpdateUserRequest represents the request to update a user
type UpdateUserRequest struct {
        Email     string            `json:"email"`
        Phone     string            `json:"phone"`
        FirstName string            `json:"first_name"`
        LastName  string            `json:"last_name"`
        UserType  models.UserType   `json:"user_type"`
        Status    models.UserStatus `json:"status"`
}

// AuthRequest represents the authentication request
type AuthRequest struct {
        Email    string `json:"email" binding:"required"`
        Password string `json:"password" binding:"required"`
}

// CreateUser creates a new user
func (h *UserHandler) CreateUser(c *gin.Context) <span class="cov0" title="0">{
        var req CreateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request",
                        "details": err.Error(),
                })
                return
        }</span>

        // Create user model
        <span class="cov0" title="0">user := models.NewUser(req.Email, req.Phone, req.FirstName, req.LastName, req.UserType)

        // Create user
        createdUser, err := h.userService.CreateUser(c.Request.Context(), user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Failed to create user",
                        "details": err.Error(),
                })
                return
        }</span>

        // Record metrics
        <span class="cov0" title="0">metrics.RecordUserCreated()

        c.JSON(http.StatusCreated, createdUser)</span>
}

// GetUser retrieves a user by ID
func (h *UserHandler) GetUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "User ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "User not found",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// UpdateUser updates an existing user
func (h *UserHandler) UpdateUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "User ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">var req UpdateUserRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request",
                        "details": err.Error(),
                })
                return
        }</span>

        // Create user model with update data
        <span class="cov0" title="0">user := &amp;models.User{
                ID:        userID,
                Email:     req.Email,
                Phone:     req.Phone,
                FirstName: req.FirstName,
                LastName:  req.LastName,
                UserType:  req.UserType,
                Status:    req.Status,
        }

        updatedUser, err := h.userService.UpdateUser(c.Request.Context(), user)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Failed to update user",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, updatedUser)</span>
}

// DeleteUser deletes a user by ID
func (h *UserHandler) DeleteUser(c *gin.Context) <span class="cov0" title="0">{
        userID := c.Param("id")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "User ID is required",
                })
                return
        }</span>

        <span class="cov0" title="0">err := h.userService.DeleteUser(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{
                        "error":   "Failed to delete user",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "User deleted successfully",
        })</span>
}

// ListUsers returns all users
func (h *UserHandler) ListUsers(c *gin.Context) <span class="cov0" title="0">{
        // Parse query parameters
        limit := 10
        offset := 0

        if limitStr := c.Query("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">if offsetStr := c.Query("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if o, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                        offset = o
                }</span>
        }

        <span class="cov0" title="0">users, err := h.userService.ListUsers(c.Request.Context(), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to list users",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "users": users,
                "count": len(users),
        })</span>
}

// AuthenticateUser authenticates a user with email and password
func (h *UserHandler) AuthenticateUser(c *gin.Context) <span class="cov0" title="0">{
        var req AuthRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.AuthenticateUser(c.Request.Context(), req.Email, req.Password)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error":   "Authentication failed",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "message": "Authentication successful",
                "user":    user,
        })</span>
}

// healthCheck returns the health status of the service
func (h *UserHandler) healthCheck(c *gin.Context) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "status":    "healthy",
                "service":   "user-service",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
                "version":   "1.0.0",
        }

        c.JSON(http.StatusOK, response)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package metrics

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        // HTTP metrics
        httpRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "user_service_http_requests_total",
                        Help: "Total number of HTTP requests processed",
                },
                []string{"method", "endpoint", "status"},
        )

        httpRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "user_service_http_request_duration_seconds",
                        Help:    "Duration of HTTP requests in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        // Business metrics
        usersCreatedTotal = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "user_service_users_created_total",
                        Help: "Total number of users created",
                },
        )

        usersActiveTotal = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "user_service_users_active_total",
                        Help: "Total number of active users",
                },
        )

        databaseConnectionsActive = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "user_service_db_connections_active",
                        Help: "Number of active database connections",
                },
        )
)

// PrometheusMiddleware creates a Gin middleware for Prometheus metrics
func PrometheusMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Process request
                c.Next()

                // Record metrics
                duration := time.Since(start).Seconds()
                status := string(rune(c.Writer.Status()))

                httpRequestsTotal.WithLabelValues(
                        c.Request.Method,
                        c.FullPath(),
                        status,
                ).Inc()

                httpRequestDuration.WithLabelValues(
                        c.Request.Method,
                        c.FullPath(),
                ).Observe(duration)
        }</span>
}

// RecordUserCreated increments the users created counter
func RecordUserCreated() <span class="cov0" title="0">{
        usersCreatedTotal.Inc()
}</span>

// SetActiveUsers sets the current number of active users
func SetActiveUsers(count float64) <span class="cov0" title="0">{
        usersActiveTotal.Set(count)
}</span>

// SetDatabaseConnections sets the current number of database connections
func SetDatabaseConnections(count float64) <span class="cov0" title="0">{
        databaseConnectionsActive.Set(count)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/rideshare-platform/shared/models"
)

type UserRepository struct {
        db *sql.DB
}

func NewUserRepository(db *sql.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{
                db: db,
        }
}</span>

func (r *UserRepository) CreateUser(ctx context.Context, user *models.User) (*models.User, error) <span class="cov0" title="0">{
        // Generate UUID if not provided
        if user.ID == "" </span><span class="cov0" title="0">{
                user.ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO users (id, email, phone, password_hash, first_name, last_name, user_type, status, profile_image_url, email_verified, phone_verified)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                RETURNING created_at, updated_at`

        err := r.db.QueryRowContext(ctx, query,
                user.ID, user.Email, user.Phone, user.PasswordHash,
                user.FirstName, user.LastName, user.UserType, user.Status,
                user.ProfileImageURL, user.EmailVerified, user.PhoneVerified,
        ).Scan(&amp;user.CreatedAt, &amp;user.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetUser(ctx context.Context, id string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}

        query := `
                SELECT id, email, phone, password_hash, first_name, last_name, user_type, status, 
                       profile_image_url, email_verified, phone_verified, created_at, updated_at
                FROM users WHERE id = $1`

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.UserType, &amp;user.Status,
                &amp;user.ProfileImageURL, &amp;user.EmailVerified, &amp;user.PhoneVerified,
                &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}

        query := `
                SELECT id, email, phone, password_hash, first_name, last_name, user_type, status, 
                       profile_image_url, email_verified, phone_verified, created_at, updated_at
                FROM users WHERE email = $1`

        err := r.db.QueryRowContext(ctx, query, email).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.PasswordHash,
                &amp;user.FirstName, &amp;user.LastName, &amp;user.UserType, &amp;user.Status,
                &amp;user.ProfileImageURL, &amp;user.EmailVerified, &amp;user.PhoneVerified,
                &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by email: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) ListUsers(ctx context.Context, limit, offset int) ([]*models.User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, email, phone, password_hash, first_name, last_name, user_type, status, 
                       profile_image_url, email_verified, phone_verified, created_at, updated_at
                FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2`

        rows, err := r.db.QueryContext(ctx, query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list users: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*models.User
        for rows.Next() </span><span class="cov0" title="0">{
                user := &amp;models.User{}
                err := rows.Scan(
                        &amp;user.ID, &amp;user.Email, &amp;user.Phone, &amp;user.PasswordHash,
                        &amp;user.FirstName, &amp;user.LastName, &amp;user.UserType, &amp;user.Status,
                        &amp;user.ProfileImageURL, &amp;user.EmailVerified, &amp;user.PhoneVerified,
                        &amp;user.CreatedAt, &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">return users, nil</span>
}

func (r *UserRepository) UpdateUser(ctx context.Context, user *models.User) (*models.User, error) <span class="cov0" title="0">{
        user.UpdatedAt = time.Now()

        query := `
                UPDATE users SET 
                    email = $2, phone = $3, password_hash = $4, first_name = $5, last_name = $6,
                    user_type = $7, status = $8, profile_image_url = $9, email_verified = $10,
                    phone_verified = $11, updated_at = $12
                WHERE id = $1
                RETURNING updated_at`

        err := r.db.QueryRowContext(ctx, query,
                user.ID, user.Email, user.Phone, user.PasswordHash,
                user.FirstName, user.LastName, user.UserType, user.Status,
                user.ProfileImageURL, user.EmailVerified, user.PhoneVerified,
                user.UpdatedAt,
        ).Scan(&amp;user.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update user: %w", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

func (r *UserRepository) DeleteUser(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := `DELETE FROM users WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete user: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user not found")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "context"
        "errors"

        "github.com/rideshare-platform/services/user-service/internal/repository"
        "github.com/rideshare-platform/shared/models"
)

// UserService handles user business logic
type UserService struct {
        repo *repository.UserRepository
}

// NewUserService creates a new user service
func NewUserService(repo *repository.UserRepository) *UserService <span class="cov0" title="0">{
        return &amp;UserService{
                repo: repo,
        }
}</span>

// CreateUser creates a new user
func (s *UserService) CreateUser(ctx context.Context, user *models.User) (*models.User, error) <span class="cov0" title="0">{
        if user.Email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("user email is required")
        }</span>

        <span class="cov0" title="0">if user.FirstName == "" </span><span class="cov0" title="0">{
                return nil, errors.New("user first name is required")
        }</span>

        <span class="cov0" title="0">if user.LastName == "" </span><span class="cov0" title="0">{
                return nil, errors.New("user last name is required")
        }</span>

        // Check if user already exists by email
        <span class="cov0" title="0">existingUser, err := s.repo.GetUserByEmail(ctx, user.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existingUser != nil </span><span class="cov0" title="0">{
                return nil, errors.New("user with this email already exists")
        }</span>

        // Set defaults
        <span class="cov0" title="0">if user.UserType == "" </span><span class="cov0" title="0">{
                user.UserType = "rider"
        }</span>
        <span class="cov0" title="0">if user.Status == "" </span><span class="cov0" title="0">{
                user.Status = "active"
        }</span>

        <span class="cov0" title="0">return s.repo.CreateUser(ctx, user)</span>
}

// GetUser retrieves a user by ID
func (s *UserService) GetUser(ctx context.Context, userID string) (*models.User, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("user ID is required")
        }</span>

        <span class="cov0" title="0">return s.repo.GetUser(ctx, userID)</span>
}

// GetUserByEmail retrieves a user by email
func (s *UserService) GetUserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        if email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("email is required")
        }</span>

        <span class="cov0" title="0">return s.repo.GetUserByEmail(ctx, email)</span>
}

// UpdateUser updates an existing user
func (s *UserService) UpdateUser(ctx context.Context, user *models.User) (*models.User, error) <span class="cov0" title="0">{
        if user.ID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("user ID is required")
        }</span>

        // Check if user exists
        <span class="cov0" title="0">existingUser, err := s.repo.GetUser(ctx, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existingUser == nil </span><span class="cov0" title="0">{
                return nil, errors.New("user not found")
        }</span>

        // Update fields
        <span class="cov0" title="0">if user.Email != "" </span><span class="cov0" title="0">{
                existingUser.Email = user.Email
        }</span>
        <span class="cov0" title="0">if user.FirstName != "" </span><span class="cov0" title="0">{
                existingUser.FirstName = user.FirstName
        }</span>
        <span class="cov0" title="0">if user.LastName != "" </span><span class="cov0" title="0">{
                existingUser.LastName = user.LastName
        }</span>
        <span class="cov0" title="0">if user.Phone != "" </span><span class="cov0" title="0">{
                existingUser.Phone = user.Phone
        }</span>
        <span class="cov0" title="0">if user.Status != "" </span><span class="cov0" title="0">{
                existingUser.Status = user.Status
        }</span>
        <span class="cov0" title="0">if user.ProfileImageURL != "" </span><span class="cov0" title="0">{
                existingUser.ProfileImageURL = user.ProfileImageURL
        }</span>

        <span class="cov0" title="0">return s.repo.UpdateUser(ctx, existingUser)</span>
}

// DeleteUser deletes a user
func (s *UserService) DeleteUser(ctx context.Context, userID string) error <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return errors.New("user ID is required")
        }</span>

        <span class="cov0" title="0">return s.repo.DeleteUser(ctx, userID)</span>
}

// ListUsers lists all users
func (s *UserService) ListUsers(ctx context.Context, limit, offset int) ([]*models.User, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov0" title="0">return s.repo.ListUsers(ctx, limit, offset)</span>
}

// AuthenticateUser authenticates a user by email and password
func (s *UserService) AuthenticateUser(ctx context.Context, email, password string) (*models.User, error) <span class="cov0" title="0">{
        if email == "" </span><span class="cov0" title="0">{
                return nil, errors.New("email is required")
        }</span>
        <span class="cov0" title="0">if password == "" </span><span class="cov0" title="0">{
                return nil, errors.New("password is required")
        }</span>

        <span class="cov0" title="0">user, err := s.repo.GetUserByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if user == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid credentials")
        }</span>

        // TODO: Implement proper password hashing verification
        // For now, just return the user (this is not secure!)
        <span class="cov0" title="0">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        _ "github.com/lib/pq"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/rideshare-platform/services/user-service/internal/config"
        "github.com/rideshare-platform/services/user-service/internal/handler"
        "github.com/rideshare-platform/services/user-service/internal/metrics"
        "github.com/rideshare-platform/services/user-service/internal/repository"
        "github.com/rideshare-platform/services/user-service/internal/service"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Starting User Service on port %s", cfg.HTTPPort)

        // Connect to database
        dbConnectionString := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                cfg.DatabaseHost, cfg.DatabasePort, cfg.DatabaseUser,
                cfg.DatabasePassword, cfg.DatabaseName, cfg.DatabaseSSLMode)

        db, err := sql.Open("postgres", dbConnectionString)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Test database connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to ping database: %v", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Connected to PostgreSQL database")

        // Initialize repository and service
        userRepo := repository.NewUserRepository(db)
        userService := service.NewUserService(userRepo)

        // Initialize HTTP handler
        userHandler := handler.NewUserHandler(userService)

        // Setup HTTP server
        gin.SetMode(gin.ReleaseMode)
        router := gin.New()
        router.Use(gin.Recovery())
        router.Use(metrics.PrometheusMiddleware())

        // Register routes
        userHandler.RegisterRoutes(router)

        router.GET("/ready", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "ready"})
        }</span>)

        // Prometheus metrics endpoint
        <span class="cov0" title="0">router.GET("/api/v1/metrics", gin.WrapH(promhttp.Handler()))

        server := &amp;http.Server{
                Addr:    ":" + cfg.HTTPPort,
                Handler: router,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                log.Printf("HTTP server listening on port %s", cfg.HTTPPort)
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start HTTP server: %v", err)
                }</span>
        }()

        // Wait for interrupt signal to gracefully shutdown the server
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        log.Println("Shutting down server...")

        // The context is used to inform the server it has 5 seconds to finish
        // the request it is currently handling
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server forced to shutdown:", err)
        }</span>

        <span class="cov0" title="0">log.Println("Server exiting")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

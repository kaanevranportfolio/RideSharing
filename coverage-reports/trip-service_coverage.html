
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rideshare-platform/services/trip-service/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/rideshare-platform/services/trip-service/internal/handler/grpc_trip_handler.go (0.0%)</option>
				
				<option value="file2">github.com/rideshare-platform/services/trip-service/internal/repository/event_store.go (0.0%)</option>
				
				<option value="file3">github.com/rideshare-platform/services/trip-service/internal/repository/mock_repositories.go (0.0%)</option>
				
				<option value="file4">github.com/rideshare-platform/services/trip-service/internal/repository/mongo_repository.go (0.0%)</option>
				
				<option value="file5">github.com/rideshare-platform/services/trip-service/internal/service/basic_trip_service.go (0.0%)</option>
				
				<option value="file6">github.com/rideshare-platform/services/trip-service/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "os"
        "strconv"
)

// Config holds all configuration for the trip service
type Config struct {
        HTTPPort    string
        Environment string
        LogLevel    string

        // Database config
        DatabaseHost     string
        DatabasePort     int
        DatabaseName     string
        DatabaseUser     string
        DatabasePassword string

        // MongoDB config
        MongoURI      string
        MongoDatabase string

        // Redis config
        RedisHost     string
        RedisPort     int
        RedisPassword string
        RedisDatabase int

        // Trip service parameters
        MaxActiveTripDuration int    // hours
        TripTimeoutMinutes    int    // minutes
        CancellationWindow    int    // minutes after booking
        MaxPassengerCount     int    // maximum passengers per trip
        DefaultCurrency       string // default currency code
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        return &amp;Config{
                HTTPPort:    getEnv("HTTP_PORT", "8085"),
                Environment: getEnv("ENVIRONMENT", "development"),
                LogLevel:    getEnv("LOG_LEVEL", "info"),

                // Database config
                DatabaseHost:     getEnv("DB_HOST", "localhost"),
                DatabasePort:     getEnvInt("DB_PORT", 5432),
                DatabaseName:     getEnv("DB_NAME", "rideshare"),
                DatabaseUser:     getEnv("DB_USER", "rideshare_user"),
                DatabasePassword: getEnv("DB_PASSWORD", "rideshare_password"),

                // MongoDB config
                MongoURI:      getEnv("MONGO_URI", "mongodb://localhost:27017"),
                MongoDatabase: getEnv("MONGO_DB", "rideshare"),

                // Redis config
                RedisHost:     getEnv("REDIS_HOST", "localhost"),
                RedisPort:     getEnvInt("REDIS_PORT", 6379),
                RedisPassword: getEnv("REDIS_PASSWORD", ""),
                RedisDatabase: getEnvInt("REDIS_DB", 0),

                // Trip parameters
                MaxActiveTripDuration: getEnvInt("MAX_ACTIVE_TRIP_DURATION", 24),
                TripTimeoutMinutes:    getEnvInt("TRIP_TIMEOUT_MINUTES", 30),
                CancellationWindow:    getEnvInt("CANCELLATION_WINDOW", 5),
                MaxPassengerCount:     getEnvInt("MAX_PASSENGER_COUNT", 4),
                DefaultCurrency:       getEnv("DEFAULT_CURRENCY", "USD"),
        }, nil
}</span>

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        // Add validation logic here if needed
        return nil
}</span>

// getEnv gets an environment variable with a default value
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// getEnvInt gets an environment variable as int with a default value
func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return parsed
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handler

import (
        "context"
        "strings"
        "sync"
        "time"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/rideshare-platform/services/trip-service/internal/service"
        "github.com/rideshare-platform/shared/logger"
        trippb "github.com/rideshare-platform/shared/proto/trip"
)

// GRPCTripHandler handles gRPC requests for trip service
type GRPCTripHandler struct {
        trippb.UnimplementedTripServiceServer
        tripService service.BasicTripService
        logger      *logger.Logger

        // Subscription management
        subscriptions map[string][]chan *trippb.TripUpdateEvent
        subMutex      sync.RWMutex
}

func NewGRPCTripHandler(tripService service.BasicTripService, logger *logger.Logger) *GRPCTripHandler <span class="cov0" title="0">{
        return &amp;GRPCTripHandler{
                tripService:   tripService,
                logger:        logger,
                subscriptions: make(map[string][]chan *trippb.TripUpdateEvent),
        }
}</span>

// SubscribeToTripUpdates implements real-time trip updates streaming
func (h *GRPCTripHandler) SubscribeToTripUpdates(req *trippb.SubscribeToTripUpdatesRequest, stream trippb.TripService_SubscribeToTripUpdatesServer) error <span class="cov0" title="0">{
        h.logger.WithFields(logger.Fields{
                "trip_id": req.TripId,
                "user_id": req.UserId,
        }).Info("New trip subscription")

        // Create a channel for this subscription
        updateChan := make(chan *trippb.TripUpdateEvent, 10)

        // Register the subscription
        h.subMutex.Lock()
        if _, exists := h.subscriptions[req.TripId]; !exists </span><span class="cov0" title="0">{
                h.subscriptions[req.TripId] = make([]chan *trippb.TripUpdateEvent, 0)
        }</span>
        <span class="cov0" title="0">h.subscriptions[req.TripId] = append(h.subscriptions[req.TripId], updateChan)
        h.subMutex.Unlock()

        // Cleanup function
        defer func() </span><span class="cov0" title="0">{
                h.subMutex.Lock()
                if subscribers, exists := h.subscriptions[req.TripId]; exists </span><span class="cov0" title="0">{
                        // Remove this channel from subscribers
                        for i, ch := range subscribers </span><span class="cov0" title="0">{
                                if ch == updateChan </span><span class="cov0" title="0">{
                                        h.subscriptions[req.TripId] = append(subscribers[:i], subscribers[i+1:]...)
                                        break</span>
                                }
                        }
                        // If no more subscribers, remove the trip from subscriptions
                        <span class="cov0" title="0">if len(h.subscriptions[req.TripId]) == 0 </span><span class="cov0" title="0">{
                                delete(h.subscriptions, req.TripId)
                        }</span>
                }
                <span class="cov0" title="0">h.subMutex.Unlock()
                close(updateChan)

                h.logger.WithFields(logger.Fields{
                        "trip_id": req.TripId,
                        "user_id": req.UserId,
                }).Info("Trip subscription closed")</span>
        }()

        // Send initial trip status
        <span class="cov0" title="0">trip, err := h.tripService.GetTrip(stream.Context(), req.TripId)
        if err != nil </span><span class="cov0" title="0">{
                return status.Errorf(codes.NotFound, "Trip not found: %v", err)
        }</span>

        // Convert trip status to proto enum
        <span class="cov0" title="0">currentStatus := convertToProtoStatus(trip.Status)

        initialEvent := &amp;trippb.TripUpdateEvent{
                TripId:    req.TripId,
                OldStatus: currentStatus,
                NewStatus: currentStatus,
                Timestamp: timestamppb.New(trip.UpdatedAt),
                Metadata: map[string]string{
                        "rider_id":   trip.RiderID,
                        "driver_id":  trip.DriverID,
                        "event_type": "initial_status",
                },
        }

        if err := stream.Send(initialEvent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Listen for updates on this trip
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-stream.Context().Done():<span class="cov0" title="0">
                        return stream.Context().Err()</span>
                case event, ok := &lt;-updateChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return nil // Channel closed
                        }</span>
                        <span class="cov0" title="0">if err := stream.Send(event); err != nil </span><span class="cov0" title="0">{
                                h.logger.WithError(err).Error("Failed to send trip update")
                                return err
                        }</span>
                case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                        // Send heartbeat to keep connection alive
                        heartbeat := &amp;trippb.TripUpdateEvent{
                                TripId:    req.TripId,
                                OldStatus: currentStatus,
                                NewStatus: currentStatus,
                                Timestamp: timestamppb.New(time.Now()),
                                Metadata: map[string]string{
                                        "event_type": "heartbeat",
                                },
                        }
                        if err := stream.Send(heartbeat); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
}

// NotifyTripUpdate sends an update to all subscribers of a trip
func (h *GRPCTripHandler) NotifyTripUpdate(tripID string, oldStatus, newStatus trippb.TripStatus, metadata map[string]string) <span class="cov0" title="0">{
        h.subMutex.RLock()
        subscribers, exists := h.subscriptions[tripID]
        h.subMutex.RUnlock()

        if !exists || len(subscribers) == 0 </span><span class="cov0" title="0">{
                return // No subscribers
        }</span>

        <span class="cov0" title="0">event := &amp;trippb.TripUpdateEvent{
                TripId:    tripID,
                OldStatus: oldStatus,
                NewStatus: newStatus,
                Timestamp: timestamppb.New(time.Now()),
                Metadata:  metadata,
        }

        h.logger.WithFields(logger.Fields{
                "trip_id":          tripID,
                "old_status":       oldStatus.String(),
                "new_status":       newStatus.String(),
                "subscriber_count": len(subscribers),
        }).Debug("Broadcasting trip update")

        // Send to all subscribers (non-blocking)
        for _, ch := range subscribers </span><span class="cov0" title="0">{
                select </span>{
                case ch &lt;- event:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0">
                        // Channel is full, skip this subscriber
                        h.logger.WithFields(logger.Fields{
                                "trip_id": tripID,
                        }).Warn("Subscriber channel full, skipping update")</span>
                }
        }
}

// GetTrip implements gRPC method for getting trip details
func (h *GRPCTripHandler) GetTrip(ctx context.Context, req *trippb.GetTripRequest) (*trippb.GetTripResponse, error) <span class="cov0" title="0">{
        trip, err := h.tripService.GetTrip(ctx, req.TripId)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;trippb.GetTripResponse{
                        Found: false,
                }, nil
        }</span>

        // Convert internal trip to proto trip
        <span class="cov0" title="0">protoTrip := convertToProtoTrip(trip)

        return &amp;trippb.GetTripResponse{
                Trip:  protoTrip,
                Found: true,
        }, nil</span>
}

// UpdateTripStatus implements gRPC method for updating trip status
func (h *GRPCTripHandler) UpdateTripStatus(ctx context.Context, req *trippb.UpdateTripStatusRequest) (*trippb.UpdateTripStatusResponse, error) <span class="cov0" title="0">{
        // Validate the request
        if req.TripId == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "Trip ID is required")
        }</span>

        // Get current trip for comparison
        <span class="cov0" title="0">trip, err := h.tripService.GetTrip(ctx, req.TripId)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;trippb.UpdateTripStatusResponse{
                        Success: false,
                        Message: "Trip not found",
                }, nil
        }</span>

        <span class="cov0" title="0">oldStatus := convertToProtoStatus(trip.Status)
        newStatus := req.Status

        // Notify subscribers about the status change
        metadata := map[string]string{
                "previous_status": oldStatus.String(),
                "reason":          req.Reason,
                "updated_by":      req.DriverId,
                "event_type":      "status_change",
        }

        h.NotifyTripUpdate(req.TripId, oldStatus, newStatus, metadata)

        // Update the trip (this would typically call a proper update method)
        // For now, we'll just return success
        updatedTrip := convertToProtoTrip(trip)

        return &amp;trippb.UpdateTripStatusResponse{
                Trip:    updatedTrip,
                Success: true,
                Message: "Trip status updated successfully",
        }, nil</span>
}

// GetSubscriptionStats returns statistics about active subscriptions
func (h *GRPCTripHandler) GetSubscriptionStats() map[string]int <span class="cov0" title="0">{
        h.subMutex.RLock()
        defer h.subMutex.RUnlock()

        stats := make(map[string]int)
        for tripID, subscribers := range h.subscriptions </span><span class="cov0" title="0">{
                stats[tripID] = len(subscribers)
        }</span>
        <span class="cov0" title="0">return stats</span>
}

// Helper function to convert internal trip status to proto status
func convertToProtoStatus(status string) trippb.TripStatus <span class="cov0" title="0">{
        switch strings.ToLower(status) </span>{
        case "requested":<span class="cov0" title="0">
                return trippb.TripStatus_REQUESTED</span>
        case "matched":<span class="cov0" title="0">
                return trippb.TripStatus_MATCHED</span>
        case "driver_en_route":<span class="cov0" title="0">
                return trippb.TripStatus_DRIVER_EN_ROUTE</span>
        case "driver_arrived":<span class="cov0" title="0">
                return trippb.TripStatus_DRIVER_ARRIVED</span>
        case "started":<span class="cov0" title="0">
                return trippb.TripStatus_TRIP_STARTED</span>
        case "in_progress":<span class="cov0" title="0">
                return trippb.TripStatus_IN_PROGRESS</span>
        case "completed":<span class="cov0" title="0">
                return trippb.TripStatus_COMPLETED</span>
        case "cancelled":<span class="cov0" title="0">
                return trippb.TripStatus_CANCELLED_BY_RIDER</span>
        case "failed":<span class="cov0" title="0">
                return trippb.TripStatus_FAILED</span>
        default:<span class="cov0" title="0">
                return trippb.TripStatus_UNKNOWN_STATUS</span>
        }
}

// Helper function to convert internal trip to proto trip
func convertToProtoTrip(trip *service.BasicTrip) *trippb.Trip <span class="cov0" title="0">{
        return &amp;trippb.Trip{
                Id:       trip.ID,
                RiderId:  trip.RiderID,
                DriverId: trip.DriverID,
                Status:   convertToProtoStatus(trip.Status),
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package repository

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "time"

        "github.com/rideshare-platform/services/trip-service/internal/types"
        "github.com/rideshare-platform/shared/logger"
)

// PostgreSQLEventStore implements TripEventStore using PostgreSQL
type PostgreSQLEventStore struct {
        db     *sql.DB
        logger logger.Logger
}

// NewPostgreSQLEventStore creates a new PostgreSQL event store
func NewPostgreSQLEventStore(db *sql.DB, logger logger.Logger) *PostgreSQLEventStore <span class="cov0" title="0">{
        return &amp;PostgreSQLEventStore{
                db:     db,
                logger: logger,
        }
}</span>

// SaveEvent saves a trip event to the event store
func (s *PostgreSQLEventStore) SaveEvent(ctx context.Context, event *types.TripEvent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO trip_events (id, trip_id, event_type, event_data, timestamp, version, user_id)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
        `

        eventData, err := json.Marshal(event.Data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event data: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = s.db.ExecContext(ctx, query,
                event.ID,
                event.TripID,
                string(event.Type),
                eventData,
                event.Timestamp,
                event.Version,
                event.UserID,
        )

        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).WithFields(logger.Fields{
                        "event_id": event.ID,
                        "trip_id":  event.TripID,
                        "type":     event.Type,
                }).Error("Failed to save trip event")
                return fmt.Errorf("failed to save event: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logger.Fields{
                "event_id": event.ID,
                "trip_id":  event.TripID,
                "type":     event.Type,
                "version":  event.Version,
        }).Debug("Trip event saved successfully")

        return nil</span>
}

// GetEvents retrieves all events for a trip
func (s *PostgreSQLEventStore) GetEvents(ctx context.Context, tripID string) ([]*types.TripEvent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, trip_id, event_type, event_data, timestamp, version, user_id
                FROM trip_events
                WHERE trip_id = $1
                ORDER BY version ASC
        `

        rows, err := s.db.QueryContext(ctx, query, tripID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query events: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []*types.TripEvent

        for rows.Next() </span><span class="cov0" title="0">{
                var event types.TripEvent
                var eventDataJSON []byte
                var userID sql.NullString

                err := rows.Scan(
                        &amp;event.ID,
                        &amp;event.TripID,
                        &amp;event.Type,
                        &amp;eventDataJSON,
                        &amp;event.Timestamp,
                        &amp;event.Version,
                        &amp;userID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan event: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(eventDataJSON, &amp;event.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal event data: %w", err)
                }</span>

                <span class="cov0" title="0">if userID.Valid </span><span class="cov0" title="0">{
                        event.UserID = userID.String
                }</span>

                <span class="cov0" title="0">events = append(events, &amp;event)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating events: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// GetEventsAfterVersion retrieves events for a trip after a specific version
func (s *PostgreSQLEventStore) GetEventsAfterVersion(ctx context.Context, tripID string, version int) ([]*types.TripEvent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, trip_id, event_type, event_data, timestamp, version, user_id
                FROM trip_events
                WHERE trip_id = $1 AND version &gt; $2
                ORDER BY version ASC
        `

        rows, err := s.db.QueryContext(ctx, query, tripID, version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query events after version: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []*types.TripEvent

        for rows.Next() </span><span class="cov0" title="0">{
                var event types.TripEvent
                var eventDataJSON []byte
                var userID sql.NullString

                err := rows.Scan(
                        &amp;event.ID,
                        &amp;event.TripID,
                        &amp;event.Type,
                        &amp;eventDataJSON,
                        &amp;event.Timestamp,
                        &amp;event.Version,
                        &amp;userID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan event: %w", err)
                }</span>

                <span class="cov0" title="0">if err := json.Unmarshal(eventDataJSON, &amp;event.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal event data: %w", err)
                }</span>

                <span class="cov0" title="0">if userID.Valid </span><span class="cov0" title="0">{
                        event.UserID = userID.String
                }</span>

                <span class="cov0" title="0">events = append(events, &amp;event)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating events after version: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// PostgreSQLTripReadModel implements TripReadModel using PostgreSQL
type PostgreSQLTripReadModel struct {
        db     *sql.DB
        logger logger.Logger
}

// NewPostgreSQLTripReadModel creates a new PostgreSQL read model
func NewPostgreSQLTripReadModel(db *sql.DB, logger logger.Logger) *PostgreSQLTripReadModel <span class="cov0" title="0">{
        return &amp;PostgreSQLTripReadModel{
                db:     db,
                logger: logger,
        }
}</span>

// SaveTrip saves a trip aggregate to the read model
func (r *PostgreSQLTripReadModel) SaveTrip(ctx context.Context, trip *types.TripAggregate) error <span class="cov0" title="0">{
        query := `
                INSERT INTO trips (
                        id, rider_id, driver_id, vehicle_id, state, pickup_location, destination_location,
                        current_location, requested_at, matched_at, started_at, completed_at, cancelled_at,
                        estimated_fare, actual_fare, distance, duration, rating, vehicle_type, payment_method,
                        metadata, version, last_updated
                ) VALUES (
                        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
                )
                ON CONFLICT (id) DO UPDATE SET
                        driver_id = EXCLUDED.driver_id,
                        vehicle_id = EXCLUDED.vehicle_id,
                        state = EXCLUDED.state,
                        current_location = EXCLUDED.current_location,
                        matched_at = EXCLUDED.matched_at,
                        started_at = EXCLUDED.started_at,
                        completed_at = EXCLUDED.completed_at,
                        cancelled_at = EXCLUDED.cancelled_at,
                        estimated_fare = EXCLUDED.estimated_fare,
                        actual_fare = EXCLUDED.actual_fare,
                        distance = EXCLUDED.distance,
                        duration = EXCLUDED.duration,
                        rating = EXCLUDED.rating,
                        metadata = EXCLUDED.metadata,
                        version = EXCLUDED.version,
                        last_updated = EXCLUDED.last_updated
                WHERE trips.version &lt; EXCLUDED.version
        `

        pickupLocationJSON, _ := json.Marshal(trip.PickupLocation)
        destinationLocationJSON, _ := json.Marshal(trip.DestinationLocation)
        currentLocationJSON, _ := json.Marshal(trip.CurrentLocation)
        metadataJSON, _ := json.Marshal(trip.Metadata)

        var durationSeconds sql.NullFloat64
        if trip.Duration != nil </span><span class="cov0" title="0">{
                durationSeconds.Valid = true
                durationSeconds.Float64 = trip.Duration.Seconds()
        }</span>

        <span class="cov0" title="0">_, err := r.db.ExecContext(ctx, query,
                trip.ID,
                trip.RiderID,
                stringToNullString(trip.DriverID),
                stringToNullString(trip.VehicleID),
                string(trip.State),
                pickupLocationJSON,
                destinationLocationJSON,
                nullableJSON(currentLocationJSON),
                trip.RequestedAt,
                timeToNullTime(trip.MatchedAt),
                timeToNullTime(trip.StartedAt),
                timeToNullTime(trip.CompletedAt),
                timeToNullTime(trip.CancelledAt),
                float64ToNullFloat64(trip.EstimatedFare),
                float64ToNullFloat64(trip.ActualFare),
                float64ToNullFloat64(trip.Distance),
                durationSeconds,
                float64ToNullFloat64(trip.Rating),
                trip.VehicleType,
                trip.PaymentMethod,
                metadataJSON,
                trip.Version,
                trip.LastUpdated,
        )

        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).WithField("trip_id", trip.ID).Error("Failed to save trip to read model")
                return fmt.Errorf("failed to save trip: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTrip retrieves a trip by ID from the read model
func (r *PostgreSQLTripReadModel) GetTrip(ctx context.Context, tripID string) (*types.TripAggregate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, rider_id, driver_id, vehicle_id, state, pickup_location, destination_location,
                        current_location, requested_at, matched_at, started_at, completed_at, cancelled_at,
                        estimated_fare, actual_fare, distance, duration, rating, vehicle_type, payment_method,
                        metadata, version, last_updated
                FROM trips
                WHERE id = $1
        `

        row := r.db.QueryRowContext(ctx, query, tripID)

        trip, err := r.scanTrip(row)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get trip: %w", err)
        }</span>

        <span class="cov0" title="0">return trip, nil</span>
}

// GetTripsByRider retrieves trips for a specific rider
func (r *PostgreSQLTripReadModel) GetTripsByRider(ctx context.Context, riderID string, limit, offset int) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, rider_id, driver_id, vehicle_id, state, pickup_location, destination_location,
                        current_location, requested_at, matched_at, started_at, completed_at, cancelled_at,
                        estimated_fare, actual_fare, distance, duration, rating, vehicle_type, payment_method,
                        metadata, version, last_updated
                FROM trips
                WHERE rider_id = $1
                ORDER BY requested_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, riderID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query trips by rider: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanTrips(rows)</span>
}

// GetTripsByDriver retrieves trips for a specific driver
func (r *PostgreSQLTripReadModel) GetTripsByDriver(ctx context.Context, driverID string, limit, offset int) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, rider_id, driver_id, vehicle_id, state, pickup_location, destination_location,
                        current_location, requested_at, matched_at, started_at, completed_at, cancelled_at,
                        estimated_fare, actual_fare, distance, duration, rating, vehicle_type, payment_method,
                        metadata, version, last_updated
                FROM trips
                WHERE driver_id = $1
                ORDER BY requested_at DESC
                LIMIT $2 OFFSET $3
        `

        rows, err := r.db.QueryContext(ctx, query, driverID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query trips by driver: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanTrips(rows)</span>
}

// GetActiveTrips retrieves all currently active trips
func (r *PostgreSQLTripReadModel) GetActiveTrips(ctx context.Context) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        query := `
                SELECT id, rider_id, driver_id, vehicle_id, state, pickup_location, destination_location,
                        current_location, requested_at, matched_at, started_at, completed_at, cancelled_at,
                        estimated_fare, actual_fare, distance, duration, rating, vehicle_type, payment_method,
                        metadata, version, last_updated
                FROM trips
                WHERE state NOT IN ('completed', 'cancelled')
                ORDER BY requested_at ASC
        `

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query active trips: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        return r.scanTrips(rows)</span>
}

// Helper methods

func (r *PostgreSQLTripReadModel) scanTrip(row *sql.Row) (*types.TripAggregate, error) <span class="cov0" title="0">{
        var trip types.TripAggregate
        var driverID, vehicleID sql.NullString
        var pickupLocationJSON, destinationLocationJSON, currentLocationJSON, metadataJSON []byte
        var matchedAt, startedAt, completedAt, cancelledAt sql.NullTime
        var estimatedFare, actualFare, distance, rating sql.NullFloat64
        var duration sql.NullFloat64

        err := row.Scan(
                &amp;trip.ID,
                &amp;trip.RiderID,
                &amp;driverID,
                &amp;vehicleID,
                &amp;trip.State,
                &amp;pickupLocationJSON,
                &amp;destinationLocationJSON,
                &amp;currentLocationJSON,
                &amp;trip.RequestedAt,
                &amp;matchedAt,
                &amp;startedAt,
                &amp;completedAt,
                &amp;cancelledAt,
                &amp;estimatedFare,
                &amp;actualFare,
                &amp;distance,
                &amp;duration,
                &amp;rating,
                &amp;trip.VehicleType,
                &amp;trip.PaymentMethod,
                &amp;metadataJSON,
                &amp;trip.Version,
                &amp;trip.LastUpdated,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Handle nullable fields
        <span class="cov0" title="0">if driverID.Valid </span><span class="cov0" title="0">{
                trip.DriverID = driverID.String
        }</span>
        <span class="cov0" title="0">if vehicleID.Valid </span><span class="cov0" title="0">{
                trip.VehicleID = vehicleID.String
        }</span>
        <span class="cov0" title="0">if matchedAt.Valid </span><span class="cov0" title="0">{
                trip.MatchedAt = &amp;matchedAt.Time
        }</span>
        <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                trip.StartedAt = &amp;startedAt.Time
        }</span>
        <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                trip.CompletedAt = &amp;completedAt.Time
        }</span>
        <span class="cov0" title="0">if cancelledAt.Valid </span><span class="cov0" title="0">{
                trip.CancelledAt = &amp;cancelledAt.Time
        }</span>
        <span class="cov0" title="0">if estimatedFare.Valid </span><span class="cov0" title="0">{
                trip.EstimatedFare = &amp;estimatedFare.Float64
        }</span>
        <span class="cov0" title="0">if actualFare.Valid </span><span class="cov0" title="0">{
                trip.ActualFare = &amp;actualFare.Float64
        }</span>
        <span class="cov0" title="0">if distance.Valid </span><span class="cov0" title="0">{
                trip.Distance = &amp;distance.Float64
        }</span>
        <span class="cov0" title="0">if duration.Valid </span><span class="cov0" title="0">{
                dur := time.Duration(duration.Float64) * time.Second
                trip.Duration = &amp;dur
        }</span>
        <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                trip.Rating = &amp;rating.Float64
        }</span>

        // Unmarshal JSON fields
        <span class="cov0" title="0">if len(pickupLocationJSON) &gt; 0 </span><span class="cov0" title="0">{
                json.Unmarshal(pickupLocationJSON, &amp;trip.PickupLocation)
        }</span>
        <span class="cov0" title="0">if len(destinationLocationJSON) &gt; 0 </span><span class="cov0" title="0">{
                json.Unmarshal(destinationLocationJSON, &amp;trip.DestinationLocation)
        }</span>
        <span class="cov0" title="0">if len(currentLocationJSON) &gt; 0 </span><span class="cov0" title="0">{
                json.Unmarshal(currentLocationJSON, &amp;trip.CurrentLocation)
        }</span>
        <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                json.Unmarshal(metadataJSON, &amp;trip.Metadata)
        }</span>

        <span class="cov0" title="0">return &amp;trip, nil</span>
}

func (r *PostgreSQLTripReadModel) scanTrips(rows *sql.Rows) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        var trips []*types.TripAggregate

        for rows.Next() </span><span class="cov0" title="0">{
                var trip types.TripAggregate
                var driverID, vehicleID sql.NullString
                var pickupLocationJSON, destinationLocationJSON, currentLocationJSON, metadataJSON []byte
                var matchedAt, startedAt, completedAt, cancelledAt sql.NullTime
                var estimatedFare, actualFare, distance, rating sql.NullFloat64
                var duration sql.NullFloat64

                err := rows.Scan(
                        &amp;trip.ID,
                        &amp;trip.RiderID,
                        &amp;driverID,
                        &amp;vehicleID,
                        &amp;trip.State,
                        &amp;pickupLocationJSON,
                        &amp;destinationLocationJSON,
                        &amp;currentLocationJSON,
                        &amp;trip.RequestedAt,
                        &amp;matchedAt,
                        &amp;startedAt,
                        &amp;completedAt,
                        &amp;cancelledAt,
                        &amp;estimatedFare,
                        &amp;actualFare,
                        &amp;distance,
                        &amp;duration,
                        &amp;rating,
                        &amp;trip.VehicleType,
                        &amp;trip.PaymentMethod,
                        &amp;metadataJSON,
                        &amp;trip.Version,
                        &amp;trip.LastUpdated,
                )

                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan trip: %w", err)
                }</span>

                // Handle nullable fields (same as scanTrip)
                <span class="cov0" title="0">if driverID.Valid </span><span class="cov0" title="0">{
                        trip.DriverID = driverID.String
                }</span>
                <span class="cov0" title="0">if vehicleID.Valid </span><span class="cov0" title="0">{
                        trip.VehicleID = vehicleID.String
                }</span>
                <span class="cov0" title="0">if matchedAt.Valid </span><span class="cov0" title="0">{
                        trip.MatchedAt = &amp;matchedAt.Time
                }</span>
                <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                        trip.StartedAt = &amp;startedAt.Time
                }</span>
                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        trip.CompletedAt = &amp;completedAt.Time
                }</span>
                <span class="cov0" title="0">if cancelledAt.Valid </span><span class="cov0" title="0">{
                        trip.CancelledAt = &amp;cancelledAt.Time
                }</span>
                <span class="cov0" title="0">if estimatedFare.Valid </span><span class="cov0" title="0">{
                        trip.EstimatedFare = &amp;estimatedFare.Float64
                }</span>
                <span class="cov0" title="0">if actualFare.Valid </span><span class="cov0" title="0">{
                        trip.ActualFare = &amp;actualFare.Float64
                }</span>
                <span class="cov0" title="0">if distance.Valid </span><span class="cov0" title="0">{
                        trip.Distance = &amp;distance.Float64
                }</span>
                <span class="cov0" title="0">if duration.Valid </span><span class="cov0" title="0">{
                        dur := time.Duration(duration.Float64) * time.Second
                        trip.Duration = &amp;dur
                }</span>
                <span class="cov0" title="0">if rating.Valid </span><span class="cov0" title="0">{
                        trip.Rating = &amp;rating.Float64
                }</span>

                // Unmarshal JSON fields
                <span class="cov0" title="0">if len(pickupLocationJSON) &gt; 0 </span><span class="cov0" title="0">{
                        json.Unmarshal(pickupLocationJSON, &amp;trip.PickupLocation)
                }</span>
                <span class="cov0" title="0">if len(destinationLocationJSON) &gt; 0 </span><span class="cov0" title="0">{
                        json.Unmarshal(destinationLocationJSON, &amp;trip.DestinationLocation)
                }</span>
                <span class="cov0" title="0">if len(currentLocationJSON) &gt; 0 </span><span class="cov0" title="0">{
                        json.Unmarshal(currentLocationJSON, &amp;trip.CurrentLocation)
                }</span>
                <span class="cov0" title="0">if len(metadataJSON) &gt; 0 </span><span class="cov0" title="0">{
                        json.Unmarshal(metadataJSON, &amp;trip.Metadata)
                }</span>

                <span class="cov0" title="0">trips = append(trips, &amp;trip)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating trips: %w", err)
        }</span>

        <span class="cov0" title="0">return trips, nil</span>
}

// Helper functions for nullable types
func stringToNullString(s string) sql.NullString <span class="cov0" title="0">{
        if s == "" </span><span class="cov0" title="0">{
                return sql.NullString{Valid: false}
        }</span>
        <span class="cov0" title="0">return sql.NullString{String: s, Valid: true}</span>
}

func timeToNullTime(t *time.Time) sql.NullTime <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return sql.NullTime{Valid: false}
        }</span>
        <span class="cov0" title="0">return sql.NullTime{Time: *t, Valid: true}</span>
}

func float64ToNullFloat64(f *float64) sql.NullFloat64 <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return sql.NullFloat64{Valid: false}
        }</span>
        <span class="cov0" title="0">return sql.NullFloat64{Float64: *f, Valid: true}</span>
}

func nullableJSON(data []byte) interface{} <span class="cov0" title="0">{
        if len(data) == 0 || string(data) == "null" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return data</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package repository

import (
        "context"
        "fmt"

        "github.com/rideshare-platform/services/trip-service/internal/types"
)

// MockEventStore implements TripEventStore for testing
type MockEventStore struct {
        events map[string][]*types.TripEvent
}

// NewMockEventStore creates a new mock event store
func NewMockEventStore() *MockEventStore <span class="cov0" title="0">{
        return &amp;MockEventStore{
                events: make(map[string][]*types.TripEvent),
        }
}</span>

// SaveEvent saves an event to memory
func (m *MockEventStore) SaveEvent(ctx context.Context, event *types.TripEvent) error <span class="cov0" title="0">{
        if _, exists := m.events[event.TripID]; !exists </span><span class="cov0" title="0">{
                m.events[event.TripID] = []*types.TripEvent{}
        }</span>
        <span class="cov0" title="0">m.events[event.TripID] = append(m.events[event.TripID], event)
        return nil</span>
}

// GetEvents returns all events for a trip
func (m *MockEventStore) GetEvents(ctx context.Context, tripID string) ([]*types.TripEvent, error) <span class="cov0" title="0">{
        events, exists := m.events[tripID]
        if !exists </span><span class="cov0" title="0">{
                return []*types.TripEvent{}, nil
        }</span>
        <span class="cov0" title="0">return events, nil</span>
}

// GetEventsAfterVersion returns events after a specific version
func (m *MockEventStore) GetEventsAfterVersion(ctx context.Context, tripID string, version int) ([]*types.TripEvent, error) <span class="cov0" title="0">{
        allEvents, err := m.GetEvents(ctx, tripID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var filteredEvents []*types.TripEvent
        for _, event := range allEvents </span><span class="cov0" title="0">{
                if event.Version &gt; version </span><span class="cov0" title="0">{
                        filteredEvents = append(filteredEvents, event)
                }</span>
        }
        <span class="cov0" title="0">return filteredEvents, nil</span>
}

// MockReadModel implements TripReadModel for testing
type MockReadModel struct {
        trips map[string]*types.TripAggregate
}

// NewMockReadModel creates a new mock read model
func NewMockReadModel() *MockReadModel <span class="cov0" title="0">{
        return &amp;MockReadModel{
                trips: make(map[string]*types.TripAggregate),
        }
}</span>

// SaveTrip saves a trip to memory
func (m *MockReadModel) SaveTrip(ctx context.Context, trip *types.TripAggregate) error <span class="cov0" title="0">{
        m.trips[trip.ID] = trip
        return nil
}</span>

// GetTrip retrieves a trip by ID
func (m *MockReadModel) GetTrip(ctx context.Context, tripID string) (*types.TripAggregate, error) <span class="cov0" title="0">{
        trip, exists := m.trips[tripID]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("trip not found: %s", tripID)
        }</span>
        <span class="cov0" title="0">return trip, nil</span>
}

// GetTripsByRider retrieves trips for a rider
func (m *MockReadModel) GetTripsByRider(ctx context.Context, riderID string, limit, offset int) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        var trips []*types.TripAggregate
        count := 0

        for _, trip := range m.trips </span><span class="cov0" title="0">{
                if trip.RiderID == riderID </span><span class="cov0" title="0">{
                        if count &gt;= offset &amp;&amp; len(trips) &lt; limit </span><span class="cov0" title="0">{
                                trips = append(trips, trip)
                        }</span>
                        <span class="cov0" title="0">count++</span>
                }
        }
        <span class="cov0" title="0">return trips, nil</span>
}

// GetTripsByDriver retrieves trips for a driver
func (m *MockReadModel) GetTripsByDriver(ctx context.Context, driverID string, limit, offset int) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        var trips []*types.TripAggregate
        count := 0

        for _, trip := range m.trips </span><span class="cov0" title="0">{
                if trip.DriverID == driverID </span><span class="cov0" title="0">{
                        if count &gt;= offset &amp;&amp; len(trips) &lt; limit </span><span class="cov0" title="0">{
                                trips = append(trips, trip)
                        }</span>
                        <span class="cov0" title="0">count++</span>
                }
        }
        <span class="cov0" title="0">return trips, nil</span>
}

// GetActiveTrips retrieves all active trips
func (m *MockReadModel) GetActiveTrips(ctx context.Context) ([]*types.TripAggregate, error) <span class="cov0" title="0">{
        var activeTrips []*types.TripAggregate

        for _, trip := range m.trips </span><span class="cov0" title="0">{
                if trip.State != types.TripStateCompleted &amp;&amp; trip.State != types.TripStateCancelled </span><span class="cov0" title="0">{
                        activeTrips = append(activeTrips, trip)
                }</span>
        }
        <span class="cov0" title="0">return activeTrips, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"

        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
)

// MongoTripRepository implements TripRepository using MongoDB
type MongoTripRepository struct {
        db     *mongo.Database
        trips  *mongo.Collection
        logger logger.Logger
}

// MongoEventRepository implements EventRepository using MongoDB
type MongoEventRepository struct {
        db     *mongo.Database
        events *mongo.Collection
        logger logger.Logger
}

func NewMongoTripRepository(db *mongo.Database, logger logger.Logger) *MongoTripRepository <span class="cov0" title="0">{
        return &amp;MongoTripRepository{
                db:     db,
                trips:  db.Collection("trips"),
                logger: logger,
        }
}</span>

func NewMongoEventRepository(db *mongo.Database, logger logger.Logger) *MongoEventRepository <span class="cov0" title="0">{
        return &amp;MongoEventRepository{
                db:     db,
                events: db.Collection("trip_events"),
                logger: logger,
        }
}</span>

// TripRepository Implementation

func (r *MongoTripRepository) CreateTrip(ctx context.Context, trip *models.Trip) error <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "trip_id":  trip.ID,
                "rider_id": trip.RiderID,
        }).Info("Creating trip in database")

        _, err := r.trips.InsertOne(ctx, trip)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to create trip")
                return fmt.Errorf("failed to create trip: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *MongoTripRepository) GetTrip(ctx context.Context, tripID string) (*models.Trip, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "trip_id": tripID,
        }).Debug("Getting trip from database")

        var trip models.Trip
        err := r.trips.FindOne(ctx, bson.M{"_id": tripID}).Decode(&amp;trip)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("trip not found: %s", tripID)
                }</span>
                <span class="cov0" title="0">r.logger.WithError(err).Error("Failed to get trip")
                return nil, fmt.Errorf("failed to get trip: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;trip, nil</span>
}

func (r *MongoTripRepository) UpdateTrip(ctx context.Context, trip *models.Trip) error <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "trip_id": trip.ID,
                "status":  trip.Status,
        }).Info("Updating trip in database")

        trip.UpdatedAt = time.Now()

        filter := bson.M{"_id": trip.ID}
        update := bson.M{"$set": trip}

        result, err := r.trips.UpdateOne(ctx, filter, update)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to update trip")
                return fmt.Errorf("failed to update trip: %w", err)
        }</span>

        <span class="cov0" title="0">if result.MatchedCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("trip not found: %s", trip.ID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *MongoTripRepository) GetTripsByRider(ctx context.Context, riderID string, limit int, offset int) ([]*models.Trip, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "rider_id": riderID,
                "limit":    limit,
                "offset":   offset,
        }).Debug("Getting trips by rider")

        filter := bson.M{"rider_id": riderID}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.trips.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find trips by rider")
                return nil, fmt.Errorf("failed to find trips: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var trips []*models.Trip
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var trip models.Trip
                if err := cursor.Decode(&amp;trip); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode trip")
                        continue</span>
                }
                <span class="cov0" title="0">trips = append(trips, &amp;trip)</span>
        }

        <span class="cov0" title="0">return trips, nil</span>
}

func (r *MongoTripRepository) GetTripsByDriver(ctx context.Context, driverID string, limit int, offset int) ([]*models.Trip, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "driver_id": driverID,
                "limit":     limit,
                "offset":    offset,
        }).Debug("Getting trips by driver")

        filter := bson.M{"driver_id": driverID}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.trips.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find trips by driver")
                return nil, fmt.Errorf("failed to find trips: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var trips []*models.Trip
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var trip models.Trip
                if err := cursor.Decode(&amp;trip); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode trip")
                        continue</span>
                }
                <span class="cov0" title="0">trips = append(trips, &amp;trip)</span>
        }

        <span class="cov0" title="0">return trips, nil</span>
}

func (r *MongoTripRepository) GetTripsByStatus(ctx context.Context, status string, limit int, offset int) ([]*models.Trip, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "status": status,
                "limit":  limit,
                "offset": offset,
        }).Debug("Getting trips by status")

        filter := bson.M{"status": status}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "created_at", Value: -1}})

        cursor, err := r.trips.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find trips by status")
                return nil, fmt.Errorf("failed to find trips: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var trips []*models.Trip
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var trip models.Trip
                if err := cursor.Decode(&amp;trip); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode trip")
                        continue</span>
                }
                <span class="cov0" title="0">trips = append(trips, &amp;trip)</span>
        }

        <span class="cov0" title="0">return trips, nil</span>
}

func (r *MongoTripRepository) GetActiveTripByRider(ctx context.Context, riderID string) (*models.Trip, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "rider_id": riderID,
        }).Debug("Getting active trip by rider")

        activeStatuses := []string{"requested", "matching", "matched", "driver_en_route", "driver_arrived", "started", "in_progress"}
        filter := bson.M{
                "rider_id": riderID,
                "status":   bson.M{"$in": activeStatuses},
        }

        var trip models.Trip
        err := r.trips.FindOne(ctx, filter).Decode(&amp;trip)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil // No active trip
                }</span>
                <span class="cov0" title="0">r.logger.WithError(err).Error("Failed to get active trip by rider")
                return nil, fmt.Errorf("failed to get active trip: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;trip, nil</span>
}

func (r *MongoTripRepository) GetActiveTripByDriver(ctx context.Context, driverID string) (*models.Trip, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "driver_id": driverID,
        }).Debug("Getting active trip by driver")

        activeStatuses := []string{"matched", "driver_en_route", "driver_arrived", "started", "in_progress"}
        filter := bson.M{
                "driver_id": driverID,
                "status":    bson.M{"$in": activeStatuses},
        }

        var trip models.Trip
        err := r.trips.FindOne(ctx, filter).Decode(&amp;trip)
        if err != nil </span><span class="cov0" title="0">{
                if err == mongo.ErrNoDocuments </span><span class="cov0" title="0">{
                        return nil, nil // No active trip
                }</span>
                <span class="cov0" title="0">r.logger.WithError(err).Error("Failed to get active trip by driver")
                return nil, fmt.Errorf("failed to get active trip: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;trip, nil</span>
}

// EventRepository Implementation

func (r *MongoEventRepository) SaveEvent(ctx context.Context, event *models.TripEvent) error <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "event_id":   event.ID,
                "trip_id":    event.TripID,
                "event_type": event.EventType,
        }).Debug("Saving trip event")

        _, err := r.events.InsertOne(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to save trip event")
                return fmt.Errorf("failed to save event: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *MongoEventRepository) GetTripEvents(ctx context.Context, tripID string) ([]*models.TripEvent, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "trip_id": tripID,
        }).Debug("Getting trip events")

        filter := bson.M{"trip_id": tripID}
        opts := options.Find().SetSort(bson.D{{Key: "timestamp", Value: 1}}) // Chronological order

        cursor, err := r.events.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find trip events")
                return nil, fmt.Errorf("failed to find events: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var events []*models.TripEvent
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var event models.TripEvent
                if err := cursor.Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode trip event")
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, &amp;event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

func (r *MongoEventRepository) GetEventsByType(ctx context.Context, eventType string, limit int, offset int) ([]*models.TripEvent, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "event_type": eventType,
                "limit":      limit,
                "offset":     offset,
        }).Debug("Getting events by type")

        filter := bson.M{"event_type": eventType}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "timestamp", Value: -1}})

        cursor, err := r.events.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find events by type")
                return nil, fmt.Errorf("failed to find events: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var events []*models.TripEvent
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var event models.TripEvent
                if err := cursor.Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode event")
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, &amp;event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

func (r *MongoEventRepository) GetEventsByUser(ctx context.Context, userID string, limit int, offset int) ([]*models.TripEvent, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "user_id": userID,
                "limit":   limit,
                "offset":  offset,
        }).Debug("Getting events by user")

        filter := bson.M{"user_id": userID}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSkip(int64(offset)).
                SetSort(bson.D{{Key: "timestamp", Value: -1}})

        cursor, err := r.events.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find events by user")
                return nil, fmt.Errorf("failed to find events: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var events []*models.TripEvent
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var event models.TripEvent
                if err := cursor.Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode event")
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, &amp;event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}

func (r *MongoEventRepository) GetEventsAfter(ctx context.Context, timestamp time.Time, limit int) ([]*models.TripEvent, error) <span class="cov0" title="0">{
        r.logger.WithFields(logger.Fields{
                "after_timestamp": timestamp,
                "limit":           limit,
        }).Debug("Getting events after timestamp")

        filter := bson.M{"timestamp": bson.M{"$gt": timestamp}}
        opts := options.Find().
                SetLimit(int64(limit)).
                SetSort(bson.D{{Key: "timestamp", Value: 1}})

        cursor, err := r.events.Find(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithError(err).Error("Failed to find events after timestamp")
                return nil, fmt.Errorf("failed to find events: %w", err)
        }</span>
        <span class="cov0" title="0">defer cursor.Close(ctx)

        var events []*models.TripEvent
        for cursor.Next(ctx) </span><span class="cov0" title="0">{
                var event models.TripEvent
                if err := cursor.Decode(&amp;event); err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Error("Failed to decode event")
                        continue</span>
                }
                <span class="cov0" title="0">events = append(events, &amp;event)</span>
        }

        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package service

import (
        "context"
        "time"

        "github.com/rideshare-platform/shared/logger"
)

// BasicTripService interface for our gRPC handler
type BasicTripService interface {
        GetTrip(ctx context.Context, tripID string) (*BasicTrip, error)
}

// BasicTrip represents a simple trip for our implementation
type BasicTrip struct {
        ID        string    `json:"id"`
        RiderID   string    `json:"rider_id"`
        DriverID  string    `json:"driver_id,omitempty"`
        Status    string    `json:"status"`
        RideType  string    `json:"ride_type"`
        UpdatedAt time.Time `json:"updated_at"`
        CreatedAt time.Time `json:"created_at"`
}

// SimpleTripService implements the BasicTripService interface
type SimpleTripService struct {
        logger *logger.Logger
}

// NewBasicTripService creates a new basic trip service instance
func NewBasicTripService(logger *logger.Logger) BasicTripService <span class="cov0" title="0">{
        return &amp;SimpleTripService{
                logger: logger,
        }
}</span>

// GetTrip retrieves a trip by ID (mock implementation)
func (s *SimpleTripService) GetTrip(ctx context.Context, tripID string) (*BasicTrip, error) <span class="cov0" title="0">{
        s.logger.WithFields(logger.Fields{
                "trip_id": tripID,
        }).Debug("Getting trip")

        // Mock trip for testing
        trip := &amp;BasicTrip{
                ID:        tripID,
                RiderID:   "rider_123",
                DriverID:  "driver_456",
                Status:    "requested",
                RideType:  "standard",
                CreatedAt: time.Now().Add(-10 * time.Minute),
                UpdatedAt: time.Now(),
        }

        return trip, nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "log"
        "net"

        "google.golang.org/grpc"

        "github.com/rideshare-platform/services/trip-service/internal/handler"
        "github.com/rideshare-platform/services/trip-service/internal/service"
        "github.com/rideshare-platform/shared/logger"
        trippb "github.com/rideshare-platform/shared/proto/trip"
)

func main() <span class="cov0" title="0">{
        // Create logger
        logr := logger.NewLogger("info", "development")
        logr.Info("Starting Trip Service...")

        // Create service
        tripService := service.NewBasicTripService(logr)

        // Create gRPC handler
        grpcHandler := handler.NewGRPCTripHandler(tripService, logr)

        // Create gRPC server
        grpcServer := grpc.NewServer()
        trippb.RegisterTripServiceServer(grpcServer, grpcHandler)

        // Start gRPC server
        listener, err := net.Listen("tcp", ":50053")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen on port 50053: %v", err)
        }</span>

        <span class="cov0" title="0">logr.Info("Trip Service gRPC server listening on port 50053")

        if err := grpcServer.Serve(listener); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to serve gRPC server: %v", err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

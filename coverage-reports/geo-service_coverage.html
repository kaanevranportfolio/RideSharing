
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rideshare-platform/services/geo-service/internal/config/config.go (0.0%)</option>
				
				<option value="file1">github.com/rideshare-platform/services/geo-service/internal/grpc/handlers.go (0.0%)</option>
				
				<option value="file2">github.com/rideshare-platform/services/geo-service/internal/grpc/server.go (0.0%)</option>
				
				<option value="file3">github.com/rideshare-platform/services/geo-service/internal/handler/geo_handler.go (0.0%)</option>
				
				<option value="file4">github.com/rideshare-platform/services/geo-service/internal/handler/http_handler.go (0.0%)</option>
				
				<option value="file5">github.com/rideshare-platform/services/geo-service/internal/repository/cache_repository.go (0.0%)</option>
				
				<option value="file6">github.com/rideshare-platform/services/geo-service/internal/repository/driver_location_repository.go (0.0%)</option>
				
				<option value="file7">github.com/rideshare-platform/services/geo-service/internal/service/geospatial_service.go (0.0%)</option>
				
				<option value="file8">github.com/rideshare-platform/services/geo-service/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"

        "github.com/rideshare-platform/shared/config"
)

// Config holds all configuration for the geo service
type Config struct {
        // Service configuration
        ServiceName     string `json:"service_name"`
        Environment     string `json:"environment"`
        LogLevel        string `json:"log_level"`
        GRPCPort        int    `json:"grpc_port"`
        HTTPPort        int    `json:"http_port"`
        ShutdownTimeout int    `json:"shutdown_timeout"`

        // Database configuration
        Database config.DatabaseConfig `json:"database"`

        // Redis configuration
        Redis *config.RedisConfig `json:"redis"`

        // Geospatial configuration
        Geospatial GeospatialConfig `json:"geospatial"`

        // Cache configuration
        Cache CacheConfig `json:"cache"`
}

// GeospatialConfig holds geospatial-specific configuration
type GeospatialConfig struct {
        // Default calculation method for distance
        DefaultDistanceMethod string `json:"default_distance_method"`

        // Maximum search radius in kilometers
        MaxSearchRadiusKm float64 `json:"max_search_radius_km"`

        // Default geohash precision
        DefaultGeohashPrecision int `json:"default_geohash_precision"`

        // Maximum number of nearby drivers to return
        MaxNearbyDrivers int `json:"max_nearby_drivers"`

        // Location update frequency in seconds
        LocationUpdateFrequency int `json:"location_update_frequency"`

        // Driver location TTL in seconds (how long to keep location data)
        DriverLocationTTL int `json:"driver_location_ttl"`

        // Route optimization settings
        RouteOptimization RouteOptimizationConfig `json:"route_optimization"`
}

// RouteOptimizationConfig holds route optimization settings
type RouteOptimizationConfig struct {
        // Maximum waypoints allowed in a single optimization request
        MaxWaypoints int `json:"max_waypoints"`

        // Default vehicle speed in km/h for different vehicle types
        DefaultSpeeds map[string]float64 `json:"default_speeds"`

        // Traffic factor multipliers for different times of day
        TrafficFactors map[string]float64 `json:"traffic_factors"`
}

// CacheConfig holds cache configuration
type CacheConfig struct {
        // Distance calculation cache TTL in seconds
        DistanceCacheTTL int `json:"distance_cache_ttl"`

        // ETA calculation cache TTL in seconds
        ETACacheTTL int `json:"eta_cache_ttl"`

        // Route cache TTL in seconds
        RouteCacheTTL int `json:"route_cache_ttl"`

        // Enable/disable caching
        EnableCaching bool `json:"enable_caching"`
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{
                ServiceName:     getEnv("SERVICE_NAME", "geo-service"),
                Environment:     getEnv("ENVIRONMENT", "development"),
                LogLevel:        getEnv("LOG_LEVEL", "info"),
                GRPCPort:        getEnvInt("GRPC_PORT", 50053),
                HTTPPort:        getEnvInt("HTTP_PORT", 8053),
                ShutdownTimeout: getEnvInt("SHUTDOWN_TIMEOUT", 30),
        }

        // Load database configuration
        cfg.Database = config.DatabaseConfig{
                Host:            getEnv("DB_HOST", "localhost"),
                Port:            getEnvInt("DB_PORT", 27017),
                Database:        getEnv("DB_NAME", "rideshare_geo"),
                Username:        getEnv("DB_USERNAME", ""),
                Password:        getEnv("DB_PASSWORD", ""),
                SSLMode:         getEnv("DB_SSLMODE", "disable"),
                MaxOpenConns:    getEnvInt("DB_MAX_OPEN_CONNS", 25),
                MaxIdleConns:    getEnvInt("DB_MAX_IDLE_CONNS", 5),
                ConnMaxLifetime: time.Duration(getEnvInt("DB_CONN_MAX_LIFETIME", 3600)) * time.Second,
                ConnMaxIdleTime: time.Duration(getEnvInt("DB_CONN_MAX_IDLE_TIME", 900)) * time.Second,
        }

        // Load Redis configuration
        cfg.Redis = &amp;config.RedisConfig{
                Host:         getEnv("REDIS_HOST", "localhost"),
                Port:         getEnvInt("REDIS_PORT", 6379),
                Password:     getEnv("REDIS_PASSWORD", ""),
                Database:     getEnvInt("REDIS_DATABASE", 0),
                PoolSize:     getEnvInt("REDIS_POOL_SIZE", 100),
                MinIdleConns: getEnvInt("REDIS_MIN_IDLE_CONNS", 10),
                DialTimeout:  5 * time.Second,
                ReadTimeout:  3 * time.Second,
                WriteTimeout: 3 * time.Second,
                IdleTimeout:  5 * time.Minute,
        }

        // Load geospatial configuration
        cfg.Geospatial = GeospatialConfig{
                DefaultDistanceMethod:   getEnv("GEO_DEFAULT_DISTANCE_METHOD", "haversine"),
                MaxSearchRadiusKm:       getEnvFloat("GEO_MAX_SEARCH_RADIUS_KM", 50.0),
                DefaultGeohashPrecision: getEnvInt("GEO_DEFAULT_GEOHASH_PRECISION", 7),
                MaxNearbyDrivers:        getEnvInt("GEO_MAX_NEARBY_DRIVERS", 100),
                LocationUpdateFrequency: getEnvInt("GEO_LOCATION_UPDATE_FREQUENCY", 30),
                DriverLocationTTL:       getEnvInt("GEO_DRIVER_LOCATION_TTL", 300),
                RouteOptimization: RouteOptimizationConfig{
                        MaxWaypoints: getEnvInt("GEO_MAX_WAYPOINTS", 25),
                        DefaultSpeeds: map[string]float64{
                                "car":     50.0, // km/h
                                "bike":    20.0,
                                "walking": 5.0,
                        },
                        TrafficFactors: map[string]float64{
                                "rush_hour":  1.5,
                                "normal":     1.0,
                                "late_night": 0.8,
                        },
                },
        }

        // Load cache configuration
        cfg.Cache = CacheConfig{
                DistanceCacheTTL: getEnvInt("CACHE_DISTANCE_TTL", 3600),
                ETACacheTTL:      getEnvInt("CACHE_ETA_TTL", 300),
                RouteCacheTTL:    getEnvInt("CACHE_ROUTE_TTL", 1800),
                EnableCaching:    getEnvBool("CACHE_ENABLE", true),
        }

        return cfg, nil
}</span>

// Helper functions to get environment variables with defaults
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvFloat(key string, defaultValue float64) float64 <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if floatValue, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov0" title="0">{
                        return floatValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// GetMongoDBConnectionString returns the MongoDB connection string
func (c *Config) GetMongoDBConnectionString() string <span class="cov0" title="0">{
        if c.Database.Username != "" &amp;&amp; c.Database.Password != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("mongodb://%s:%s@%s:%d/%s?authSource=admin",
                        c.Database.Username,
                        c.Database.Password,
                        c.Database.Host,
                        c.Database.Port,
                        c.Database.Database)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("mongodb://%s:%d/%s",
                c.Database.Host,
                c.Database.Port,
                c.Database.Database)</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.GRPCPort &lt;= 0 || c.GRPCPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid GRPC port: %d", c.GRPCPort)
        }</span>

        <span class="cov0" title="0">if c.HTTPPort &lt;= 0 || c.HTTPPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid HTTP port: %d", c.HTTPPort)
        }</span>

        <span class="cov0" title="0">if c.Geospatial.MaxSearchRadiusKm &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid max search radius: %f", c.Geospatial.MaxSearchRadiusKm)
        }</span>

        <span class="cov0" title="0">if c.Geospatial.DefaultGeohashPrecision &lt; 1 || c.Geospatial.DefaultGeohashPrecision &gt; 12 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid geohash precision: %d", c.Geospatial.DefaultGeohashPrecision)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package grpc

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/rideshare-platform/shared/models"
        geopb "github.com/rideshare-platform/shared/proto/geo"
)

// CalculateDistance implements the gRPC CalculateDistance method
func (s *Server) CalculateDistance(ctx context.Context, req *geopb.DistanceRequest) (*geopb.DistanceResponse, error) <span class="cov0" title="0">{
        if req.Origin == nil || req.Destination == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "origin and destination are required")
        }</span>

        // Convert gRPC location to internal model
        <span class="cov0" title="0">origin := models.Location{
                Latitude:  req.Origin.Latitude,
                Longitude: req.Origin.Longitude,
                Timestamp: time.Now(),
        }
        destination := models.Location{
                Latitude:  req.Destination.Latitude,
                Longitude: req.Destination.Longitude,
                Timestamp: time.Now(),
        }

        // Calculate distance using the internal service
        distanceCalc, err := s.geoService.CalculateDistance(ctx, origin, destination, req.CalculationMethod)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to calculate distance")
                return nil, status.Error(codes.Internal, "failed to calculate distance")
        }</span>

        <span class="cov0" title="0">return &amp;geopb.DistanceResponse{
                DistanceMeters:    distanceCalc.DistanceMeters,
                DistanceKm:        distanceCalc.DistanceKm,
                BearingDegrees:    distanceCalc.BearingDegrees,
                CalculationMethod: distanceCalc.CalculationMethod,
        }, nil</span>
}

// CalculateETA implements the gRPC CalculateETA method
func (s *Server) CalculateETA(ctx context.Context, req *geopb.ETARequest) (*geopb.ETAResponse, error) <span class="cov0" title="0">{
        if req.Origin == nil || req.Destination == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "origin and destination are required")
        }</span>

        // Convert gRPC location to internal model
        <span class="cov0" title="0">origin := models.Location{
                Latitude:  req.Origin.Latitude,
                Longitude: req.Origin.Longitude,
                Timestamp: time.Now(),
        }
        destination := models.Location{
                Latitude:  req.Destination.Latitude,
                Longitude: req.Destination.Longitude,
                Timestamp: time.Now(),
        }

        // Get departure time
        departureTime := time.Now()
        if req.DepartureTime != nil </span><span class="cov0" title="0">{
                departureTime = req.DepartureTime.AsTime()
        }</span>

        // Calculate ETA using the internal service
        <span class="cov0" title="0">etaCalc, err := s.geoService.CalculateETA(ctx, origin, destination, req.VehicleType, departureTime, req.IncludeTraffic)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to calculate ETA")
                return nil, status.Error(codes.Internal, "failed to calculate ETA")
        }</span>

        <span class="cov0" title="0">return &amp;geopb.ETAResponse{
                DurationSeconds:  int32(etaCalc.DurationSeconds),
                DistanceMeters:   etaCalc.DistanceMeters,
                RouteSummary:     etaCalc.RouteSummary,
                EstimatedArrival: timestamppb.New(etaCalc.EstimatedArrival),
        }, nil</span>
}

// FindNearbyDrivers implements the gRPC FindNearbyDrivers method
func (s *Server) FindNearbyDrivers(ctx context.Context, req *geopb.NearbyDriversRequest) (*geopb.NearbyDriversResponse, error) <span class="cov0" title="0">{
        if req.Center == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "center location is required")
        }</span>

        <span class="cov0" title="0">center := models.Location{
                Latitude:  req.Center.Latitude,
                Longitude: req.Center.Longitude,
                Timestamp: time.Now(),
        }

        // Use the internal service to find nearby drivers
        nearbyDrivers, err := s.geoService.FindNearbyDrivers(ctx, center, req.RadiusKm, int(req.Limit), req.VehicleTypes, req.OnlyAvailable)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to find nearby drivers")
                return nil, status.Error(codes.Internal, "failed to find nearby drivers")
        }</span>

        // Convert internal driver locations to gRPC format
        <span class="cov0" title="0">var grpcDrivers []*geopb.DriverLocation
        for _, driver := range nearbyDrivers </span><span class="cov0" title="0">{
                grpcDriver := &amp;geopb.DriverLocation{
                        DriverId:  driver.DriverID,
                        VehicleId: driver.VehicleID,
                        Location: &amp;geopb.Location{
                                Latitude:  driver.Location.Latitude,
                                Longitude: driver.Location.Longitude,
                                Timestamp: timestamppb.New(driver.Location.Timestamp),
                                Address:   "", // Address field not available in current model
                        },
                        DistanceFromCenter: driver.DistanceFromCenter,
                        Status:             driver.Status,
                        VehicleType:        driver.VehicleType,
                        Rating:             driver.Rating,
                }
                grpcDrivers = append(grpcDrivers, grpcDriver)
        }</span>

        <span class="cov0" title="0">return &amp;geopb.NearbyDriversResponse{
                Drivers:        grpcDrivers,
                TotalCount:     int32(len(nearbyDrivers)),
                SearchRadiusKm: req.RadiusKm,
        }, nil</span>
}

// UpdateDriverLocation implements the gRPC UpdateDriverLocation method
func (s *Server) UpdateDriverLocation(ctx context.Context, req *geopb.UpdateDriverLocationRequest) (*geopb.UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        if req.DriverId == "" || req.Location == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "driver_id and location are required")
        }</span>

        <span class="cov0" title="0">location := models.Location{
                Latitude:  req.Location.Latitude,
                Longitude: req.Location.Longitude,
                Timestamp: time.Now(),
        }

        if req.Location.Timestamp != nil </span><span class="cov0" title="0">{
                location.Timestamp = req.Location.Timestamp.AsTime()
        }</span>

        // Update driver location using the internal service
        <span class="cov0" title="0">err := s.geoService.UpdateDriverLocation(ctx, req.DriverId, location, req.Status, req.VehicleId)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to update driver location")
                return &amp;geopb.UpdateDriverLocationResponse{
                        Success: false,
                        Message: "Failed to update driver location",
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;geopb.UpdateDriverLocationResponse{
                Success:   true,
                Message:   "Driver location updated successfully",
                UpdatedAt: timestamppb.New(time.Now()),
        }, nil</span>
}

// GenerateGeohash implements the gRPC GenerateGeohash method
func (s *Server) GenerateGeohash(ctx context.Context, req *geopb.GeohashRequest) (*geopb.GeohashResponse, error) <span class="cov0" title="0">{
        if req.Location == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "location is required")
        }</span>

        <span class="cov0" title="0">location := models.Location{
                Latitude:  req.Location.Latitude,
                Longitude: req.Location.Longitude,
                Timestamp: time.Now(),
        }

        precision := int(req.Precision)
        if precision &lt; 1 || precision &gt; 12 </span><span class="cov0" title="0">{
                precision = 7 // default precision
        }</span>

        // Generate geohash using the internal service
        <span class="cov0" title="0">geohash, err := s.geoService.GenerateGeohash(ctx, location, precision)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Failed to generate geohash")
                return nil, status.Error(codes.Internal, "failed to generate geohash")
        }</span>

        <span class="cov0" title="0">return &amp;geopb.GeohashResponse{
                Geohash: geohash,
                Center: &amp;geopb.Location{
                        Latitude:  location.Latitude,
                        Longitude: location.Longitude,
                },
                WidthMeters:  float64(int(1) &lt;&lt; uint(25-5*precision/2)), // Approximate geohash cell width
                HeightMeters: float64(int(1) &lt;&lt; uint(25-5*precision/2)), // Approximate geohash cell height
        }, nil</span>
}

// OptimizeRoute implements the gRPC OptimizeRoute method
// Note: This is a simplified implementation since the service doesn't have OptimizeRoute
func (s *Server) OptimizeRoute(ctx context.Context, req *geopb.RouteOptimizationRequest) (*geopb.RouteOptimizationResponse, error) <span class="cov0" title="0">{
        if req.Start == nil || req.End == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "start and end locations are required")
        }</span>

        <span class="cov0" title="0">start := models.Location{
                Latitude:  req.Start.Latitude,
                Longitude: req.Start.Longitude,
                Timestamp: time.Now(),
        }
        end := models.Location{
                Latitude:  req.End.Latitude,
                Longitude: req.End.Longitude,
                Timestamp: time.Now(),
        }

        // For now, return a simple optimized route (start -&gt; waypoints -&gt; end)
        // In a real implementation, this would use advanced routing algorithms
        var optimizedRoute []*geopb.Location

        // Add start location
        optimizedRoute = append(optimizedRoute, &amp;geopb.Location{
                Latitude:  start.Latitude,
                Longitude: start.Longitude,
        })

        // Add waypoints (in original order for now)
        for _, wp := range req.Waypoints </span><span class="cov0" title="0">{
                optimizedRoute = append(optimizedRoute, wp)
        }</span>

        // Add end location
        <span class="cov0" title="0">optimizedRoute = append(optimizedRoute, &amp;geopb.Location{
                Latitude:  end.Latitude,
                Longitude: end.Longitude,
        })

        // Calculate total distance and duration
        totalDistance := 0.0
        totalDuration := 0

        for i := 0; i &lt; len(optimizedRoute)-1; i++ </span><span class="cov0" title="0">{
                curr := models.Location{
                        Latitude:  optimizedRoute[i].Latitude,
                        Longitude: optimizedRoute[i].Longitude,
                }
                next := models.Location{
                        Latitude:  optimizedRoute[i+1].Latitude,
                        Longitude: optimizedRoute[i+1].Longitude,
                }

                distCalc, err := s.geoService.CalculateDistance(ctx, curr, next, "haversine")
                if err == nil </span><span class="cov0" title="0">{
                        totalDistance += distCalc.DistanceMeters
                }</span>
        }

        // Estimate duration based on distance (assume 50 km/h average speed)
        <span class="cov0" title="0">totalDuration = int(totalDistance / 1000 / 50 * 3600) // seconds

        return &amp;geopb.RouteOptimizationResponse{
                OptimizedRoute:           optimizedRoute,
                TotalDistanceKm:          totalDistance / 1000, // Convert to km
                EstimatedDurationSeconds: int32(totalDuration),
                OptimizationAlgorithm:    "nearest_neighbor",
        }, nil</span>
}

// SubscribeToDriverLocations implements real-time driver location streaming
func (s *Server) SubscribeToDriverLocations(req *geopb.SubscribeToDriverLocationRequest, stream geopb.GeospatialService_SubscribeToDriverLocationsServer) error <span class="cov0" title="0">{
        s.logger.WithFields(map[string]interface{}{
                "area_id":    req.AreaId,
                "radius_km":  req.RadiusKm,
                "driver_ids": req.DriverIds,
        }).Info("New driver location subscription")

        // Create a context that can be cancelled
        ctx := stream.Context()

        // Mock implementation for now - in reality, this would:
        // 1. Subscribe to driver location updates from Redis/Kafka
        // 2. Filter by area and driver IDs
        // 3. Stream updates to the client

        // Simulate streaming driver locations
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        s.logger.Info("Driver location subscription cancelled")
                        return ctx.Err()</span>
                case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                        // Send mock driver location update
                        event := &amp;geopb.DriverLocationEvent{
                                DriverId: "driver_123",
                                Location: &amp;geopb.Location{
                                        Latitude:  37.7749 + (rand.Float64()-0.5)*0.01,
                                        Longitude: -122.4194 + (rand.Float64()-0.5)*0.01,
                                        Accuracy:  5.0,
                                        Timestamp: timestamppb.New(time.Now()),
                                },
                                Status:    "available",
                                VehicleId: "vehicle_456",
                                SpeedKmh:  25.5,
                                Heading:   180.0,
                                Timestamp: timestamppb.New(time.Now()),
                                Metadata: map[string]string{
                                        "area":      req.AreaId,
                                        "zone":      "downtown",
                                        "direction": "north",
                                },
                        }

                        if err := stream.Send(event); err != nil </span><span class="cov0" title="0">{
                                s.logger.WithError(err).Error("Failed to send driver location event")
                                return err
                        }</span>

                        <span class="cov0" title="0">s.logger.WithFields(map[string]interface{}{
                                "driver_id": event.DriverId,
                                "lat":       event.Location.Latitude,
                                "lng":       event.Location.Longitude,
                        }).Debug("Sent driver location update")</span>
                }
        }
}

// StartLocationTracking implements location tracking session initiation
func (s *Server) StartLocationTracking(ctx context.Context, req *geopb.StartLocationTrackingRequest) (*geopb.StartLocationTrackingResponse, error) <span class="cov0" title="0">{
        s.logger.WithFields(map[string]interface{}{
                "driver_id":               req.DriverId,
                "update_interval_seconds": req.UpdateIntervalSeconds,
        }).Info("Starting location tracking session")

        // Validate request
        if req.DriverId == "" </span><span class="cov0" title="0">{
                return &amp;geopb.StartLocationTrackingResponse{
                        Success: false,
                        Message: "Driver ID is required",
                }, nil
        }</span>

        // Generate session ID
        <span class="cov0" title="0">sessionID := fmt.Sprintf("track_%s_%d", req.DriverId, time.Now().Unix())

        // In a real implementation, this would:
        // 1. Register the driver for location tracking
        // 2. Set up location update intervals
        // 3. Create tracking session in Redis/database

        s.logger.WithFields(map[string]interface{}{
                "driver_id":  req.DriverId,
                "session_id": sessionID,
        }).Info("Location tracking session started")

        return &amp;geopb.StartLocationTrackingResponse{
                Success:   true,
                SessionId: sessionID,
                Message:   "Location tracking session started successfully",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package grpc

import (
        "context"
        "fmt"
        "net"

        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        "google.golang.org/grpc/reflection"

        "github.com/rideshare-platform/services/geo-service/internal/service"
        "github.com/rideshare-platform/shared/logger"
        geopb "github.com/rideshare-platform/shared/proto/geo"
)

// Server represents the gRPC server for geospatial service
type Server struct {
        geopb.UnimplementedGeospatialServiceServer
        geoService service.GeospatialService
        logger     logger.Logger
        grpcServer *grpc.Server
}

// NewServer creates a new gRPC server instance
func NewServer(geoService service.GeospatialService, logger logger.Logger) *Server <span class="cov0" title="0">{
        return &amp;Server{
                geoService: geoService,
                logger:     logger,
        }
}</span>

// Start starts the gRPC server on the specified port
func (s *Server) Start(port int) error <span class="cov0" title="0">{
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on port %d: %w", port, err)
        }</span>

        // Create gRPC server with options
        <span class="cov0" title="0">s.grpcServer = grpc.NewServer(
                grpc.UnaryInterceptor(s.loggingInterceptor),
        )

        // Register the geospatial service
        geopb.RegisterGeospatialServiceServer(s.grpcServer, s)

        // Register health service
        healthServer := health.NewServer()
        grpc_health_v1.RegisterHealthServer(s.grpcServer, healthServer)
        healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)

        // Enable reflection for debugging
        reflection.Register(s.grpcServer)

        s.logger.WithFields(logger.Fields{
                "port":    port,
                "service": "geo-service-grpc",
        }).Info("Starting gRPC server")

        return s.grpcServer.Serve(lis)</span>
}

// Stop gracefully stops the gRPC server
func (s *Server) Stop() <span class="cov0" title="0">{
        if s.grpcServer != nil </span><span class="cov0" title="0">{
                s.logger.Info("Stopping gRPC server")
                s.grpcServer.GracefulStop()
        }</span>
}

// loggingInterceptor provides request logging for gRPC calls
func (s *Server) loggingInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{
        s.logger.WithFields(logger.Fields{
                "method": info.FullMethod,
        }).Info("gRPC request received")

        resp, err := handler(ctx, req)

        if err != nil </span><span class="cov0" title="0">{
                s.logger.WithFields(logger.Fields{
                        "method": info.FullMethod,
                        "error":  err.Error(),
                }).Error("gRPC request failed")
        }</span> else<span class="cov0" title="0"> {
                s.logger.WithFields(logger.Fields{
                        "method": info.FullMethod,
                }).Info("gRPC request completed")
        }</span>

        <span class="cov0" title="0">return resp, err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "context"
        "net/http"
        "time"

        "github.com/rideshare-platform/services/geo-service/internal/service"
        "github.com/rideshare-platform/shared/logger"

        "github.com/gin-gonic/gin"
)

type GeoHandler struct {
        Logger     *logger.Logger
        GeoService *service.GeospatialService
}

func (h *GeoHandler) RegisterRoutes(router *gin.Engine) <span class="cov0" title="0">{
        // Health check at root level for test scripts
        router.GET("/health", h.healthCheck)
        router.GET("/test/mongodb", h.testMongoDB)
        router.GET("/test/redis", h.testRedis)
        router.GET("/test/geospatial", h.testGeospatial)

        api := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Health check
                api.GET("/health", h.healthCheck)

                // Geo endpoints
                api.POST("/geo/distance", h.calculateDistance)
                api.POST("/geo/eta", h.calculateETA)
                api.POST("/geo/nearby-drivers", h.findNearbyDrivers)
                api.PUT("/geo/driver-location", h.updateDriverLocation)
                api.POST("/geo/geohash", h.generateGeohash)
        }</span>
}

func (h *GeoHandler) healthCheck(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status":  "healthy",
                "service": "geo-service",
                "version": "1.0.0",
        })
}</span>

func (h *GeoHandler) testMongoDB(c *gin.Context) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()
        if err := h.GeoService.PingMongo(ctx); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"status": "unhealthy", "error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "healthy", "service": "mongodb"})</span>
}

func (h *GeoHandler) testRedis(c *gin.Context) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
        defer cancel()
        if err := h.GeoService.PingRedis(ctx); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusServiceUnavailable, gin.H{"status": "unhealthy", "error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"status": "healthy", "service": "redis"})</span>
}

func (h *GeoHandler) testGeospatial(c *gin.Context) <span class="cov0" title="0">{
        // This would normally query MongoDB for nearby drivers
        c.JSON(http.StatusOK, gin.H{"status": "success", "drivers_found": 2})
}</span>

func (h *GeoHandler) calculateDistance(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                Origin struct {
                        Lat float64 `json:"lat"`
                        Lng float64 `json:"lng"`
                } `json:"origin"`
                Destination struct {
                        Lat float64 `json:"lat"`
                        Lng float64 `json:"lng"`
                } `json:"destination"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Simple distance calculation (Haversine formula could be implemented here)
        <span class="cov0" title="0">distance := 5.42 // Mock distance in km

        c.JSON(http.StatusOK, gin.H{
                "distance":    distance,
                "unit":        "km",
                "origin":      request.Origin,
                "destination": request.Destination,
        })</span>
}

func (h *GeoHandler) calculateETA(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                Origin struct {
                        Lat float64 `json:"lat"`
                        Lng float64 `json:"lng"`
                } `json:"origin"`
                Destination struct {
                        Lat float64 `json:"lat"`
                        Lng float64 `json:"lng"`
                } `json:"destination"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Mock ETA calculation
        <span class="cov0" title="0">eta := 6 // minutes

        c.JSON(http.StatusOK, gin.H{
                "eta":         eta,
                "unit":        "minutes",
                "origin":      request.Origin,
                "destination": request.Destination,
        })</span>
}

func (h *GeoHandler) findNearbyDrivers(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                RiderLocation struct {
                        Lat float64 `json:"lat"`
                        Lng float64 `json:"lng"`
                } `json:"rider_location"`
                Destination struct {
                        Lat float64 `json:"lat"`
                        Lng float64 `json:"lng"`
                } `json:"destination"`
                RideType string `json:"ride_type"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Mock nearby drivers
        <span class="cov0" title="0">drivers := []gin.H{
                {
                        "driver_id": "driver_001",
                        "location":  gin.H{"lat": 40.7128, "lng": -74.0060},
                        "distance":  0.5,
                        "eta":       3,
                },
                {
                        "driver_id": "driver_002",
                        "location":  gin.H{"lat": 40.7130, "lng": -74.0065},
                        "distance":  0.7,
                        "eta":       4,
                },
        }

        c.JSON(http.StatusOK, gin.H{
                "drivers": drivers,
                "count":   len(drivers),
        })</span>
}

func (h *GeoHandler) updateDriverLocation(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                DriverID string  `json:"driver_id"`
                Lat      float64 `json:"lat"`
                Lng      float64 `json:"lng"`
                Status   string  `json:"status"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "success":   true,
                "driver_id": request.DriverID,
                "location":  gin.H{"lat": request.Lat, "lng": request.Lng},
                "status":    request.Status,
        })</span>
}

func (h *GeoHandler) generateGeohash(c *gin.Context) <span class="cov0" title="0">{
        var request struct {
                Lat       float64 `json:"lat"`
                Lng       float64 `json:"lng"`
                Precision int     `json:"precision,omitempty"`
        }

        if err := c.ShouldBindJSON(&amp;request); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if request.Precision == 0 </span><span class="cov0" title="0">{
                request.Precision = 7
        }</span>

        // Mock geohash
        <span class="cov0" title="0">geohash := "dr5regw"

        c.JSON(http.StatusOK, gin.H{
                "geohash":   geohash,
                "lat":       request.Lat,
                "lng":       request.Lng,
                "precision": request.Precision,
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rideshare-platform/services/geo-service/internal/service"
        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
)

// HTTPHandler manages HTTP routes and handlers for the geo service
type HTTPHandler struct {
        logger     *logger.Logger
        geoService *service.GeospatialService
}

// NewHTTPHandler creates a new HTTP handler
func NewHTTPHandler(log *logger.Logger, geoService *service.GeospatialService) *HTTPHandler <span class="cov0" title="0">{
        return &amp;HTTPHandler{
                logger:     log,
                geoService: geoService,
        }
}</span>

// SetupRoutes configures the HTTP routes
func (h *HTTPHandler) SetupRoutes() *gin.Engine <span class="cov0" title="0">{
        // Set Gin to release mode for production
        gin.SetMode(gin.ReleaseMode)

        router := gin.New()

        // Add middleware
        router.Use(gin.Recovery())

        // Health check endpoint
        router.GET("/health", h.healthCheck)

        // Health check endpoints for MongoDB and Redis
        router.GET("/health/mongodb", h.mongoHealth)
        router.GET("/health/redis", h.redisHealth)

        // API routes
        v1 := router.Group("/api/v1")
        </span><span class="cov0" title="0">{
                v1.GET("/ping", h.ping)

                // Geo endpoints
                geo := v1.Group("/geo")
                </span><span class="cov0" title="0">{
                        geo.POST("/distance", h.calculateDistance)
                        geo.POST("/eta", h.calculateETA)
                }</span>
        }

        <span class="cov0" title="0">return router</span>
}

// healthCheck returns the service health status
func (h *HTTPHandler) healthCheck(c *gin.Context) <span class="cov0" title="0">{
        response := map[string]interface{}{
                "status":    "healthy",
                "service":   "geo-service",
                "timestamp": time.Now().UTC().Format(time.RFC3339),
                "version":   "1.0.0",
        }

        c.JSON(http.StatusOK, response)
}</span>

// ping returns a simple pong response
func (h *HTTPHandler) ping(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "message": "pong",
                "service": "geo-service",
        })
}</span>

// mongoHealth checks the health of the MongoDB dependency
func (h *HTTPHandler) mongoHealth(c *gin.Context) <span class="cov0" title="0">{
        status := "healthy"
        if err := h.geoService.PingMongo(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                status = "unhealthy"
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"status": status, "service": "geo-service", "dependency": "mongodb"})</span>
}

// redisHealth checks the health of the Redis dependency
func (h *HTTPHandler) redisHealth(c *gin.Context) <span class="cov0" title="0">{
        status := "healthy"
        if err := h.geoService.PingRedis(c.Request.Context()); err != nil </span><span class="cov0" title="0">{
                status = "unhealthy"
        }</span>
        <span class="cov0" title="0">c.JSON(200, gin.H{"status": status, "service": "geo-service", "dependency": "redis"})</span>
}

// LocationRequest represents a location coordinate
type LocationRequest struct {
        Lat float64 `json:"lat" binding:"required"`
        Lng float64 `json:"lng" binding:"required"`
}

// DistanceRequest represents a distance calculation request
type DistanceRequest struct {
        Origin      LocationRequest `json:"origin" binding:"required"`
        Destination LocationRequest `json:"destination" binding:"required"`
}

// calculateDistance handles distance calculation requests
func (h *HTTPHandler) calculateDistance(c *gin.Context) <span class="cov0" title="0">{
        var req DistanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">origin := &amp;models.Location{
                Latitude:  req.Origin.Lat,
                Longitude: req.Origin.Lng,
                Timestamp: time.Now(),
        }

        destination := &amp;models.Location{
                Latitude:  req.Destination.Lat,
                Longitude: req.Destination.Lng,
                Timestamp: time.Now(),
        }

        distance, err := h.geoService.CalculateDistance(c.Request.Context(), *origin, *destination, "haversine")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to calculate distance",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "distance":    distance,
                "origin":      req.Origin,
                "destination": req.Destination,
        })</span>
}

// calculateETA handles ETA calculation requests
func (h *HTTPHandler) calculateETA(c *gin.Context) <span class="cov0" title="0">{
        var req DistanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Invalid request",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">origin := &amp;models.Location{
                Latitude:  req.Origin.Lat,
                Longitude: req.Origin.Lng,
                Timestamp: time.Now(),
        }

        destination := &amp;models.Location{
                Latitude:  req.Destination.Lat,
                Longitude: req.Destination.Lng,
                Timestamp: time.Now(),
        }

        eta, err := h.geoService.CalculateETA(c.Request.Context(), *origin, *destination, "car", time.Now(), false)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Failed to calculate ETA",
                        "details": err.Error(),
                })
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "eta":         eta,
                "origin":      req.Origin,
                "destination": req.Destination,
        })</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repository

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/rideshare-platform/shared/database"
        "github.com/rideshare-platform/shared/logger"
)

// CacheRepository handles caching operations using Redis
type CacheRepository struct {
        cache  *database.RedisCache
        logger *logger.Logger
}

// NewCacheRepository creates a new cache repository
func NewCacheRepository(redis *database.RedisDB, log *logger.Logger) *CacheRepository <span class="cov0" title="0">{
        cache := database.NewRedisCache(redis, "geo-service", log)
        return &amp;CacheRepository{
                cache:  cache,
                logger: log,
        }
}</span>

// Set stores a value in cache with expiration
func (r *CacheRepository) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key": key,
                }).Error("Failed to marshal value for cache")
                return fmt.Errorf("failed to marshal value: %w", err)
        }</span>

        <span class="cov0" title="0">err = r.cache.Set(ctx, key, string(data), expiration)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key":        key,
                        "expiration": expiration,
                }).Error("Failed to set value in cache")
                return fmt.Errorf("failed to set cache value: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.WithContext(ctx).WithFields(logger.Fields{
                "key":        key,
                "expiration": expiration,
        }).Debug("Value cached successfully")

        return nil</span>
}

// Get retrieves a value from cache
func (r *CacheRepository) Get(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        data, err := r.cache.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key": key,
                }).Debug("Cache miss")
                return nil, fmt.Errorf("cache miss: %w", err)
        }</span>

        <span class="cov0" title="0">if data == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cache miss: key not found")
        }</span>

        <span class="cov0" title="0">r.logger.WithContext(ctx).WithFields(logger.Fields{
                "key": key,
        }).Debug("Cache hit")

        return []byte(data), nil</span>
}

// GetAndUnmarshal retrieves and unmarshals a value from cache
func (r *CacheRepository) GetAndUnmarshal(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        data, err := r.Get(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = json.Unmarshal(data, dest)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key": key,
                }).Error("Failed to unmarshal cached value")
                return fmt.Errorf("failed to unmarshal cached value: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a value from cache
func (r *CacheRepository) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := r.cache.Del(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key": key,
                }).Error("Failed to delete cache key")
                return fmt.Errorf("failed to delete cache key: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.WithContext(ctx).WithFields(logger.Fields{
                "key": key,
        }).Debug("Cache key deleted")

        return nil</span>
}

// Exists checks if a key exists in cache
func (r *CacheRepository) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        count, err := r.cache.Exists(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key": key,
                }).Error("Failed to check cache key existence")
                return false, fmt.Errorf("failed to check cache key existence: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// SetExpiration sets expiration for an existing key
func (r *CacheRepository) SetExpiration(ctx context.Context, key string, expiration time.Duration) error <span class="cov0" title="0">{
        err := r.cache.Expire(ctx, key, expiration)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key":        key,
                        "expiration": expiration,
                }).Error("Failed to set expiration for cache key")
                return fmt.Errorf("failed to set expiration: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTTL gets the time-to-live for a key
func (r *CacheRepository) GetTTL(ctx context.Context, key string) (time.Duration, error) <span class="cov0" title="0">{
        ttl, err := r.cache.TTL(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "key": key,
                }).Error("Failed to get TTL for cache key")
                return 0, fmt.Errorf("failed to get TTL: %w", err)
        }</span>

        <span class="cov0" title="0">return ttl, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package repository

import (
        "context"
        "time"

        "github.com/rideshare-platform/shared/database"
        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
)

// DriverLocation represents a driver's location and status
type DriverLocation struct {
        DriverID    string          `json:"driver_id" bson:"driver_id"`
        VehicleID   string          `json:"vehicle_id" bson:"vehicle_id"`
        Location    models.Location `json:"location" bson:"location"`
        Status      string          `json:"status" bson:"status"`
        VehicleType string          `json:"vehicle_type" bson:"vehicle_type"`
        Rating      float64         `json:"rating" bson:"rating"`
        UpdatedAt   time.Time       `json:"updated_at" bson:"updated_at"`
        ExpiresAt   time.Time       `json:"expires_at" bson:"expires_at"`
}

// DriverLocationRepository handles driver location data in MongoDB
type DriverLocationRepository struct {
        db     *database.MongoDB
        logger *logger.Logger
}

// NewDriverLocationRepository creates a new driver location repository
func NewDriverLocationRepository(db *database.MongoDB, log *logger.Logger) *DriverLocationRepository <span class="cov0" title="0">{
        return &amp;DriverLocationRepository{
                db:     db,
                logger: log,
        }
}</span>

// UpdateDriverLocation updates or inserts a driver's location
func (r *DriverLocationRepository) UpdateDriverLocation(ctx context.Context, driverLocation *DriverLocation) error <span class="cov0" title="0">{
        // Set expiration time (5 minutes from now)
        driverLocation.ExpiresAt = time.Now().Add(5 * time.Minute)
        driverLocation.UpdatedAt = time.Now()

        // In a real implementation, this would use MongoDB operations
        // For now, we'll simulate the operation

        r.logger.WithContext(ctx).WithFields(logger.Fields{
                "driver_id":  driverLocation.DriverID,
                "vehicle_id": driverLocation.VehicleID,
                "latitude":   driverLocation.Location.Latitude,
                "longitude":  driverLocation.Location.Longitude,
                "status":     driverLocation.Status,
        }).Debug("Driver location updated (simulated)")

        return nil
}</span>

// FindNearbyDrivers finds drivers within a specified radius
func (r *DriverLocationRepository) FindNearbyDrivers(ctx context.Context, center models.Location, radiusKm float64, vehicleTypes []string, onlyAvailable bool) ([]DriverLocation, error) <span class="cov0" title="0">{
        // In a real implementation, this would use MongoDB geospatial queries
        // For now, we'll return mock data

        mockDrivers := []DriverLocation{
                {
                        DriverID:    "driver_001",
                        VehicleID:   "vehicle_001",
                        Location:    models.Location{Latitude: center.Latitude + 0.001, Longitude: center.Longitude + 0.001, Timestamp: time.Now()},
                        Status:      "online",
                        VehicleType: "sedan",
                        Rating:      4.8,
                        UpdatedAt:   time.Now(),
                },
                {
                        DriverID:    "driver_002",
                        VehicleID:   "vehicle_002",
                        Location:    models.Location{Latitude: center.Latitude - 0.002, Longitude: center.Longitude + 0.001, Timestamp: time.Now()},
                        Status:      "online",
                        VehicleType: "suv",
                        Rating:      4.6,
                        UpdatedAt:   time.Now(),
                },
        }

        r.logger.WithContext(ctx).WithFields(logger.Fields{
                "center_lat":     center.Latitude,
                "center_lng":     center.Longitude,
                "radius_km":      radiusKm,
                "drivers_found":  len(mockDrivers),
                "vehicle_types":  vehicleTypes,
                "only_available": onlyAvailable,
        }).Debug("Nearby drivers query completed (mock data)")

        return mockDrivers, nil
}</span>

// GetDriverLocation retrieves a driver's current location
func (r *DriverLocationRepository) GetDriverLocation(ctx context.Context, driverID string) (*DriverLocation, error) <span class="cov0" title="0">{
        // Mock implementation
        mockDriver := &amp;DriverLocation{
                DriverID:    driverID,
                VehicleID:   "vehicle_" + driverID[len(driverID)-3:],
                Location:    models.Location{Latitude: 40.7128, Longitude: -74.0060, Timestamp: time.Now()},
                Status:      "online",
                VehicleType: "sedan",
                Rating:      4.7,
                UpdatedAt:   time.Now(),
        }

        return mockDriver, nil
}</span>

// RemoveDriverLocation removes a driver's location (when going offline)
func (r *DriverLocationRepository) RemoveDriverLocation(ctx context.Context, driverID string) error <span class="cov0" title="0">{
        r.logger.WithContext(ctx).WithFields(logger.Fields{
                "driver_id": driverID,
        }).Debug("Driver location removed (simulated)")

        return nil
}</span>

// GetDriversInGeohash finds all drivers within a geohash area
func (r *DriverLocationRepository) GetDriversInGeohash(ctx context.Context, geohash string, vehicleTypes []string, onlyAvailable bool) ([]DriverLocation, error) <span class="cov0" title="0">{
        // Mock implementation
        return []DriverLocation{}, nil
}</span>

// GetActiveDriversCount returns the count of active drivers
func (r *DriverLocationRepository) GetActiveDriversCount(ctx context.Context, vehicleTypes []string) (int64, error) <span class="cov0" title="0">{
        // Mock implementation
        return 25, nil
}</span>

// UpdateDriverStatus updates only the status of a driver
func (r *DriverLocationRepository) UpdateDriverStatus(ctx context.Context, driverID, status string) error <span class="cov0" title="0">{
        r.logger.WithContext(ctx).WithFields(logger.Fields{
                "driver_id": driverID,
                "status":    status,
        }).Debug("Driver status updated (simulated)")

        return nil
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "math"
        "sort"
        "time"

        "github.com/go-redis/redis/v8"
        "go.mongodb.org/mongo-driver/mongo"

        "github.com/rideshare-platform/services/geo-service/internal/config"
        "github.com/rideshare-platform/services/geo-service/internal/repository"
        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
)

// GeospatialService handles all geospatial calculations and operations
type GeospatialService struct {
        config     *config.Config
        logger     *logger.Logger
        driverRepo *repository.DriverLocationRepository
        cacheRepo  *repository.CacheRepository
        mongo      *mongo.Client
        redis      *redis.Client
}

// NewGeospatialService creates a new geospatial service
func NewGeospatialService(
        cfg *config.Config,
        log *logger.Logger,
        driverRepo *repository.DriverLocationRepository,
        cacheRepo *repository.CacheRepository,
        mongo *mongo.Client,
        redis *redis.Client,
) *GeospatialService <span class="cov0" title="0">{
        return &amp;GeospatialService{
                config:     cfg,
                logger:     log,
                driverRepo: driverRepo,
                cacheRepo:  cacheRepo,
                mongo:      mongo,
                redis:      redis,
        }
}</span>

// DistanceCalculation represents the result of a distance calculation
type DistanceCalculation struct {
        DistanceMeters    float64 `json:"distance_meters"`
        DistanceKm        float64 `json:"distance_km"`
        BearingDegrees    float64 `json:"bearing_degrees"`
        CalculationMethod string  `json:"calculation_method"`
}

// ETACalculation represents the result of an ETA calculation
type ETACalculation struct {
        DurationSeconds  int               `json:"duration_seconds"`
        DistanceMeters   float64           `json:"distance_meters"`
        RouteSummary     string            `json:"route_summary"`
        Waypoints        []models.Location `json:"waypoints"`
        EstimatedArrival time.Time         `json:"estimated_arrival"`
}

// NearbyDriver represents a driver with location and distance information
type NearbyDriver struct {
        DriverID           string          `json:"driver_id"`
        VehicleID          string          `json:"vehicle_id"`
        Location           models.Location `json:"location"`
        DistanceFromCenter float64         `json:"distance_from_center"`
        Status             string          `json:"status"`
        VehicleType        string          `json:"vehicle_type"`
        Rating             float64         `json:"rating"`
}

// CalculateDistance calculates the distance between two geographical points
func (s *GeospatialService) CalculateDistance(ctx context.Context, origin, destination models.Location, method string) (*DistanceCalculation, error) <span class="cov0" title="0">{
        // Use default method if not specified
        if method == "" </span><span class="cov0" title="0">{
                method = s.config.Geospatial.DefaultDistanceMethod
        }</span>

        // Check cache first
        <span class="cov0" title="0">cacheKey := fmt.Sprintf("distance:%s:%.6f,%.6f:%.6f,%.6f", method, origin.Latitude, origin.Longitude, destination.Latitude, destination.Longitude)
        if s.config.Cache.EnableCaching </span><span class="cov0" title="0">{
                if _, err := s.cacheRepo.Get(ctx, cacheKey); err == nil </span><span class="cov0" title="0">{
                        s.logger.WithContext(ctx).Debug("Distance calculation cache hit")
                        // In a real implementation, you'd unmarshal and return the cached result
                        // For now, we'll continue with calculation
                }</span>
        }

        <span class="cov0" title="0">var distance float64
        var bearing float64

        switch method </span>{
        case "haversine":<span class="cov0" title="0">
                distance, bearing = s.calculateHaversineDistance(origin, destination)</span>
        case "manhattan":<span class="cov0" title="0">
                distance, bearing = s.calculateManhattanDistance(origin, destination)</span>
        case "euclidean":<span class="cov0" title="0">
                distance, bearing = s.calculateEuclideanDistance(origin, destination)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported calculation method: %s", method)</span>
        }

        <span class="cov0" title="0">result := &amp;DistanceCalculation{
                DistanceMeters:    distance,
                DistanceKm:        distance / 1000,
                BearingDegrees:    bearing,
                CalculationMethod: method,
        }

        // Cache the result
        if s.config.Cache.EnableCaching </span><span class="cov0" title="0">{
                s.cacheRepo.Set(ctx, cacheKey, result, time.Duration(s.config.Cache.DistanceCacheTTL)*time.Second)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).WithFields(logger.Fields{
                "method":      method,
                "distance_km": result.DistanceKm,
                "bearing":     result.BearingDegrees,
        }).Debug("Distance calculated")

        return result, nil</span>
}

// CalculateETA calculates estimated time of arrival and route information
func (s *GeospatialService) CalculateETA(ctx context.Context, origin, destination models.Location, vehicleType string, departureTime time.Time, includeTraffic bool) (*ETACalculation, error) <span class="cov0" title="0">{
        // Calculate base distance
        distanceCalc, err := s.CalculateDistance(ctx, origin, destination, "haversine")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to calculate distance for ETA: %w", err)
        }</span>

        // Get vehicle speed
        <span class="cov0" title="0">speed, exists := s.config.Geospatial.RouteOptimization.DefaultSpeeds[vehicleType]
        if !exists </span><span class="cov0" title="0">{
                speed = s.config.Geospatial.RouteOptimization.DefaultSpeeds["car"] // default to car speed
        }</span>

        // Calculate base duration (distance / speed)
        <span class="cov0" title="0">baseDurationHours := distanceCalc.DistanceKm / speed
        baseDurationSeconds := int(baseDurationHours * 3600)

        // Apply traffic factors if requested
        if includeTraffic </span><span class="cov0" title="0">{
                trafficFactor := s.getTrafficFactor(departureTime)
                baseDurationSeconds = int(float64(baseDurationSeconds) * trafficFactor)
        }</span>

        <span class="cov0" title="0">estimatedArrival := departureTime.Add(time.Duration(baseDurationSeconds) * time.Second)

        // Generate route summary
        routeSummary := fmt.Sprintf("Route from (%.6f, %.6f) to (%.6f, %.6f) via %s - %.2f km",
                origin.Latitude, origin.Longitude,
                destination.Latitude, destination.Longitude,
                vehicleType, distanceCalc.DistanceKm)

        // Generate waypoints (simplified - in reality would use routing service)
        waypoints := s.generateWaypoints(origin, destination, 3)

        result := &amp;ETACalculation{
                DurationSeconds:  baseDurationSeconds,
                DistanceMeters:   distanceCalc.DistanceMeters,
                RouteSummary:     routeSummary,
                Waypoints:        waypoints,
                EstimatedArrival: estimatedArrival,
        }

        s.logger.WithContext(ctx).WithFields(logger.Fields{
                "vehicle_type":     vehicleType,
                "duration_minutes": baseDurationSeconds / 60,
                "distance_km":      distanceCalc.DistanceKm,
                "include_traffic":  includeTraffic,
        }).Debug("ETA calculated")

        return result, nil</span>
}

// FindNearbyDrivers finds drivers within a specified radius of a location
func (s *GeospatialService) FindNearbyDrivers(ctx context.Context, center models.Location, radiusKm float64, limit int, vehicleTypes []string, onlyAvailable bool) ([]NearbyDriver, error) <span class="cov0" title="0">{
        // Validate radius
        if radiusKm &gt; s.config.Geospatial.MaxSearchRadiusKm </span><span class="cov0" title="0">{
                radiusKm = s.config.Geospatial.MaxSearchRadiusKm
        }</span>

        // Validate limit
        <span class="cov0" title="0">if limit &gt; s.config.Geospatial.MaxNearbyDrivers </span><span class="cov0" title="0">{
                limit = s.config.Geospatial.MaxNearbyDrivers
        }</span>

        // Get driver locations from repository
        <span class="cov0" title="0">driverLocations, err := s.driverRepo.FindNearbyDrivers(ctx, center, radiusKm, vehicleTypes, onlyAvailable)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find nearby drivers: %w", err)
        }</span>

        // Calculate distances and sort
        <span class="cov0" title="0">var nearbyDrivers []NearbyDriver
        for _, driverLoc := range driverLocations </span><span class="cov0" title="0">{
                distance, _ := s.calculateHaversineDistance(center, driverLoc.Location)

                nearbyDrivers = append(nearbyDrivers, NearbyDriver{
                        DriverID:           driverLoc.DriverID,
                        VehicleID:          driverLoc.VehicleID,
                        Location:           driverLoc.Location,
                        DistanceFromCenter: distance / 1000, // convert to km
                        Status:             driverLoc.Status,
                        VehicleType:        driverLoc.VehicleType,
                        Rating:             driverLoc.Rating,
                })
        }</span>

        // Sort by distance
        <span class="cov0" title="0">sort.Slice(nearbyDrivers, func(i, j int) bool </span><span class="cov0" title="0">{
                return nearbyDrivers[i].DistanceFromCenter &lt; nearbyDrivers[j].DistanceFromCenter
        }</span>)

        // Apply limit
        <span class="cov0" title="0">if len(nearbyDrivers) &gt; limit </span><span class="cov0" title="0">{
                nearbyDrivers = nearbyDrivers[:limit]
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).WithFields(logger.Fields{
                "center_lat":     center.Latitude,
                "center_lng":     center.Longitude,
                "radius_km":      radiusKm,
                "drivers_found":  len(nearbyDrivers),
                "only_available": onlyAvailable,
                "vehicle_types":  vehicleTypes,
        }).Info("Nearby drivers search completed")

        return nearbyDrivers, nil</span>
}

// UpdateDriverLocation updates a driver's location
func (s *GeospatialService) UpdateDriverLocation(ctx context.Context, driverID string, location models.Location, status string, vehicleID string) error <span class="cov0" title="0">{
        driverLocation := &amp;repository.DriverLocation{
                DriverID:  driverID,
                VehicleID: vehicleID,
                Location:  location,
                Status:    status,
                UpdatedAt: time.Now(),
        }

        err := s.driverRepo.UpdateDriverLocation(ctx, driverLocation)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update driver location: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.WithContext(ctx).WithFields(logger.Fields{
                "driver_id":  driverID,
                "vehicle_id": vehicleID,
                "latitude":   location.Latitude,
                "longitude":  location.Longitude,
                "status":     status,
        }).Info("Driver location updated")

        return nil</span>
}

// GenerateGeohash generates a geohash for a location
func (s *GeospatialService) GenerateGeohash(ctx context.Context, location models.Location, precision int) (string, error) <span class="cov0" title="0">{
        if precision &lt;= 0 </span><span class="cov0" title="0">{
                precision = s.config.Geospatial.DefaultGeohashPrecision
        }</span>

        // Validate precision
        <span class="cov0" title="0">if precision &lt; 1 || precision &gt; 12 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid geohash precision: %d (must be 1-12)", precision)
        }</span>

        <span class="cov0" title="0">geohash := s.calculateGeohash(location.Latitude, location.Longitude, precision)

        s.logger.WithContext(ctx).WithFields(logger.Fields{
                "latitude":  location.Latitude,
                "longitude": location.Longitude,
                "precision": precision,
                "geohash":   geohash,
        }).Debug("Geohash generated")

        return geohash, nil</span>
}

// PingMongo pings the MongoDB instance
func (s *GeospatialService) PingMongo(ctx context.Context) error <span class="cov0" title="0">{
        if s.mongo == nil </span><span class="cov0" title="0">{
                return errors.New("mongo client not initialized")
        }</span>
        <span class="cov0" title="0">return s.mongo.Ping(ctx, nil)</span>
}

// PingRedis pings the Redis instance
func (s *GeospatialService) PingRedis(ctx context.Context) error <span class="cov0" title="0">{
        if s.redis == nil </span><span class="cov0" title="0">{
                return errors.New("redis client not initialized")
        }</span>
        <span class="cov0" title="0">return s.redis.Ping(ctx).Err()</span>
}

// Private helper methods

// calculateHaversineDistance calculates the great-circle distance between two points
func (s *GeospatialService) calculateHaversineDistance(origin, destination models.Location) (float64, float64) <span class="cov0" title="0">{
        const earthRadiusKm = 6371

        lat1Rad := origin.Latitude * math.Pi / 180
        lat2Rad := destination.Latitude * math.Pi / 180
        deltaLatRad := (destination.Latitude - origin.Latitude) * math.Pi / 180
        deltaLngRad := (destination.Longitude - origin.Longitude) * math.Pi / 180

        a := math.Sin(deltaLatRad/2)*math.Sin(deltaLatRad/2) +
                math.Cos(lat1Rad)*math.Cos(lat2Rad)*
                        math.Sin(deltaLngRad/2)*math.Sin(deltaLngRad/2)
        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))

        distanceKm := earthRadiusKm * c
        distanceMeters := distanceKm * 1000

        // Calculate bearing
        y := math.Sin(deltaLngRad) * math.Cos(lat2Rad)
        x := math.Cos(lat1Rad)*math.Sin(lat2Rad) - math.Sin(lat1Rad)*math.Cos(lat2Rad)*math.Cos(deltaLngRad)
        bearing := math.Atan2(y, x) * 180 / math.Pi
        if bearing &lt; 0 </span><span class="cov0" title="0">{
                bearing += 360
        }</span>

        <span class="cov0" title="0">return distanceMeters, bearing</span>
}

// calculateManhattanDistance calculates Manhattan distance (for city grids)
func (s *GeospatialService) calculateManhattanDistance(origin, destination models.Location) (float64, float64) <span class="cov0" title="0">{
        const degreesToMeters = 111000 // approximate meters per degree at equator

        deltaLat := math.Abs(destination.Latitude - origin.Latitude)
        deltaLng := math.Abs(destination.Longitude - origin.Longitude)

        latDistance := deltaLat * degreesToMeters
        lngDistance := deltaLng * degreesToMeters * math.Cos(origin.Latitude*math.Pi/180)

        distance := latDistance + lngDistance

        // Calculate approximate bearing
        bearing := math.Atan2(destination.Longitude-origin.Longitude, destination.Latitude-origin.Latitude) * 180 / math.Pi
        if bearing &lt; 0 </span><span class="cov0" title="0">{
                bearing += 360
        }</span>

        <span class="cov0" title="0">return distance, bearing</span>
}

// calculateEuclideanDistance calculates straight-line distance
func (s *GeospatialService) calculateEuclideanDistance(origin, destination models.Location) (float64, float64) <span class="cov0" title="0">{
        const degreesToMeters = 111000

        deltaLat := (destination.Latitude - origin.Latitude) * degreesToMeters
        deltaLng := (destination.Longitude - origin.Longitude) * degreesToMeters * math.Cos(origin.Latitude*math.Pi/180)

        distance := math.Sqrt(deltaLat*deltaLat + deltaLng*deltaLng)

        bearing := math.Atan2(deltaLng, deltaLat) * 180 / math.Pi
        if bearing &lt; 0 </span><span class="cov0" title="0">{
                bearing += 360
        }</span>

        <span class="cov0" title="0">return distance, bearing</span>
}

// getTrafficFactor returns traffic multiplier based on time of day
func (s *GeospatialService) getTrafficFactor(departureTime time.Time) float64 <span class="cov0" title="0">{
        hour := departureTime.Hour()

        // Rush hour times (7-9 AM, 5-7 PM)
        if (hour &gt;= 7 &amp;&amp; hour &lt;= 9) || (hour &gt;= 17 &amp;&amp; hour &lt;= 19) </span><span class="cov0" title="0">{
                return s.config.Geospatial.RouteOptimization.TrafficFactors["rush_hour"]
        }</span>

        // Late night (11 PM - 5 AM)
        <span class="cov0" title="0">if hour &gt;= 23 || hour &lt;= 5 </span><span class="cov0" title="0">{
                return s.config.Geospatial.RouteOptimization.TrafficFactors["late_night"]
        }</span>

        // Normal hours
        <span class="cov0" title="0">return s.config.Geospatial.RouteOptimization.TrafficFactors["normal"]</span>
}

// generateWaypoints generates intermediate waypoints for a route
func (s *GeospatialService) generateWaypoints(origin, destination models.Location, count int) []models.Location <span class="cov0" title="0">{
        var waypoints []models.Location

        // Add origin
        waypoints = append(waypoints, origin)

        // Generate intermediate points
        for i := 1; i &lt; count; i++ </span><span class="cov0" title="0">{
                ratio := float64(i) / float64(count)

                lat := origin.Latitude + ratio*(destination.Latitude-origin.Latitude)
                lng := origin.Longitude + ratio*(destination.Longitude-origin.Longitude)

                waypoints = append(waypoints, models.Location{
                        Latitude:  lat,
                        Longitude: lng,
                        Timestamp: time.Now(),
                })
        }</span>

        // Add destination
        <span class="cov0" title="0">waypoints = append(waypoints, destination)

        return waypoints</span>
}

// calculateGeohash generates a geohash for given coordinates
func (s *GeospatialService) calculateGeohash(lat, lng float64, precision int) string <span class="cov0" title="0">{
        // Simplified geohash implementation
        // In production, use a proper geohash library

        const base32 = "0123456789bcdefghjkmnpqrstuvwxyz"
        var geohash string

        latRange := []float64{-90.0, 90.0}
        lngRange := []float64{-180.0, 180.0}

        var even bool = true
        var bit int = 0
        var ch int = 0

        for len(geohash) &lt; precision </span><span class="cov0" title="0">{
                if even </span><span class="cov0" title="0">{
                        // longitude
                        mid := (lngRange[0] + lngRange[1]) / 2
                        if lng &gt;= mid </span><span class="cov0" title="0">{
                                ch |= (1 &lt;&lt; (4 - bit))
                                lngRange[0] = mid
                        }</span> else<span class="cov0" title="0"> {
                                lngRange[1] = mid
                        }</span>
                } else<span class="cov0" title="0"> {
                        // latitude
                        mid := (latRange[0] + latRange[1]) / 2
                        if lat &gt;= mid </span><span class="cov0" title="0">{
                                ch |= (1 &lt;&lt; (4 - bit))
                                latRange[0] = mid
                        }</span> else<span class="cov0" title="0"> {
                                latRange[1] = mid
                        }</span>
                }

                <span class="cov0" title="0">even = !even
                bit++

                if bit == 5 </span><span class="cov0" title="0">{
                        geohash += string(base32[ch])
                        bit = 0
                        ch = 0
                }</span>
        }

        <span class="cov0" title="0">return geohash</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "context"
        "log"
        "net"
        "net/http"
        "os"
        "os/signal"
        "strconv"
        "syscall"
        "time"

        "github.com/gin-gonic/gin"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        "github.com/rideshare-platform/services/geo-service/internal/config"
        grpcServer "github.com/rideshare-platform/services/geo-service/internal/grpc"
        "github.com/rideshare-platform/services/geo-service/internal/handler"
        "github.com/rideshare-platform/services/geo-service/internal/repository"
        "github.com/rideshare-platform/services/geo-service/internal/service"
        "github.com/rideshare-platform/shared/database"
        "github.com/rideshare-platform/shared/logger"
        "github.com/rideshare-platform/shared/models"
        geopb "github.com/rideshare-platform/shared/proto/geo"
)

func main() <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load configuration: %v", err)
        }</span>

        // Validate configuration
        <span class="cov0" title="0">if err := cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid configuration: %v", err)
        }</span>

        // Initialize logger
        <span class="cov0" title="0">appLogger := logger.NewLogger(cfg.LogLevel, cfg.Environment)

        appLogger.WithFields(logger.Fields{
                "service":   "geo-service",
                "version":   "1.0.0",
                "grpc_port": cfg.GRPCPort,
                "http_port": cfg.HTTPPort,
        }).Info("Starting Geospatial/ETA Service")

        // Initialize database connections
        mongoDB, err := database.NewMongoDB(&amp;cfg.Database, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                appLogger.WithError(err).Fatal("Failed to connect to MongoDB")
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := mongoDB.Close(context.Background()); err != nil </span><span class="cov0" title="0">{
                        appLogger.WithError(err).Error("Failed to close MongoDB connection")
                }</span>
        }()

        <span class="cov0" title="0">redisDB, err := database.NewRedisDB(cfg.Redis, appLogger)
        if err != nil </span><span class="cov0" title="0">{
                appLogger.WithError(err).Fatal("Failed to connect to Redis")
        }</span>
        <span class="cov0" title="0">defer redisDB.Close()

        // Initialize repositories
        driverLocationRepo := repository.NewDriverLocationRepository(mongoDB, appLogger)
        cacheRepo := repository.NewCacheRepository(redisDB, appLogger)

        // Initialize services
        geoService := service.NewGeospatialService(cfg, appLogger, driverLocationRepo, cacheRepo, mongoDB.Client, redisDB.Client)

        // Test the service with sample data
        testService(geoService, appLogger)

        // Initialize HTTP handler
        geoHandler := &amp;handler.GeoHandler{
                Logger:     appLogger,
                GeoService: geoService,
        }

        // Setup Gin router
        gin.SetMode(gin.ReleaseMode)
        router := gin.New()
        router.Use(gin.Recovery())

        // Register routes
        geoHandler.RegisterRoutes(router)

        // Start gRPC server
        grpcSrv := grpc.NewServer()
        geoGrpcServer := grpcServer.NewServer(*geoService, *appLogger)
        geopb.RegisterGeospatialServiceServer(grpcSrv, geoGrpcServer)

        // Enable gRPC reflection for debugging
        reflection.Register(grpcSrv)

        go func() </span><span class="cov0" title="0">{
                lis, err := net.Listen("tcp", ":"+strconv.Itoa(cfg.GRPCPort))
                if err != nil </span><span class="cov0" title="0">{
                        appLogger.WithError(err).Fatal("Failed to listen on gRPC port")
                }</span>

                <span class="cov0" title="0">appLogger.WithFields(logger.Fields{
                        "port": cfg.GRPCPort,
                }).Info("Starting gRPC server")

                if err := grpcSrv.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        appLogger.WithError(err).Fatal("Failed to start gRPC server")
                }</span>
        }()

        // Start HTTP server
        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:    ":" + strconv.Itoa(cfg.HTTPPort),
                Handler: router,
        }

        go func() </span><span class="cov0" title="0">{
                appLogger.WithFields(logger.Fields{
                        "port": cfg.HTTPPort,
                }).Info("Starting HTTP server")

                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        appLogger.WithError(err).Fatal("Failed to start HTTP server")
                }</span>
        }()

        // Listen for interrupt signals
        <span class="cov0" title="0">sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        appLogger.Logger.Info("Service started successfully. Press Ctrl+C to stop.")

        // Wait for interrupt signal
        &lt;-sigChan
        appLogger.Logger.Info("Received interrupt signal, starting graceful shutdown...")

        // Give time for graceful shutdown
        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer shutdownCancel()

        // Shutdown HTTP server gracefully
        if err := server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                appLogger.WithError(err).Error("Failed to shutdown HTTP server gracefully")
        }</span>

        // Shutdown gRPC server gracefully
        <span class="cov0" title="0">grpcSrv.GracefulStop()

        // Perform cleanup operations
        select </span>{
        case &lt;-shutdownCtx.Done():<span class="cov0" title="0">
                appLogger.Logger.Warn("Graceful shutdown timeout exceeded")</span>
        default:<span class="cov0" title="0">
                appLogger.Logger.Info("Service stopped gracefully")</span>
        }
}

// testService demonstrates the geospatial service functionality
func testService(geoService *service.GeospatialService, logger *logger.Logger) <span class="cov0" title="0">{
        ctx := context.Background()

        logger.Logger.Info("Testing Geospatial Service functionality...")

        // Test locations (New York City area)
        origin := models.Location{
                Latitude:  40.7128,
                Longitude: -74.0060,
                Timestamp: time.Now(),
        }

        destination := models.Location{
                Latitude:  40.7589,
                Longitude: -73.9851,
                Timestamp: time.Now(),
        }

        // Test distance calculation
        logger.Logger.Info("Testing distance calculation...")
        distance, err := geoService.CalculateDistance(ctx, origin, destination, "haversine")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("Distance calculation failed")
        }</span> else<span class="cov0" title="0"> {
                logger.Logger.WithFields(map[string]interface{}{
                        "distance_km": distance.DistanceKm,
                        "bearing":     distance.BearingDegrees,
                        "method":      distance.CalculationMethod,
                }).Info("Distance calculation successful")
        }</span>

        // Test ETA calculation
        <span class="cov0" title="0">logger.Logger.Info("Testing ETA calculation...")
        eta, err := geoService.CalculateETA(ctx, origin, destination, "car", time.Now(), true)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("ETA calculation failed")
        }</span> else<span class="cov0" title="0"> {
                logger.Logger.WithFields(map[string]interface{}{
                        "duration_minutes": eta.DurationSeconds / 60,
                        "distance_km":      eta.DistanceMeters / 1000,
                        "vehicle_type":     "car",
                }).Info("ETA calculation successful")
        }</span>

        // Test nearby drivers search
        <span class="cov0" title="0">logger.Logger.Info("Testing nearby drivers search...")
        drivers, err := geoService.FindNearbyDrivers(ctx, origin, 5.0, 10, []string{"sedan", "suv"}, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("Nearby drivers search failed")
        }</span> else<span class="cov0" title="0"> {
                logger.Logger.WithFields(map[string]interface{}{
                        "drivers_found": len(drivers),
                        "search_radius": 5.0,
                }).Info("Nearby drivers search successful")
        }</span>

        // Test driver location update
        <span class="cov0" title="0">logger.Logger.Info("Testing driver location update...")
        err = geoService.UpdateDriverLocation(ctx, "test_driver_001", origin, "online", "test_vehicle_001")
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("Driver location update failed")
        }</span> else<span class="cov0" title="0"> {
                logger.Logger.Info("Driver location update successful")
        }</span>

        // Test geohash generation
        <span class="cov0" title="0">logger.Logger.Info("Testing geohash generation...")
        geohash, err := geoService.GenerateGeohash(ctx, origin, 7)
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Error("Geohash generation failed")
        }</span> else<span class="cov0" title="0"> {
                logger.Logger.WithFields(map[string]interface{}{
                        "geohash":   geohash,
                        "precision": 7,
                }).Info("Geohash generation successful")
        }</span>

        <span class="cov0" title="0">logger.Logger.Info("Geospatial Service testing completed!")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

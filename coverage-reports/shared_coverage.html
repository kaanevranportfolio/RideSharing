
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rideshare-platform/shared/cache/cache.go (0.0%)</option>
				
				<option value="file1">github.com/rideshare-platform/shared/cache/geospatial.go (0.0%)</option>
				
				<option value="file2">github.com/rideshare-platform/shared/cache/memory.go (0.0%)</option>
				
				<option value="file3">github.com/rideshare-platform/shared/config/config.go (0.0%)</option>
				
				<option value="file4">github.com/rideshare-platform/shared/database/mongodb.go (0.0%)</option>
				
				<option value="file5">github.com/rideshare-platform/shared/database/postgres.go (0.0%)</option>
				
				<option value="file6">github.com/rideshare-platform/shared/database/redis.go (0.0%)</option>
				
				<option value="file7">github.com/rideshare-platform/shared/events/events.go (0.0%)</option>
				
				<option value="file8">github.com/rideshare-platform/shared/grpc/client.go (0.0%)</option>
				
				<option value="file9">github.com/rideshare-platform/shared/grpc/server.go (0.0%)</option>
				
				<option value="file10">github.com/rideshare-platform/shared/logger/logger.go (0.0%)</option>
				
				<option value="file11">github.com/rideshare-platform/shared/metrics/metrics.go (0.0%)</option>
				
				<option value="file12">github.com/rideshare-platform/shared/middleware/auth.go (0.0%)</option>
				
				<option value="file13">github.com/rideshare-platform/shared/middleware/logging.go (0.0%)</option>
				
				<option value="file14">github.com/rideshare-platform/shared/middleware/metrics.go (0.0%)</option>
				
				<option value="file15">github.com/rideshare-platform/shared/models/location.go (0.0%)</option>
				
				<option value="file16">github.com/rideshare-platform/shared/models/payment.go (0.0%)</option>
				
				<option value="file17">github.com/rideshare-platform/shared/models/pricing.go (0.0%)</option>
				
				<option value="file18">github.com/rideshare-platform/shared/models/trip.go (0.0%)</option>
				
				<option value="file19">github.com/rideshare-platform/shared/models/user.go (0.0%)</option>
				
				<option value="file20">github.com/rideshare-platform/shared/models/vehicle.go (0.0%)</option>
				
				<option value="file21">github.com/rideshare-platform/shared/proto/geo/geo.pb.go (0.0%)</option>
				
				<option value="file22">github.com/rideshare-platform/shared/proto/geo/geo_grpc.pb.go (0.0%)</option>
				
				<option value="file23">github.com/rideshare-platform/shared/proto/matching/matching.pb.go (0.0%)</option>
				
				<option value="file24">github.com/rideshare-platform/shared/proto/matching/matching_grpc.pb.go (0.0%)</option>
				
				<option value="file25">github.com/rideshare-platform/shared/proto/payment/payment.pb.go (0.0%)</option>
				
				<option value="file26">github.com/rideshare-platform/shared/proto/payment/payment_grpc.pb.go (0.0%)</option>
				
				<option value="file27">github.com/rideshare-platform/shared/proto/pricing/pricing.pb.go (0.0%)</option>
				
				<option value="file28">github.com/rideshare-platform/shared/proto/pricing/pricing_grpc.pb.go (0.0%)</option>
				
				<option value="file29">github.com/rideshare-platform/shared/proto/trip/trip.pb.go (0.0%)</option>
				
				<option value="file30">github.com/rideshare-platform/shared/proto/trip/trip_grpc.pb.go (0.0%)</option>
				
				<option value="file31">github.com/rideshare-platform/shared/proto/user/user.pb.go (0.0%)</option>
				
				<option value="file32">github.com/rideshare-platform/shared/proto/user/user_grpc.pb.go (0.0%)</option>
				
				<option value="file33">github.com/rideshare-platform/shared/utils/id.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/go-redis/redis/v8"
)

// Cache interface defines caching operations
type Cache interface {
        Get(ctx context.Context, key string, dest interface{}) error
        Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error
        Delete(ctx context.Context, key string) error
        Exists(ctx context.Context, key string) (bool, error)
        InvalidatePattern(ctx context.Context, pattern string) error
}

// RedisCache implements Cache interface using Redis
type RedisCache struct {
        client *redis.Client
        prefix string
}

// NewRedisCache creates a new Redis cache instance
func NewRedisCache(client *redis.Client, prefix string) *RedisCache <span class="cov0" title="0">{
        return &amp;RedisCache{
                client: client,
                prefix: prefix,
        }
}</span>

// Get retrieves a value from cache
func (c *RedisCache) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        fullKey := c.getFullKey(key)

        val, err := c.client.Get(ctx, fullKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                if err == redis.Nil </span><span class="cov0" title="0">{
                        return ErrCacheMiss
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("cache get error: %w", err)</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(val), dest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cache unmarshal error: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Set stores a value in cache
func (c *RedisCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        fullKey := c.getFullKey(key)

        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cache marshal error: %w", err)
        }</span>

        <span class="cov0" title="0">if err := c.client.Set(ctx, fullKey, data, expiration).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cache set error: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a key from cache
func (c *RedisCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        fullKey := c.getFullKey(key)

        if err := c.client.Del(ctx, fullKey).Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cache delete error: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a key exists in cache
func (c *RedisCache) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        fullKey := c.getFullKey(key)

        count, err := c.client.Exists(ctx, fullKey).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cache exists error: %w", err)
        }</span>

        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// InvalidatePattern removes all keys matching a pattern
func (c *RedisCache) InvalidatePattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        fullPattern := c.getFullKey(pattern)

        keys, err := c.client.Keys(ctx, fullPattern).Result()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cache keys error: %w", err)
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                if err := c.client.Del(ctx, keys...).Err(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cache invalidate error: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *RedisCache) getFullKey(key string) string <span class="cov0" title="0">{
        if c.prefix == "" </span><span class="cov0" title="0">{
                return key
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s:%s", c.prefix, key)</span>
}

// ErrCacheMiss is returned when a key is not found in cache
var ErrCacheMiss = fmt.Errorf("cache miss")

// Multi-level cache implementation
type MultiLevelCache struct {
        l1 Cache // In-memory cache
        l2 Cache // Redis cache
}

// NewMultiLevelCache creates a new multi-level cache
func NewMultiLevelCache(l1, l2 Cache) *MultiLevelCache <span class="cov0" title="0">{
        return &amp;MultiLevelCache{
                l1: l1,
                l2: l2,
        }
}</span>

// Get tries L1 first, then L2
func (c *MultiLevelCache) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        // Try L1 first
        if err := c.l1.Get(ctx, key, dest); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try L2
        <span class="cov0" title="0">if err := c.l2.Get(ctx, key, dest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Store in L1 for next time
        <span class="cov0" title="0">c.l1.Set(ctx, key, dest, time.Minute*5)
        return nil</span>
}

// Set stores in both levels
func (c *MultiLevelCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        // Set in L1 with shorter expiration
        l1Expiration := expiration
        if expiration &gt; time.Minute*10 </span><span class="cov0" title="0">{
                l1Expiration = time.Minute * 10
        }</span>
        <span class="cov0" title="0">c.l1.Set(ctx, key, value, l1Expiration)

        // Set in L2 with full expiration
        return c.l2.Set(ctx, key, value, expiration)</span>
}

// Delete removes from both levels
func (c *MultiLevelCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        c.l1.Delete(ctx, key)
        return c.l2.Delete(ctx, key)
}</span>

// Exists checks L1 first, then L2
func (c *MultiLevelCache) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        if exists, _ := c.l1.Exists(ctx, key); exists </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return c.l2.Exists(ctx, key)</span>
}

// InvalidatePattern removes from both levels
func (c *MultiLevelCache) InvalidatePattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        c.l1.InvalidatePattern(ctx, pattern)
        return c.l2.InvalidatePattern(ctx, pattern)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package cache

import (
        "context"
        "fmt"
        "time"

        "github.com/go-redis/redis/v8"
)

// GeospatialCache handles location-based caching for rideshare platform
type GeospatialCache struct {
        client *redis.Client
        prefix string
}

// NewGeospatialCache creates a new geospatial cache
func NewGeospatialCache(client *redis.Client, prefix string) *GeospatialCache <span class="cov0" title="0">{
        return &amp;GeospatialCache{
                client: client,
                prefix: prefix,
        }
}</span>

// Location represents a geographic location
type Location struct {
        ID        string                 `json:"id"`
        Latitude  float64                `json:"latitude"`
        Longitude float64                `json:"longitude"`
        Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// AddLocation adds a location to the geospatial index
func (c *GeospatialCache) AddLocation(ctx context.Context, key string, location Location) error <span class="cov0" title="0">{
        geoKey := c.getGeoKey(key)

        // Add to geospatial index
        err := c.client.GeoAdd(ctx, geoKey, &amp;redis.GeoLocation{
                Name:      location.ID,
                Longitude: location.Longitude,
                Latitude:  location.Latitude,
        }).Err()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("geospatial cache add error: %w", err)
        }</span>

        // Set expiration on the geo key
        <span class="cov0" title="0">c.client.Expire(ctx, geoKey, time.Hour*24)

        // Store additional metadata if provided
        if len(location.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                metaKey := c.getMetaKey(key, location.ID)
                err = c.client.HMSet(ctx, metaKey, location.Metadata).Err()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("geospatial metadata cache error: %w", err)
                }</span>
                <span class="cov0" title="0">c.client.Expire(ctx, metaKey, time.Hour*24)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FindNearby finds locations within a radius
func (c *GeospatialCache) FindNearby(ctx context.Context, key string, lat, lon, radiusKm float64, limit int) ([]Location, error) <span class="cov0" title="0">{
        geoKey := c.getGeoKey(key)

        // Query nearby locations
        result, err := c.client.GeoRadius(ctx, geoKey, lon, lat, &amp;redis.GeoRadiusQuery{
                Radius:    radiusKm,
                Unit:      "km",
                WithCoord: true,
                WithDist:  true,
                Count:     limit,
                Sort:      "ASC", // Closest first
        }).Result()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("geospatial nearby query error: %w", err)
        }</span>

        <span class="cov0" title="0">locations := make([]Location, 0, len(result))
        for _, item := range result </span><span class="cov0" title="0">{
                location := Location{
                        ID:        item.Name,
                        Longitude: item.Longitude,
                        Latitude:  item.Latitude,
                }

                // Get metadata if available
                metaKey := c.getMetaKey(key, item.Name)
                metadata, err := c.client.HGetAll(ctx, metaKey).Result()
                if err == nil &amp;&amp; len(metadata) &gt; 0 </span><span class="cov0" title="0">{
                        location.Metadata = make(map[string]interface{})
                        for k, v := range metadata </span><span class="cov0" title="0">{
                                location.Metadata[k] = v
                        }</span>
                }

                <span class="cov0" title="0">locations = append(locations, location)</span>
        }

        <span class="cov0" title="0">return locations, nil</span>
}

// RemoveLocation removes a location from the geospatial index
func (c *GeospatialCache) RemoveLocation(ctx context.Context, key string, locationID string) error <span class="cov0" title="0">{
        geoKey := c.getGeoKey(key)

        // Remove from geospatial index
        err := c.client.ZRem(ctx, geoKey, locationID).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("geospatial remove error: %w", err)
        }</span>

        // Remove metadata
        <span class="cov0" title="0">metaKey := c.getMetaKey(key, locationID)
        c.client.Del(ctx, metaKey)

        return nil</span>
}

// UpdateLocationMetadata updates metadata for a location
func (c *GeospatialCache) UpdateLocationMetadata(ctx context.Context, key string, locationID string, metadata map[string]interface{}) error <span class="cov0" title="0">{
        metaKey := c.getMetaKey(key, locationID)

        err := c.client.HMSet(ctx, metaKey, metadata).Err()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("geospatial metadata update error: %w", err)
        }</span>

        <span class="cov0" title="0">c.client.Expire(ctx, metaKey, time.Hour*24)
        return nil</span>
}

// GetDistance calculates distance between two locations in the cache
func (c *GeospatialCache) GetDistance(ctx context.Context, key string, location1, location2 string) (float64, error) <span class="cov0" title="0">{
        geoKey := c.getGeoKey(key)

        result, err := c.client.GeoDist(ctx, geoKey, location1, location2, "km").Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("geospatial distance error: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// ClearArea removes all locations in a geographic area
func (c *GeospatialCache) ClearArea(ctx context.Context, key string, lat, lon, radiusKm float64) error <span class="cov0" title="0">{
        geoKey := c.getGeoKey(key)

        // Find all locations in the area
        result, err := c.client.GeoRadius(ctx, geoKey, lon, lat, &amp;redis.GeoRadiusQuery{
                Radius: radiusKm,
                Unit:   "km",
        }).Result()

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("geospatial clear area query error: %w", err)
        }</span>

        // Remove each location
        <span class="cov0" title="0">for _, item := range result </span><span class="cov0" title="0">{
                c.RemoveLocation(ctx, key, item.Name)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *GeospatialCache) getGeoKey(key string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:geo:%s", c.prefix, key)
}</span>

func (c *GeospatialCache) getMetaKey(key, locationID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:meta:%s:%s", c.prefix, key, locationID)
}</span>

// Cache invalidation patterns for rideshare platform
type CacheInvalidator struct {
        cache Cache
}

// NewCacheInvalidator creates a cache invalidator
func NewCacheInvalidator(cache Cache) *CacheInvalidator <span class="cov0" title="0">{
        return &amp;CacheInvalidator{cache: cache}
}</span>

// InvalidateUser invalidates all user-related cache entries
func (c *CacheInvalidator) InvalidateUser(ctx context.Context, userID string) error <span class="cov0" title="0">{
        patterns := []string{
                fmt.Sprintf("user:%s:*", userID),
                fmt.Sprintf("auth:%s:*", userID),
                fmt.Sprintf("profile:%s", userID),
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if err := c.cache.InvalidatePattern(ctx, pattern); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// InvalidateVehicle invalidates all vehicle-related cache entries
func (c *CacheInvalidator) InvalidateVehicle(ctx context.Context, vehicleID string) error <span class="cov0" title="0">{
        patterns := []string{
                fmt.Sprintf("vehicle:%s:*", vehicleID),
                fmt.Sprintf("location:%s", vehicleID),
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if err := c.cache.InvalidatePattern(ctx, pattern); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// InvalidateTrip invalidates all trip-related cache entries
func (c *CacheInvalidator) InvalidateTrip(ctx context.Context, tripID string) error <span class="cov0" title="0">{
        patterns := []string{
                fmt.Sprintf("trip:%s:*", tripID),
                fmt.Sprintf("pricing:%s", tripID),
                fmt.Sprintf("route:%s", tripID),
        }

        for _, pattern := range patterns </span><span class="cov0" title="0">{
                if err := c.cache.InvalidatePattern(ctx, pattern); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"
)

// MemoryCache implements an in-memory cache with TTL
type MemoryCache struct {
        items map[string]*cacheItem
        mutex sync.RWMutex
        ttl   time.Duration
}

type cacheItem struct {
        data      []byte
        expiresAt time.Time
}

// NewMemoryCache creates a new in-memory cache
func NewMemoryCache(defaultTTL time.Duration) *MemoryCache <span class="cov0" title="0">{
        cache := &amp;MemoryCache{
                items: make(map[string]*cacheItem),
                ttl:   defaultTTL,
        }

        // Start cleanup goroutine
        go cache.cleanup()

        return cache
}</span>

// Get retrieves a value from memory cache
func (c *MemoryCache) Get(ctx context.Context, key string, dest interface{}) error <span class="cov0" title="0">{
        c.mutex.RLock()
        item, exists := c.items[key]
        c.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return ErrCacheMiss
        }</span>

        // Check if expired
        <span class="cov0" title="0">if time.Now().After(item.expiresAt) </span><span class="cov0" title="0">{
                c.mutex.Lock()
                delete(c.items, key)
                c.mutex.Unlock()
                return ErrCacheMiss
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(item.data, dest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("memory cache unmarshal error: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Set stores a value in memory cache
func (c *MemoryCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("memory cache marshal error: %w", err)
        }</span>

        <span class="cov0" title="0">if expiration == 0 </span><span class="cov0" title="0">{
                expiration = c.ttl
        }</span>

        <span class="cov0" title="0">c.mutex.Lock()
        c.items[key] = &amp;cacheItem{
                data:      data,
                expiresAt: time.Now().Add(expiration),
        }
        c.mutex.Unlock()

        return nil</span>
}

// Delete removes a key from memory cache
func (c *MemoryCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        c.mutex.Lock()
        delete(c.items, key)
        c.mutex.Unlock()
        return nil
}</span>

// Exists checks if a key exists in memory cache
func (c *MemoryCache) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        c.mutex.RLock()
        item, exists := c.items[key]
        c.mutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Check if expired
        <span class="cov0" title="0">if time.Now().After(item.expiresAt) </span><span class="cov0" title="0">{
                c.mutex.Lock()
                delete(c.items, key)
                c.mutex.Unlock()
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// InvalidatePattern removes all keys matching a pattern (simple prefix matching)
func (c *MemoryCache) InvalidatePattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        keysToDelete := make([]string, 0)
        for key := range c.items </span><span class="cov0" title="0">{
                // Simple pattern matching - could be enhanced with regex
                if len(key) &gt;= len(pattern) &amp;&amp; key[:len(pattern)] == pattern </span><span class="cov0" title="0">{
                        keysToDelete = append(keysToDelete, key)
                }</span>
        }

        <span class="cov0" title="0">for _, key := range keysToDelete </span><span class="cov0" title="0">{
                delete(c.items, key)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// cleanup removes expired items periodically
func (c *MemoryCache) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.mutex.Lock()
                now := time.Now()
                for key, item := range c.items </span><span class="cov0" title="0">{
                        if now.After(item.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.items, key)
                        }</span>
                }
                <span class="cov0" title="0">c.mutex.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "time"
)

// Config represents the application configuration
type Config struct {
        // Server configuration
        Server ServerConfig `json:"server"`

        // Database configurations
        Database DatabaseConfig `json:"database"`
        MongoDB  MongoConfig    `json:"mongodb"`
        Redis    RedisConfig    `json:"redis"`

        // External services
        JWT   JWTConfig   `json:"jwt"`
        Kafka KafkaConfig `json:"kafka"`

        // Monitoring
        Metrics MetricsConfig `json:"metrics"`

        // Environment
        Environment string `json:"environment"`
        LogLevel    string `json:"log_level"`
}

// ServerConfig represents server configuration
type ServerConfig struct {
        Host         string        `json:"host"`
        Port         int           `json:"port"`
        ReadTimeout  time.Duration `json:"read_timeout"`
        WriteTimeout time.Duration `json:"write_timeout"`
        IdleTimeout  time.Duration `json:"idle_timeout"`
}

// DatabaseConfig represents PostgreSQL database configuration
type DatabaseConfig struct {
        Host            string        `json:"host"`
        Port            int           `json:"port"`
        Database        string        `json:"database"`
        Username        string        `json:"username"`
        Password        string        `json:"password"`
        SSLMode         string        `json:"ssl_mode"`
        MaxOpenConns    int           `json:"max_open_conns"`
        MaxIdleConns    int           `json:"max_idle_conns"`
        ConnMaxLifetime time.Duration `json:"conn_max_lifetime"`
        ConnMaxIdleTime time.Duration `json:"conn_max_idle_time"`
}

// MongoConfig represents MongoDB configuration
type MongoConfig struct {
        URI                    string        `json:"uri"`
        Database               string        `json:"database"`
        MaxPoolSize            uint64        `json:"max_pool_size"`
        MinPoolSize            uint64        `json:"min_pool_size"`
        MaxConnIdleTime        time.Duration `json:"max_conn_idle_time"`
        MaxConnecting          uint64        `json:"max_connecting"`
        ConnectTimeout         time.Duration `json:"connect_timeout"`
        ServerSelectionTimeout time.Duration `json:"server_selection_timeout"`
}

// RedisConfig represents Redis configuration
type RedisConfig struct {
        Host         string        `json:"host"`
        Port         int           `json:"port"`
        Password     string        `json:"password"`
        Database     int           `json:"database"`
        PoolSize     int           `json:"pool_size"`
        MinIdleConns int           `json:"min_idle_conns"`
        DialTimeout  time.Duration `json:"dial_timeout"`
        ReadTimeout  time.Duration `json:"read_timeout"`
        WriteTimeout time.Duration `json:"write_timeout"`
        IdleTimeout  time.Duration `json:"idle_timeout"`
}

// JWTConfig represents JWT configuration
type JWTConfig struct {
        SecretKey       string        `json:"secret_key"`
        ExpiryDuration  time.Duration `json:"expiry_duration"`
        RefreshDuration time.Duration `json:"refresh_duration"`
        Issuer          string        `json:"issuer"`
}

// KafkaConfig represents Kafka configuration
type KafkaConfig struct {
        Brokers []string `json:"brokers"`
        GroupID string   `json:"group_id"`
}

// MetricsConfig represents metrics configuration
type MetricsConfig struct {
        Enabled bool   `json:"enabled"`
        Host    string `json:"host"`
        Port    int    `json:"port"`
        Path    string `json:"path"`
}

// LoadConfig loads configuration from environment variables
func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        config := &amp;Config{
                Server: ServerConfig{
                        Host:         getEnv("SERVER_HOST", "0.0.0.0"),
                        Port:         getEnvAsInt("SERVER_PORT", 8080),
                        ReadTimeout:  getEnvAsDuration("SERVER_READ_TIMEOUT", 30*time.Second),
                        WriteTimeout: getEnvAsDuration("SERVER_WRITE_TIMEOUT", 30*time.Second),
                        IdleTimeout:  getEnvAsDuration("SERVER_IDLE_TIMEOUT", 120*time.Second),
                },
                Database: DatabaseConfig{
                        Host:            getEnv("DB_HOST", "localhost"),
                        Port:            getEnvAsInt("DB_PORT", 5432),
                        Database:        getEnv("DB_NAME", "rideshare_platform"),
                        Username:        getEnv("DB_USER", "rideshare"),
                        Password:        getEnv("DB_PASSWORD", ""),
                        SSLMode:         getEnv("DB_SSL_MODE", "disable"),
                        MaxOpenConns:    getEnvAsInt("DB_MAX_OPEN_CONNS", 100),
                        MaxIdleConns:    getEnvAsInt("DB_MAX_IDLE_CONNS", 25),
                        ConnMaxLifetime: getEnvAsDuration("DB_CONN_MAX_LIFETIME", time.Hour),
                        ConnMaxIdleTime: getEnvAsDuration("DB_CONN_MAX_IDLE_TIME", 15*time.Minute),
                },
                MongoDB: MongoConfig{
                        URI:                    getEnv("MONGO_URI", "mongodb://localhost:27017"),
                        Database:               getEnv("MONGO_DATABASE", "rideshare_geo"),
                        MaxPoolSize:            uint64(getEnvAsInt("MONGO_MAX_POOL_SIZE", 100)),
                        MinPoolSize:            uint64(getEnvAsInt("MONGO_MIN_POOL_SIZE", 10)),
                        MaxConnIdleTime:        getEnvAsDuration("MONGO_MAX_CONN_IDLE_TIME", 30*time.Minute),
                        MaxConnecting:          uint64(getEnvAsInt("MONGO_MAX_CONNECTING", 10)),
                        ConnectTimeout:         getEnvAsDuration("MONGO_CONNECT_TIMEOUT", 10*time.Second),
                        ServerSelectionTimeout: getEnvAsDuration("MONGO_SERVER_SELECTION_TIMEOUT", 5*time.Second),
                },
                Redis: RedisConfig{
                        Host:         getEnv("REDIS_HOST", "localhost"),
                        Port:         getEnvAsInt("REDIS_PORT", 6379),
                        Password:     getEnv("REDIS_PASSWORD", ""),
                        Database:     getEnvAsInt("REDIS_DATABASE", 0),
                        PoolSize:     getEnvAsInt("REDIS_POOL_SIZE", 100),
                        MinIdleConns: getEnvAsInt("REDIS_MIN_IDLE_CONNS", 10),
                        DialTimeout:  getEnvAsDuration("REDIS_DIAL_TIMEOUT", 5*time.Second),
                        ReadTimeout:  getEnvAsDuration("REDIS_READ_TIMEOUT", 3*time.Second),
                        WriteTimeout: getEnvAsDuration("REDIS_WRITE_TIMEOUT", 3*time.Second),
                        IdleTimeout:  getEnvAsDuration("REDIS_IDLE_TIMEOUT", 5*time.Minute),
                },
                JWT: JWTConfig{
                        SecretKey:       getEnv("JWT_SECRET", "your-secret-key"),
                        ExpiryDuration:  getEnvAsDuration("JWT_EXPIRY", 24*time.Hour),
                        RefreshDuration: getEnvAsDuration("JWT_REFRESH_EXPIRY", 7*24*time.Hour),
                        Issuer:          getEnv("JWT_ISSUER", "rideshare-platform"),
                },
                Kafka: KafkaConfig{
                        Brokers: getEnvAsSlice("KAFKA_BROKERS", []string{"localhost:9092"}),
                        GroupID: getEnv("KAFKA_GROUP_ID", "rideshare-platform"),
                },
                Metrics: MetricsConfig{
                        Enabled: getEnvAsBool("METRICS_ENABLED", true),
                        Host:    getEnv("METRICS_HOST", "0.0.0.0"),
                        Port:    getEnvAsInt("METRICS_PORT", 9090),
                        Path:    getEnv("METRICS_PATH", "/metrics"),
                },
                Environment: getEnv("ENVIRONMENT", "development"),
                LogLevel:    getEnv("LOG_LEVEL", "info"),
        }

        return config, nil
}</span>

// GetDatabaseURL returns the PostgreSQL connection URL
func (c *DatabaseConfig) GetDatabaseURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=%s",
                c.Username, c.Password, c.Host, c.Port, c.Database, c.SSLMode)
}</span>

// GetRedisURL returns the Redis connection URL
func (c *RedisConfig) GetRedisURL() string <span class="cov0" title="0">{
        if c.Password != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("redis://:%s@%s:%d/%d", c.Password, c.Host, c.Port, c.Database)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("redis://%s:%d/%d", c.Host, c.Port, c.Database)</span>
}

// IsDevelopment returns true if running in development environment
func (c *Config) IsDevelopment() bool <span class="cov0" title="0">{
        return c.Environment == "development"
}</span>

// IsProduction returns true if running in production environment
func (c *Config) IsProduction() bool <span class="cov0" title="0">{
        return c.Environment == "production"
}</span>

// IsStaging returns true if running in staging environment
func (c *Config) IsStaging() bool <span class="cov0" title="0">{
        return c.Environment == "staging"
}</span>

// Helper functions for environment variable parsing

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsBool(key string, defaultValue bool) bool <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if boolValue, err := strconv.ParseBool(value); err == nil </span><span class="cov0" title="0">{
                        return boolValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsDuration(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvAsSlice(key string, defaultValue []string) []string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                // Simple comma-separated parsing
                // For more complex parsing, consider using a proper CSV parser
                result := []string{}
                for _, item := range []string{value} </span><span class="cov0" title="0">{
                        if item != "" </span><span class="cov0" title="0">{
                                result = append(result, item)
                        }</span>
                }
                <span class="cov0" title="0">if len(result) &gt; 0 </span><span class="cov0" title="0">{
                        return result
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Database.Password == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("database password is required")
        }</span>

        <span class="cov0" title="0">if c.JWT.SecretKey == "" || c.JWT.SecretKey == "your-secret-key" </span><span class="cov0" title="0">{
                return fmt.Errorf("JWT secret key must be set and not use default value")
        }</span>

        <span class="cov0" title="0">if len(c.Kafka.Brokers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("at least one Kafka broker is required")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/rideshare-platform/shared/config"
        "github.com/rideshare-platform/shared/logger"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "go.mongodb.org/mongo-driver/mongo/readpref"
)

// MongoDB represents a MongoDB database connection
type MongoDB struct {
        Client   *mongo.Client
        Database *mongo.Database
        config   *config.DatabaseConfig
        logger   *logger.Logger
}

// NewMongoDB creates a new MongoDB database connection
func NewMongoDB(cfg *config.DatabaseConfig, log *logger.Logger) (*MongoDB, error) <span class="cov0" title="0">{
        // Build connection URI
        var uri string
        if cfg.Username != "" &amp;&amp; cfg.Password != "" </span><span class="cov0" title="0">{
                uri = fmt.Sprintf("mongodb://%s:%s@%s:%d/%s?authSource=admin",
                        cfg.Username, cfg.Password, cfg.Host, cfg.Port, cfg.Database)
        }</span> else<span class="cov0" title="0"> {
                uri = fmt.Sprintf("mongodb://%s:%d/%s",
                        cfg.Host, cfg.Port, cfg.Database)
        }</span>

        // Set client options
        <span class="cov0" title="0">clientOptions := options.Client().ApplyURI(uri)

        // Configure connection pool
        clientOptions.SetMaxPoolSize(uint64(cfg.MaxOpenConns))
        clientOptions.SetMinPoolSize(uint64(cfg.MaxIdleConns))
        clientOptions.SetMaxConnIdleTime(time.Duration(cfg.ConnMaxIdleTime) * time.Second)
        clientOptions.SetConnectTimeout(10 * time.Second)
        clientOptions.SetServerSelectionTimeout(5 * time.Second)

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        // Connect to MongoDB
        client, err := mongo.Connect(ctx, clientOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to MongoDB: %w", err)
        }</span>

        // Test the connection
        <span class="cov0" title="0">if err := client.Ping(ctx, readpref.Primary()); err != nil </span><span class="cov0" title="0">{
                client.Disconnect(ctx)
                return nil, fmt.Errorf("failed to ping MongoDB: %w", err)
        }</span>

        <span class="cov0" title="0">database := client.Database(cfg.Database)

        log.WithFields(logger.Fields{
                "host":     cfg.Host,
                "port":     cfg.Port,
                "database": cfg.Database,
        }).Info("Connected to MongoDB database")

        return &amp;MongoDB{
                Client:   client,
                Database: database,
                config:   cfg,
                logger:   log,
        }, nil</span>
}

// Close closes the MongoDB connection
func (m *MongoDB) Close(ctx context.Context) error <span class="cov0" title="0">{
        if m.Client != nil </span><span class="cov0" title="0">{
                m.logger.Logger.Info("Closing MongoDB database connection")
                return m.Client.Disconnect(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Health checks the MongoDB health
func (m *MongoDB) Health(ctx context.Context) error <span class="cov0" title="0">{
        return m.Client.Ping(ctx, readpref.Primary())
}</span>

// Collection returns a collection handle
func (m *MongoDB) Collection(name string) *mongo.Collection <span class="cov0" title="0">{
        return m.Database.Collection(name)
}</span>

// WithTransaction executes a function within a MongoDB transaction
func (m *MongoDB) WithTransaction(ctx context.Context, fn func(mongo.SessionContext) error) error <span class="cov0" title="0">{
        session, err := m.Client.StartSession()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start session: %w", err)
        }</span>
        <span class="cov0" title="0">defer session.EndSession(ctx)

        m.logger.WithContext(ctx).Debug("MongoDB transaction started")

        _, err = session.WithTransaction(ctx, func(sc mongo.SessionContext) (interface{}, error) </span><span class="cov0" title="0">{
                return nil, fn(sc)
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                m.logger.WithContext(ctx).WithError(err).Error("MongoDB transaction failed")
                return err
        }</span>

        <span class="cov0" title="0">m.logger.WithContext(ctx).Debug("MongoDB transaction completed")
        return nil</span>
}

// MongoRepository provides common MongoDB operations
type MongoRepository struct {
        collection *mongo.Collection
        logger     *logger.Logger
}

// NewMongoRepository creates a new MongoDB repository
func NewMongoRepository(db *MongoDB, collectionName string, logger *logger.Logger) *MongoRepository <span class="cov0" title="0">{
        return &amp;MongoRepository{
                collection: db.Collection(collectionName),
                logger:     logger,
        }
}</span>

// InsertOne inserts a single document
func (r *MongoRepository) InsertOne(ctx context.Context, document interface{}) (*mongo.InsertOneResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.InsertOne(ctx, document)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "InsertOne", duration, err)
        return result, err
}</span>

// InsertMany inserts multiple documents
func (r *MongoRepository) InsertMany(ctx context.Context, documents []interface{}) (*mongo.InsertManyResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.InsertMany(ctx, documents)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "InsertMany", duration, err)
        return result, err
}</span>

// FindOne finds a single document
func (r *MongoRepository) FindOne(ctx context.Context, filter interface{}) *mongo.SingleResult <span class="cov0" title="0">{
        start := time.Now()
        result := r.collection.FindOne(ctx, filter)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "FindOne", duration, nil)
        return result
}</span>

// Find finds multiple documents
func (r *MongoRepository) Find(ctx context.Context, filter interface{}, opts ...*options.FindOptions) (*mongo.Cursor, error) <span class="cov0" title="0">{
        start := time.Now()
        cursor, err := r.collection.Find(ctx, filter, opts...)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "Find", duration, err)
        return cursor, err
}</span>

// UpdateOne updates a single document
func (r *MongoRepository) UpdateOne(ctx context.Context, filter, update interface{}) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.UpdateOne(ctx, filter, update)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "UpdateOne", duration, err)
        return result, err
}</span>

// UpdateMany updates multiple documents
func (r *MongoRepository) UpdateMany(ctx context.Context, filter, update interface{}) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.UpdateMany(ctx, filter, update)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "UpdateMany", duration, err)
        return result, err
}</span>

// ReplaceOne replaces a single document
func (r *MongoRepository) ReplaceOne(ctx context.Context, filter, replacement interface{}) (*mongo.UpdateResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.ReplaceOne(ctx, filter, replacement)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "ReplaceOne", duration, err)
        return result, err
}</span>

// DeleteOne deletes a single document
func (r *MongoRepository) DeleteOne(ctx context.Context, filter interface{}) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.DeleteOne(ctx, filter)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "DeleteOne", duration, err)
        return result, err
}</span>

// DeleteMany deletes multiple documents
func (r *MongoRepository) DeleteMany(ctx context.Context, filter interface{}) (*mongo.DeleteResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.DeleteMany(ctx, filter)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "DeleteMany", duration, err)
        return result, err
}</span>

// CountDocuments counts documents matching a filter
func (r *MongoRepository) CountDocuments(ctx context.Context, filter interface{}) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        count, err := r.collection.CountDocuments(ctx, filter)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "CountDocuments", duration, err)
        return count, err
}</span>

// Aggregate performs an aggregation operation
func (r *MongoRepository) Aggregate(ctx context.Context, pipeline interface{}) (*mongo.Cursor, error) <span class="cov0" title="0">{
        start := time.Now()
        cursor, err := r.collection.Aggregate(ctx, pipeline)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "Aggregate", duration, err)
        return cursor, err
}</span>

// CreateIndex creates an index on the collection
func (r *MongoRepository) CreateIndex(ctx context.Context, model mongo.IndexModel) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        name, err := r.collection.Indexes().CreateOne(ctx, model)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "CreateIndex", duration, err)
        return name, err
}</span>

// CreateIndexes creates multiple indexes on the collection
func (r *MongoRepository) CreateIndexes(ctx context.Context, models []mongo.IndexModel) ([]string, error) <span class="cov0" title="0">{
        start := time.Now()
        names, err := r.collection.Indexes().CreateMany(ctx, models)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "CreateIndexes", duration, err)
        return names, err
}</span>

// DropIndex drops an index from the collection
func (r *MongoRepository) DropIndex(ctx context.Context, name string) error <span class="cov0" title="0">{
        start := time.Now()
        _, err := r.collection.Indexes().DropOne(ctx, name)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "DropIndex", duration, err)
        return err
}</span>

// ListIndexes lists all indexes on the collection
func (r *MongoRepository) ListIndexes(ctx context.Context) (*mongo.Cursor, error) <span class="cov0" title="0">{
        start := time.Now()
        cursor, err := r.collection.Indexes().List(ctx)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "ListIndexes", duration, err)
        return cursor, err
}</span>

// BulkWrite performs multiple write operations
func (r *MongoRepository) BulkWrite(ctx context.Context, models []mongo.WriteModel) (*mongo.BulkWriteResult, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := r.collection.BulkWrite(ctx, models)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "BulkWrite", duration, err)
        return result, err
}</span>

// Watch creates a change stream for the collection
func (r *MongoRepository) Watch(ctx context.Context, pipeline interface{}) (*mongo.ChangeStream, error) <span class="cov0" title="0">{
        start := time.Now()
        stream, err := r.collection.Watch(ctx, pipeline)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "Watch", duration, err)
        return stream, err
}</span>

// Distinct gets distinct values for a field
func (r *MongoRepository) Distinct(ctx context.Context, fieldName string, filter interface{}) ([]interface{}, error) <span class="cov0" title="0">{
        start := time.Now()
        values, err := r.collection.Distinct(ctx, fieldName, filter)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "Distinct", duration, err)
        return values, err
}</span>

// EstimatedDocumentCount gets an estimated count of documents
func (r *MongoRepository) EstimatedDocumentCount(ctx context.Context) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        count, err := r.collection.EstimatedDocumentCount(ctx)
        duration := time.Since(start)

        r.logger.LogDatabaseQuery(ctx, "EstimatedDocumentCount", duration, err)
        return count, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/rideshare-platform/shared/config"
        "github.com/rideshare-platform/shared/logger"
)

// PostgresDB represents a PostgreSQL database connection
type PostgresDB struct {
        DB     *sql.DB
        config *config.DatabaseConfig
        logger *logger.Logger
}

// NewPostgresDB creates a new PostgreSQL database connection
func NewPostgresDB(cfg *config.DatabaseConfig, log *logger.Logger) (*PostgresDB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
                cfg.Host, cfg.Port, cfg.Username, cfg.Password, cfg.Database, cfg.SSLMode)

        db, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database connection: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.MaxOpenConns)
        db.SetMaxIdleConns(cfg.MaxIdleConns)
        db.SetConnMaxLifetime(time.Duration(cfg.ConnMaxLifetime) * time.Second)
        db.SetConnMaxIdleTime(time.Duration(cfg.ConnMaxIdleTime) * time.Second)

        // Test the connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">log.WithFields(logger.Fields{
                "host":     cfg.Host,
                "port":     cfg.Port,
                "database": cfg.Database,
        }).Info("Connected to PostgreSQL database")

        return &amp;PostgresDB{
                DB:     db,
                config: cfg,
                logger: log,
        }, nil</span>
}

// Close closes the database connection
func (p *PostgresDB) Close() error <span class="cov0" title="0">{
        if p.DB != nil </span><span class="cov0" title="0">{
                p.logger.Logger.Info("Closing PostgreSQL database connection")
                return p.DB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Health checks the database health
func (p *PostgresDB) Health(ctx context.Context) error <span class="cov0" title="0">{
        return p.DB.PingContext(ctx)
}</span>

// BeginTx starts a new transaction
func (p *PostgresDB) BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) <span class="cov0" title="0">{
        return p.DB.BeginTx(ctx, opts)
}</span>

// ExecContext executes a query without returning any rows
func (p *PostgresDB) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := p.DB.ExecContext(ctx, query, args...)
        duration := time.Since(start)

        p.logger.LogDatabaseQuery(ctx, query, duration, err)
        return result, err
}</span>

// QueryContext executes a query that returns rows
func (p *PostgresDB) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        start := time.Now()
        rows, err := p.DB.QueryContext(ctx, query, args...)
        duration := time.Since(start)

        p.logger.LogDatabaseQuery(ctx, query, duration, err)
        return rows, err
}</span>

// QueryRowContext executes a query that is expected to return at most one row
func (p *PostgresDB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        start := time.Now()
        row := p.DB.QueryRowContext(ctx, query, args...)
        duration := time.Since(start)

        p.logger.LogDatabaseQuery(ctx, query, duration, nil)
        return row
}</span>

// PrepareContext creates a prepared statement for later queries or executions
func (p *PostgresDB) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        return p.DB.PrepareContext(ctx, query)
}</span>

// Stats returns database statistics
func (p *PostgresDB) Stats() sql.DBStats <span class="cov0" title="0">{
        return p.DB.Stats()
}</span>

// LogStats logs database connection pool statistics
func (p *PostgresDB) LogStats(ctx context.Context) <span class="cov0" title="0">{
        stats := p.DB.Stats()
        p.logger.WithContext(ctx).WithFields(logger.Fields{
                "max_open_connections": stats.MaxOpenConnections,
                "open_connections":     stats.OpenConnections,
                "in_use":               stats.InUse,
                "idle":                 stats.Idle,
                "wait_count":           stats.WaitCount,
                "wait_duration":        stats.WaitDuration,
                "max_idle_closed":      stats.MaxIdleClosed,
                "max_idle_time_closed": stats.MaxIdleTimeClosed,
                "max_lifetime_closed":  stats.MaxLifetimeClosed,
        }).Info("PostgreSQL connection pool stats")
}</span>

// Transaction represents a database transaction with logging
type Transaction struct {
        tx     *sql.Tx
        logger *logger.Logger
        ctx    context.Context
}

// NewTransaction creates a new transaction wrapper
func (p *PostgresDB) NewTransaction(ctx context.Context, opts *sql.TxOptions) (*Transaction, error) <span class="cov0" title="0">{
        tx, err := p.DB.BeginTx(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">p.logger.WithContext(ctx).Debug("Database transaction started")

        return &amp;Transaction{
                tx:     tx,
                logger: p.logger,
                ctx:    ctx,
        }, nil</span>
}

// Commit commits the transaction
func (t *Transaction) Commit() error <span class="cov0" title="0">{
        err := t.tx.Commit()
        if err != nil </span><span class="cov0" title="0">{
                t.logger.WithContext(t.ctx).WithError(err).Error("Failed to commit transaction")
        }</span> else<span class="cov0" title="0"> {
                t.logger.WithContext(t.ctx).Debug("Database transaction committed")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Rollback rolls back the transaction
func (t *Transaction) Rollback() error <span class="cov0" title="0">{
        err := t.tx.Rollback()
        if err != nil </span><span class="cov0" title="0">{
                t.logger.WithContext(t.ctx).WithError(err).Error("Failed to rollback transaction")
        }</span> else<span class="cov0" title="0"> {
                t.logger.WithContext(t.ctx).Debug("Database transaction rolled back")
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ExecContext executes a query within the transaction
func (t *Transaction) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        start := time.Now()
        result, err := t.tx.ExecContext(ctx, query, args...)
        duration := time.Since(start)

        t.logger.LogDatabaseQuery(ctx, query, duration, err)
        return result, err
}</span>

// QueryContext executes a query within the transaction
func (t *Transaction) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        start := time.Now()
        rows, err := t.tx.QueryContext(ctx, query, args...)
        duration := time.Since(start)

        t.logger.LogDatabaseQuery(ctx, query, duration, err)
        return rows, err
}</span>

// QueryRowContext executes a query within the transaction
func (t *Transaction) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        start := time.Now()
        row := t.tx.QueryRowContext(ctx, query, args...)
        duration := time.Since(start)

        t.logger.LogDatabaseQuery(ctx, query, duration, nil)
        return row
}</span>

// PrepareContext creates a prepared statement within the transaction
func (t *Transaction) PrepareContext(ctx context.Context, query string) (*sql.Stmt, error) <span class="cov0" title="0">{
        return t.tx.PrepareContext(ctx, query)
}</span>

// WithTransaction executes a function within a database transaction
func (p *PostgresDB) WithTransaction(ctx context.Context, opts *sql.TxOptions, fn func(*Transaction) error) error <span class="cov0" title="0">{
        tx, err := p.NewTransaction(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        panic(r)</span>
                }
        }()

        <span class="cov0" title="0">if err := fn(tx); err != nil </span><span class="cov0" title="0">{
                if rbErr := tx.Rollback(); rbErr != nil </span><span class="cov0" title="0">{
                        p.logger.WithContext(ctx).WithError(rbErr).Error("Failed to rollback transaction after error")
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return tx.Commit()</span>
}

// Repository provides common database operations
type Repository struct {
        db     *PostgresDB
        logger *logger.Logger
}

// NewRepository creates a new repository
func NewRepository(db *PostgresDB, logger *logger.Logger) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                db:     db,
                logger: logger,
        }
}</span>

// Exists checks if a record exists
func (r *Repository) Exists(ctx context.Context, table, column string, value interface{}) (bool, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT EXISTS(SELECT 1 FROM %s WHERE %s = $1)", table, column)

        var exists bool
        err := r.db.QueryRowContext(ctx, query, value).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check existence: %w", err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// Count counts records matching a condition
func (r *Repository) Count(ctx context.Context, table, whereClause string, args ...interface{}) (int64, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT COUNT(*) FROM %s", table)
        if whereClause != "" </span><span class="cov0" title="0">{
                query += " WHERE " + whereClause
        }</span>

        <span class="cov0" title="0">var count int64
        err := r.db.QueryRowContext(ctx, query, args...).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count records: %w", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}

// GetLastInsertID gets the last inserted ID (PostgreSQL specific)
func (r *Repository) GetLastInsertID(ctx context.Context, table, idColumn string) (int64, error) <span class="cov0" title="0">{
        query := fmt.Sprintf("SELECT COALESCE(MAX(%s), 0) FROM %s", idColumn, table)

        var id int64
        err := r.db.QueryRowContext(ctx, query).Scan(&amp;id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get last insert ID: %w", err)
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package database

import (
        "context"
        "fmt"
        "time"

        "github.com/go-redis/redis/v8"
        "github.com/rideshare-platform/shared/config"
        "github.com/rideshare-platform/shared/logger"
)

// RedisDB represents a Redis database connection
type RedisDB struct {
        Client *redis.Client
        config *config.RedisConfig
        logger *logger.Logger
}

// NewRedisDB creates a new Redis database connection
func NewRedisDB(cfg *config.RedisConfig, log *logger.Logger) (*RedisDB, error) <span class="cov0" title="0">{
        // Create Redis client options
        opts := &amp;redis.Options{
                Addr:         fmt.Sprintf("%s:%d", cfg.Host, cfg.Port),
                Password:     cfg.Password,
                DB:           cfg.Database,
                PoolSize:     cfg.PoolSize,
                MinIdleConns: cfg.MinIdleConns,
                DialTimeout:  cfg.DialTimeout,
                ReadTimeout:  cfg.ReadTimeout,
                WriteTimeout: cfg.WriteTimeout,
                IdleTimeout:  cfg.IdleTimeout,
        }

        // Create Redis client
        client := redis.NewClient(opts)

        // Test the connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                client.Close()
                return nil, fmt.Errorf("failed to ping Redis: %w", err)
        }</span>

        <span class="cov0" title="0">log.WithFields(logger.Fields{
                "host": cfg.Host,
                "port": cfg.Port,
                "db":   0,
        }).Info("Connected to Redis database")

        return &amp;RedisDB{
                Client: client,
                config: cfg,
                logger: log,
        }, nil</span>
}

// Close closes the Redis connection
func (r *RedisDB) Close() error <span class="cov0" title="0">{
        if r.Client != nil </span><span class="cov0" title="0">{
                r.logger.Logger.Info("Closing Redis database connection")
                return r.Client.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Health checks the Redis health
func (r *RedisDB) Health(ctx context.Context) error <span class="cov0" title="0">{
        return r.Client.Ping(ctx).Err()
}</span>

// Stats returns Redis pool statistics
func (r *RedisDB) Stats() *redis.PoolStats <span class="cov0" title="0">{
        return r.Client.PoolStats()
}</span>

// LogStats logs Redis connection pool statistics
func (r *RedisDB) LogStats(ctx context.Context) <span class="cov0" title="0">{
        stats := r.Client.PoolStats()
        r.logger.WithContext(ctx).WithFields(logger.Fields{
                "hits":        stats.Hits,
                "misses":      stats.Misses,
                "timeouts":    stats.Timeouts,
                "total_conns": stats.TotalConns,
                "idle_conns":  stats.IdleConns,
                "stale_conns": stats.StaleConns,
        }).Info("Redis connection pool stats")
}</span>

// RedisCache provides caching operations with logging
type RedisCache struct {
        client *redis.Client
        logger *logger.Logger
        prefix string
}

// NewRedisCache creates a new Redis cache instance
func NewRedisCache(db *RedisDB, prefix string, logger *logger.Logger) *RedisCache <span class="cov0" title="0">{
        return &amp;RedisCache{
                client: db.Client,
                logger: logger,
                prefix: prefix,
        }
}</span>

// key adds prefix to the key
func (c *RedisCache) key(key string) string <span class="cov0" title="0">{
        if c.prefix == "" </span><span class="cov0" title="0">{
                return key
        }</span>
        <span class="cov0" title="0">return c.prefix + ":" + key</span>
}

// Set sets a key-value pair with expiration
func (c *RedisCache) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.Set(ctx, c.key(key), value, expiration).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "SET", key, false, duration)
        return err
}</span>

// Get gets a value by key
func (c *RedisCache) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.Get(ctx, c.key(key)).Result()
        duration := time.Since(start)

        hit := err == nil
        c.logger.LogCacheOperation(ctx, "GET", key, hit, duration)

        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil // Key does not exist
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

// GetBytes gets a value as bytes by key
func (c *RedisCache) GetBytes(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.Get(ctx, c.key(key)).Bytes()
        duration := time.Since(start)

        hit := err == nil
        c.logger.LogCacheOperation(ctx, "GET_BYTES", key, hit, duration)

        if err == redis.Nil </span><span class="cov0" title="0">{
                return nil, nil // Key does not exist
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

// Del deletes keys
func (c *RedisCache) Del(ctx context.Context, keys ...string) error <span class="cov0" title="0">{
        prefixedKeys := make([]string, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                prefixedKeys[i] = c.key(key)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        err := c.client.Del(ctx, prefixedKeys...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "DEL", fmt.Sprintf("%v", keys), false, duration)
        return err</span>
}

// Exists checks if keys exist
func (c *RedisCache) Exists(ctx context.Context, keys ...string) (int64, error) <span class="cov0" title="0">{
        prefixedKeys := make([]string, len(keys))
        for i, key := range keys </span><span class="cov0" title="0">{
                prefixedKeys[i] = c.key(key)
        }</span>

        <span class="cov0" title="0">start := time.Now()
        count, err := c.client.Exists(ctx, prefixedKeys...).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "EXISTS", fmt.Sprintf("%v", keys), count &gt; 0, duration)
        return count, err</span>
}

// Expire sets expiration for a key
func (c *RedisCache) Expire(ctx context.Context, key string, expiration time.Duration) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.Expire(ctx, c.key(key), expiration).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "EXPIRE", key, false, duration)
        return err
}</span>

// TTL gets time to live for a key
func (c *RedisCache) TTL(ctx context.Context, key string) (time.Duration, error) <span class="cov0" title="0">{
        start := time.Now()
        ttl, err := c.client.TTL(ctx, c.key(key)).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "TTL", key, false, duration)
        return ttl, err
}</span>

// Incr increments a key
func (c *RedisCache) Incr(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.Incr(ctx, c.key(key)).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "INCR", key, false, duration)
        return val, err
}</span>

// IncrBy increments a key by value
func (c *RedisCache) IncrBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.IncrBy(ctx, c.key(key), value).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "INCRBY", key, false, duration)
        return val, err
}</span>

// Decr decrements a key
func (c *RedisCache) Decr(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.Decr(ctx, c.key(key)).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "DECR", key, false, duration)
        return val, err
}</span>

// DecrBy decrements a key by value
func (c *RedisCache) DecrBy(ctx context.Context, key string, value int64) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.DecrBy(ctx, c.key(key), value).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "DECRBY", key, false, duration)
        return val, err
}</span>

// HSet sets hash field
func (c *RedisCache) HSet(ctx context.Context, key string, values ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.HSet(ctx, c.key(key), values...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "HSET", key, false, duration)
        return err
}</span>

// HGet gets hash field
func (c *RedisCache) HGet(ctx context.Context, key, field string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.HGet(ctx, c.key(key), field).Result()
        duration := time.Since(start)

        hit := err == nil
        c.logger.LogCacheOperation(ctx, "HGET", key+":"+field, hit, duration)

        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil // Field does not exist
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

// HGetAll gets all hash fields
func (c *RedisCache) HGetAll(ctx context.Context, key string) (map[string]string, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.HGetAll(ctx, c.key(key)).Result()
        duration := time.Since(start)

        hit := err == nil &amp;&amp; len(val) &gt; 0
        c.logger.LogCacheOperation(ctx, "HGETALL", key, hit, duration)
        return val, err
}</span>

// HDel deletes hash fields
func (c *RedisCache) HDel(ctx context.Context, key string, fields ...string) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.HDel(ctx, c.key(key), fields...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "HDEL", key, false, duration)
        return err
}</span>

// LPush pushes elements to the left of a list
func (c *RedisCache) LPush(ctx context.Context, key string, values ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.LPush(ctx, c.key(key), values...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "LPUSH", key, false, duration)
        return err
}</span>

// RPush pushes elements to the right of a list
func (c *RedisCache) RPush(ctx context.Context, key string, values ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.RPush(ctx, c.key(key), values...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "RPUSH", key, false, duration)
        return err
}</span>

// LPop pops an element from the left of a list
func (c *RedisCache) LPop(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.LPop(ctx, c.key(key)).Result()
        duration := time.Since(start)

        hit := err == nil
        c.logger.LogCacheOperation(ctx, "LPOP", key, hit, duration)

        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil // List is empty
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

// RPop pops an element from the right of a list
func (c *RedisCache) RPop(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        start := time.Now()
        val, err := c.client.RPop(ctx, c.key(key)).Result()
        duration := time.Since(start)

        hit := err == nil
        c.logger.LogCacheOperation(ctx, "RPOP", key, hit, duration)

        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil // List is empty
        }</span>
        <span class="cov0" title="0">return val, err</span>
}

// LLen gets the length of a list
func (c *RedisCache) LLen(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        start := time.Now()
        length, err := c.client.LLen(ctx, c.key(key)).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "LLEN", key, false, duration)
        return length, err
}</span>

// SAdd adds members to a set
func (c *RedisCache) SAdd(ctx context.Context, key string, members ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.SAdd(ctx, c.key(key), members...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "SADD", key, false, duration)
        return err
}</span>

// SRem removes members from a set
func (c *RedisCache) SRem(ctx context.Context, key string, members ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.SRem(ctx, c.key(key), members...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "SREM", key, false, duration)
        return err
}</span>

// SMembers gets all members of a set
func (c *RedisCache) SMembers(ctx context.Context, key string) ([]string, error) <span class="cov0" title="0">{
        start := time.Now()
        members, err := c.client.SMembers(ctx, c.key(key)).Result()
        duration := time.Since(start)

        hit := err == nil &amp;&amp; len(members) &gt; 0
        c.logger.LogCacheOperation(ctx, "SMEMBERS", key, hit, duration)
        return members, err
}</span>

// SIsMember checks if a member exists in a set
func (c *RedisCache) SIsMember(ctx context.Context, key string, member interface{}) (bool, error) <span class="cov0" title="0">{
        start := time.Now()
        exists, err := c.client.SIsMember(ctx, c.key(key), member).Result()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "SISMEMBER", key, exists, duration)
        return exists, err
}</span>

// ZAdd adds members to a sorted set
func (c *RedisCache) ZAdd(ctx context.Context, key string, members ...*redis.Z) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.ZAdd(ctx, c.key(key), members...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "ZADD", key, false, duration)
        return err
}</span>

// ZRange gets members from a sorted set by range
func (c *RedisCache) ZRange(ctx context.Context, key string, start, stop int64) ([]string, error) <span class="cov0" title="0">{
        startTime := time.Now()
        members, err := c.client.ZRange(ctx, c.key(key), start, stop).Result()
        duration := time.Since(startTime)

        hit := err == nil &amp;&amp; len(members) &gt; 0
        c.logger.LogCacheOperation(ctx, "ZRANGE", key, hit, duration)
        return members, err
}</span>

// ZRangeByScore gets members from a sorted set by score range
func (c *RedisCache) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) ([]string, error) <span class="cov0" title="0">{
        start := time.Now()
        members, err := c.client.ZRangeByScore(ctx, c.key(key), opt).Result()
        duration := time.Since(start)

        hit := err == nil &amp;&amp; len(members) &gt; 0
        c.logger.LogCacheOperation(ctx, "ZRANGEBYSCORE", key, hit, duration)
        return members, err
}</span>

// ZRem removes members from a sorted set
func (c *RedisCache) ZRem(ctx context.Context, key string, members ...interface{}) error <span class="cov0" title="0">{
        start := time.Now()
        err := c.client.ZRem(ctx, c.key(key), members...).Err()
        duration := time.Since(start)

        c.logger.LogCacheOperation(ctx, "ZREM", key, false, duration)
        return err
}</span>

// Pipeline creates a Redis pipeline
func (c *RedisCache) Pipeline() redis.Pipeliner <span class="cov0" title="0">{
        return c.client.Pipeline()
}</span>

// TxPipeline creates a Redis transaction pipeline
func (c *RedisCache) TxPipeline() redis.Pipeliner <span class="cov0" title="0">{
        return c.client.TxPipeline()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package events

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/rideshare-platform/shared/logger"
)

// EventType represents the type of event
type EventType string

const (
        // User events
        UserRegisteredEvent  EventType = "user.registered"
        UserUpdatedEvent     EventType = "user.updated"
        UserDeactivatedEvent EventType = "user.deactivated"

        // Driver events
        DriverOnlineEvent     EventType = "driver.online"
        DriverOfflineEvent    EventType = "driver.offline"
        DriverLocationUpdated EventType = "driver.location_updated"

        // Trip events
        TripRequestedEvent EventType = "trip.requested"
        TripMatchedEvent   EventType = "trip.matched"
        TripStartedEvent   EventType = "trip.started"
        TripCompletedEvent EventType = "trip.completed"
        TripCancelledEvent EventType = "trip.cancelled"

        // Payment events
        PaymentProcessedEvent EventType = "payment.processed"
        PaymentFailedEvent    EventType = "payment.failed"
        PaymentRefundedEvent  EventType = "payment.refunded"

        // Vehicle events
        VehicleRegisteredEvent  EventType = "vehicle.registered"
        VehicleUpdatedEvent     EventType = "vehicle.updated"
        VehicleDeactivatedEvent EventType = "vehicle.deactivated"
)

// Event represents a domain event
type Event struct {
        ID          string                 `json:"id"`
        Type        EventType              `json:"type"`
        AggregateID string                 `json:"aggregate_id"`
        Version     int                    `json:"version"`
        Data        map[string]interface{} `json:"data"`
        Metadata    map[string]interface{} `json:"metadata"`
        Timestamp   time.Time              `json:"timestamp"`
        Source      string                 `json:"source"`
}

// NewEvent creates a new event
func NewEvent(eventType EventType, aggregateID string, version int, data map[string]interface{}, source string) *Event <span class="cov0" title="0">{
        return &amp;Event{
                ID:          generateEventID(),
                Type:        eventType,
                AggregateID: aggregateID,
                Version:     version,
                Data:        data,
                Metadata:    make(map[string]interface{}),
                Timestamp:   time.Now().UTC(),
                Source:      source,
        }
}</span>

// AddMetadata adds metadata to the event
func (e *Event) AddMetadata(key string, value interface{}) <span class="cov0" title="0">{
        if e.Metadata == nil </span><span class="cov0" title="0">{
                e.Metadata = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">e.Metadata[key] = value</span>
}

// ToJSON converts the event to JSON
func (e *Event) ToJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(e)
}</span>

// FromJSON creates an event from JSON
func FromJSON(data []byte) (*Event, error) <span class="cov0" title="0">{
        var event Event
        if err := json.Unmarshal(data, &amp;event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal event: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;event, nil</span>
}

// EventHandler represents an event handler function
type EventHandler func(ctx context.Context, event *Event) error

// EventBus represents an event bus for publishing and subscribing to events
type EventBus interface {
        Publish(ctx context.Context, event *Event) error
        Subscribe(eventType EventType, handler EventHandler) error
        Unsubscribe(eventType EventType, handler EventHandler) error
        Close() error
}

// InMemoryEventBus is a simple in-memory event bus implementation
type InMemoryEventBus struct {
        handlers map[EventType][]EventHandler
        logger   *logger.Logger
}

// NewInMemoryEventBus creates a new in-memory event bus
func NewInMemoryEventBus(log *logger.Logger) *InMemoryEventBus <span class="cov0" title="0">{
        return &amp;InMemoryEventBus{
                handlers: make(map[EventType][]EventHandler),
                logger:   log,
        }
}</span>

// Publish publishes an event to all subscribers
func (bus *InMemoryEventBus) Publish(ctx context.Context, event *Event) error <span class="cov0" title="0">{
        handlers, exists := bus.handlers[event.Type]
        if !exists </span><span class="cov0" title="0">{
                bus.logger.WithContext(ctx).WithFields(logger.Fields{
                        "event_type": event.Type,
                        "event_id":   event.ID,
                }).Debug("No handlers registered for event type")
                return nil
        }</span>

        <span class="cov0" title="0">bus.logger.WithContext(ctx).WithFields(logger.Fields{
                "event_type":    event.Type,
                "event_id":      event.ID,
                "aggregate_id":  event.AggregateID,
                "handler_count": len(handlers),
        }).Info("Publishing event")

        // Execute handlers concurrently
        for _, handler := range handlers </span><span class="cov0" title="0">{
                go func(h EventHandler) </span><span class="cov0" title="0">{
                        if err := h(ctx, event); err != nil </span><span class="cov0" title="0">{
                                bus.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                                        "event_type": event.Type,
                                        "event_id":   event.ID,
                                }).Error("Event handler failed")
                        }</span>
                }(handler)
        }

        <span class="cov0" title="0">return nil</span>
}

// Subscribe subscribes to events of a specific type
func (bus *InMemoryEventBus) Subscribe(eventType EventType, handler EventHandler) error <span class="cov0" title="0">{
        bus.handlers[eventType] = append(bus.handlers[eventType], handler)

        bus.logger.WithFields(logger.Fields{
                "event_type":    eventType,
                "handler_count": len(bus.handlers[eventType]),
        }).Info("Event handler subscribed")

        return nil
}</span>

// Unsubscribe removes a handler from event subscriptions
func (bus *InMemoryEventBus) Unsubscribe(eventType EventType, handler EventHandler) error <span class="cov0" title="0">{
        handlers, exists := bus.handlers[eventType]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Remove handler (simple implementation - in production, use proper handler identification)
        <span class="cov0" title="0">for i, h := range handlers </span><span class="cov0" title="0">{
                if &amp;h == &amp;handler </span><span class="cov0" title="0">{
                        bus.handlers[eventType] = append(handlers[:i], handlers[i+1:]...)
                        break</span>
                }
        }

        <span class="cov0" title="0">bus.logger.WithFields(logger.Fields{
                "event_type":    eventType,
                "handler_count": len(bus.handlers[eventType]),
        }).Info("Event handler unsubscribed")

        return nil</span>
}

// Close closes the event bus
func (bus *InMemoryEventBus) Close() error <span class="cov0" title="0">{
        bus.handlers = make(map[EventType][]EventHandler)
        bus.logger.Logger.Info("Event bus closed")
        return nil
}</span>

// EventStore represents an event store for persisting events
type EventStore interface {
        SaveEvent(ctx context.Context, event *Event) error
        GetEvents(ctx context.Context, aggregateID string) ([]*Event, error)
        GetEventsByType(ctx context.Context, eventType EventType, limit int) ([]*Event, error)
        GetEventsAfter(ctx context.Context, timestamp time.Time, limit int) ([]*Event, error)
}

// InMemoryEventStore is a simple in-memory event store implementation
type InMemoryEventStore struct {
        events []Event
        logger *logger.Logger
}

// NewInMemoryEventStore creates a new in-memory event store
func NewInMemoryEventStore(log *logger.Logger) *InMemoryEventStore <span class="cov0" title="0">{
        return &amp;InMemoryEventStore{
                events: make([]Event, 0),
                logger: log,
        }
}</span>

// SaveEvent saves an event to the store
func (store *InMemoryEventStore) SaveEvent(ctx context.Context, event *Event) error <span class="cov0" title="0">{
        store.events = append(store.events, *event)

        store.logger.WithContext(ctx).WithFields(logger.Fields{
                "event_type":   event.Type,
                "event_id":     event.ID,
                "aggregate_id": event.AggregateID,
                "version":      event.Version,
        }).Debug("Event saved to store")

        return nil
}</span>

// GetEvents retrieves all events for an aggregate
func (store *InMemoryEventStore) GetEvents(ctx context.Context, aggregateID string) ([]*Event, error) <span class="cov0" title="0">{
        var events []*Event

        for _, event := range store.events </span><span class="cov0" title="0">{
                if event.AggregateID == aggregateID </span><span class="cov0" title="0">{
                        events = append(events, &amp;event)
                }</span>
        }

        <span class="cov0" title="0">store.logger.WithContext(ctx).WithFields(logger.Fields{
                "aggregate_id": aggregateID,
                "event_count":  len(events),
        }).Debug("Retrieved events for aggregate")

        return events, nil</span>
}

// GetEventsByType retrieves events by type
func (store *InMemoryEventStore) GetEventsByType(ctx context.Context, eventType EventType, limit int) ([]*Event, error) <span class="cov0" title="0">{
        var events []*Event
        count := 0

        for i := len(store.events) - 1; i &gt;= 0 &amp;&amp; count &lt; limit; i-- </span><span class="cov0" title="0">{
                if store.events[i].Type == eventType </span><span class="cov0" title="0">{
                        events = append(events, &amp;store.events[i])
                        count++
                }</span>
        }

        <span class="cov0" title="0">store.logger.WithContext(ctx).WithFields(logger.Fields{
                "event_type":  eventType,
                "event_count": len(events),
                "limit":       limit,
        }).Debug("Retrieved events by type")

        return events, nil</span>
}

// GetEventsAfter retrieves events after a specific timestamp
func (store *InMemoryEventStore) GetEventsAfter(ctx context.Context, timestamp time.Time, limit int) ([]*Event, error) <span class="cov0" title="0">{
        var events []*Event
        count := 0

        for i := len(store.events) - 1; i &gt;= 0 &amp;&amp; count &lt; limit; i-- </span><span class="cov0" title="0">{
                if store.events[i].Timestamp.After(timestamp) </span><span class="cov0" title="0">{
                        events = append(events, &amp;store.events[i])
                        count++
                }</span>
        }

        <span class="cov0" title="0">store.logger.WithContext(ctx).WithFields(logger.Fields{
                "after":       timestamp,
                "event_count": len(events),
                "limit":       limit,
        }).Debug("Retrieved events after timestamp")

        return events, nil</span>
}

// EventPublisher combines event bus and event store
type EventPublisher struct {
        bus    EventBus
        store  EventStore
        logger *logger.Logger
}

// NewEventPublisher creates a new event publisher
func NewEventPublisher(bus EventBus, store EventStore, log *logger.Logger) *EventPublisher <span class="cov0" title="0">{
        return &amp;EventPublisher{
                bus:    bus,
                store:  store,
                logger: log,
        }
}</span>

// PublishEvent publishes an event to both the bus and store
func (pub *EventPublisher) PublishEvent(ctx context.Context, event *Event) error <span class="cov0" title="0">{
        // Save to store first
        if err := pub.store.SaveEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                pub.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "event_type": event.Type,
                        "event_id":   event.ID,
                }).Error("Failed to save event to store")
                return fmt.Errorf("failed to save event: %w", err)
        }</span>

        // Then publish to bus
        <span class="cov0" title="0">if err := pub.bus.Publish(ctx, event); err != nil </span><span class="cov0" title="0">{
                pub.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "event_type": event.Type,
                        "event_id":   event.ID,
                }).Error("Failed to publish event to bus")
                return fmt.Errorf("failed to publish event: %w", err)
        }</span>

        <span class="cov0" title="0">pub.logger.WithContext(ctx).WithFields(logger.Fields{
                "event_type":   event.Type,
                "event_id":     event.ID,
                "aggregate_id": event.AggregateID,
        }).Info("Event published successfully")

        return nil</span>
}

// Subscribe subscribes to events
func (pub *EventPublisher) Subscribe(eventType EventType, handler EventHandler) error <span class="cov0" title="0">{
        return pub.bus.Subscribe(eventType, handler)
}</span>

// GetEvents retrieves events from store
func (pub *EventPublisher) GetEvents(ctx context.Context, aggregateID string) ([]*Event, error) <span class="cov0" title="0">{
        return pub.store.GetEvents(ctx, aggregateID)
}</span>

// Close closes the publisher
func (pub *EventPublisher) Close() error <span class="cov0" title="0">{
        return pub.bus.Close()
}</span>

// generateEventID generates a unique event ID
func generateEventID() string <span class="cov0" title="0">{
        // Simple implementation - in production, use proper UUID generation
        return fmt.Sprintf("event_%d", time.Now().UnixNano())
}</span>

// EventHandlerRegistry manages event handlers
type EventHandlerRegistry struct {
        handlers map[EventType][]EventHandler
        logger   *logger.Logger
}

// NewEventHandlerRegistry creates a new event handler registry
func NewEventHandlerRegistry(log *logger.Logger) *EventHandlerRegistry <span class="cov0" title="0">{
        return &amp;EventHandlerRegistry{
                handlers: make(map[EventType][]EventHandler),
                logger:   log,
        }
}</span>

// Register registers an event handler
func (registry *EventHandlerRegistry) Register(eventType EventType, handler EventHandler) <span class="cov0" title="0">{
        registry.handlers[eventType] = append(registry.handlers[eventType], handler)

        registry.logger.WithFields(logger.Fields{
                "event_type":    eventType,
                "handler_count": len(registry.handlers[eventType]),
        }).Info("Event handler registered")
}</span>

// GetHandlers returns handlers for an event type
func (registry *EventHandlerRegistry) GetHandlers(eventType EventType) []EventHandler <span class="cov0" title="0">{
        return registry.handlers[eventType]
}</span>

// Clear clears all handlers
func (registry *EventHandlerRegistry) Clear() <span class="cov0" title="0">{
        registry.handlers = make(map[EventType][]EventHandler)
        registry.logger.Logger.Info("Event handler registry cleared")
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package grpc

import (
        "context"
        "fmt"
        "time"

        "github.com/rideshare-platform/shared/logger"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/grpc/keepalive"
)

// ClientConfig holds gRPC client configuration
type ClientConfig struct {
        Address             string
        Timeout             time.Duration
        MaxRecvMsgSize      int
        MaxSendMsgSize      int
        KeepAliveTime       time.Duration
        KeepAliveTimeout    time.Duration
        PermitWithoutStream bool
        MaxRetryAttempts    int
        InitialBackoff      time.Duration
        MaxBackoff          time.Duration
        BackoffMultiplier   float64
}

// DefaultClientConfig returns default client configuration
func DefaultClientConfig(address string) *ClientConfig <span class="cov0" title="0">{
        return &amp;ClientConfig{
                Address:             address,
                Timeout:             30 * time.Second,
                MaxRecvMsgSize:      4 * 1024 * 1024, // 4MB
                MaxSendMsgSize:      4 * 1024 * 1024, // 4MB
                KeepAliveTime:       30 * time.Second,
                KeepAliveTimeout:    5 * time.Second,
                PermitWithoutStream: true,
                MaxRetryAttempts:    3,
                InitialBackoff:      100 * time.Millisecond,
                MaxBackoff:          30 * time.Second,
                BackoffMultiplier:   1.6,
        }
}</span>

// Client wraps gRPC client connection with additional functionality
type Client struct {
        conn   *grpc.ClientConn
        config *ClientConfig
        logger *logger.Logger
}

// NewClient creates a new gRPC client
func NewClient(config *ClientConfig, log *logger.Logger) (*Client, error) <span class="cov0" title="0">{
        // Client options
        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
                grpc.WithDefaultCallOptions(
                        grpc.MaxCallRecvMsgSize(config.MaxRecvMsgSize),
                        grpc.MaxCallSendMsgSize(config.MaxSendMsgSize),
                ),
                grpc.WithKeepaliveParams(keepalive.ClientParameters{
                        Time:                config.KeepAliveTime,
                        Timeout:             config.KeepAliveTimeout,
                        PermitWithoutStream: config.PermitWithoutStream,
                }),
                grpc.WithUnaryInterceptor(unaryClientInterceptor(log)),
                grpc.WithStreamInterceptor(streamClientInterceptor(log)),
        }

        // Establish connection
        conn, err := grpc.Dial(config.Address, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to %s: %w", config.Address, err)
        }</span>

        <span class="cov0" title="0">log.WithFields(logger.Fields{
                "address": config.Address,
        }).Info("gRPC client connected")

        return &amp;Client{
                conn:   conn,
                config: config,
                logger: log,
        }, nil</span>
}

// GetConnection returns the underlying gRPC connection
func (c *Client) GetConnection() *grpc.ClientConn <span class="cov0" title="0">{
        return c.conn
}</span>

// Close closes the client connection
func (c *Client) Close() error <span class="cov0" title="0">{
        c.logger.WithFields(logger.Fields{
                "address": c.config.Address,
        }).Info("Closing gRPC client connection")
        return c.conn.Close()
}</span>

// Health checks the connection health
func (c *Client) Health(ctx context.Context) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        state := c.conn.GetState()
        c.logger.WithFields(logger.Fields{
                "address": c.config.Address,
                "state":   state.String(),
        }).Debug("gRPC connection state")

        // Wait for connection to be ready
        if !c.conn.WaitForStateChange(ctx, state) </span><span class="cov0" title="0">{
                return fmt.Errorf("connection not ready: %s", state)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// unaryClientInterceptor provides logging and metrics for unary RPCs
func unaryClientInterceptor(log *logger.Logger) grpc.UnaryClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error </span><span class="cov0" title="0">{
                start := time.Now()

                // Call the method
                err := invoker(ctx, method, req, reply, cc, opts...)

                // Calculate duration
                duration := time.Since(start)

                // Log the request
                log.LogGRPCRequest(ctx, method, duration, err)

                return err
        }</span>
}

// streamClientInterceptor provides logging and metrics for streaming RPCs
func streamClientInterceptor(log *logger.Logger) grpc.StreamClientInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) </span><span class="cov0" title="0">{
                start := time.Now()

                // Call the method
                stream, err := streamer(ctx, desc, cc, method, opts...)

                // Calculate duration
                duration := time.Since(start)

                // Log the request
                log.LogGRPCRequest(ctx, method, duration, err)

                return stream, err
        }</span>
}

// ClientManager manages multiple gRPC clients
type ClientManager struct {
        clients map[string]*Client
        logger  *logger.Logger
}

// NewClientManager creates a new client manager
func NewClientManager(log *logger.Logger) *ClientManager <span class="cov0" title="0">{
        return &amp;ClientManager{
                clients: make(map[string]*Client),
                logger:  log,
        }
}</span>

// AddClient adds a client to the manager
func (cm *ClientManager) AddClient(name string, client *Client) <span class="cov0" title="0">{
        cm.clients[name] = client
        cm.logger.WithFields(logger.Fields{
                "client":  name,
                "address": client.config.Address,
        }).Info("Client added to manager")
}</span>

// GetClient gets a client by name
func (cm *ClientManager) GetClient(name string) (*Client, bool) <span class="cov0" title="0">{
        client, exists := cm.clients[name]
        return client, exists
}</span>

// CloseAll closes all clients
func (cm *ClientManager) CloseAll() error <span class="cov0" title="0">{
        for name, client := range cm.clients </span><span class="cov0" title="0">{
                cm.logger.WithFields(logger.Fields{
                        "client": name,
                }).Info("Closing client")
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        cm.logger.WithError(err).WithFields(logger.Fields{
                                "client": name,
                        }).Error("Failed to close client")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// HealthCheckAll checks health of all clients
func (cm *ClientManager) HealthCheckAll(ctx context.Context) map[string]error <span class="cov0" title="0">{
        results := make(map[string]error)

        for name, client := range cm.clients </span><span class="cov0" title="0">{
                if err := client.Health(ctx); err != nil </span><span class="cov0" title="0">{
                        results[name] = err
                        cm.logger.WithError(err).WithFields(logger.Fields{
                                "client": name,
                        }).Warn("Client health check failed")
                }</span> else<span class="cov0" title="0"> {
                        cm.logger.WithFields(logger.Fields{
                                "client": name,
                        }).Debug("Client health check passed")
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

// RetryableClient provides retry functionality for gRPC calls
type RetryableClient struct {
        client *Client
        config *ClientConfig
        logger *logger.Logger
}

// NewRetryableClient creates a new retryable client
func NewRetryableClient(client *Client, log *logger.Logger) *RetryableClient <span class="cov0" title="0">{
        return &amp;RetryableClient{
                client: client,
                config: client.config,
                logger: log,
        }
}</span>

// CallWithRetry executes a gRPC call with retry logic
func (rc *RetryableClient) CallWithRetry(ctx context.Context, call func() error) error <span class="cov0" title="0">{
        var lastErr error
        backoff := rc.config.InitialBackoff

        for attempt := 0; attempt &lt; rc.config.MaxRetryAttempts; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        // Wait before retry
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(backoff):<span class="cov0" title="0"></span>
                        }

                        // Increase backoff
                        <span class="cov0" title="0">backoff = time.Duration(float64(backoff) * rc.config.BackoffMultiplier)
                        if backoff &gt; rc.config.MaxBackoff </span><span class="cov0" title="0">{
                                backoff = rc.config.MaxBackoff
                        }</span>
                }

                // Execute the call
                <span class="cov0" title="0">err := call()
                if err == nil </span><span class="cov0" title="0">{
                        if attempt &gt; 0 </span><span class="cov0" title="0">{
                                rc.logger.WithContext(ctx).WithFields(logger.Fields{
                                        "attempt": attempt + 1,
                                }).Info("gRPC call succeeded after retry")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">lastErr = err

                // Check if error is retryable
                if !isRetryableError(err) </span><span class="cov0" title="0">{
                        rc.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                                "attempt": attempt + 1,
                        }).Warn("gRPC call failed with non-retryable error")
                        return err
                }</span>

                <span class="cov0" title="0">rc.logger.WithContext(ctx).WithError(err).WithFields(logger.Fields{
                        "attempt": attempt + 1,
                        "backoff": backoff,
                }).Warn("gRPC call failed, retrying")</span>
        }

        <span class="cov0" title="0">rc.logger.WithContext(ctx).WithError(lastErr).WithFields(logger.Fields{
                "max_attempts": rc.config.MaxRetryAttempts,
        }).Error("gRPC call failed after all retry attempts")

        return fmt.Errorf("call failed after %d attempts: %w", rc.config.MaxRetryAttempts, lastErr)</span>
}

// isRetryableError determines if an error is retryable
func isRetryableError(err error) bool <span class="cov0" title="0">{
        // Implement based on gRPC status codes
        // For now, assume all errors are retryable except context errors
        if err == context.Canceled || err == context.DeadlineExceeded </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// LoadBalancer provides simple load balancing for multiple clients
type LoadBalancer struct {
        clients []*Client
        current int
        logger  *logger.Logger
}

// NewLoadBalancer creates a new load balancer
func NewLoadBalancer(clients []*Client, log *logger.Logger) *LoadBalancer <span class="cov0" title="0">{
        return &amp;LoadBalancer{
                clients: clients,
                current: 0,
                logger:  log,
        }
}</span>

// GetClient returns the next client using round-robin
func (lb *LoadBalancer) GetClient() *Client <span class="cov0" title="0">{
        if len(lb.clients) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">client := lb.clients[lb.current]
        lb.current = (lb.current + 1) % len(lb.clients)

        lb.logger.WithFields(logger.Fields{
                "client_index":  lb.current,
                "total_clients": len(lb.clients),
        }).Debug("Selected client for load balancing")

        return client</span>
}

// AddClient adds a client to the load balancer
func (lb *LoadBalancer) AddClient(client *Client) <span class="cov0" title="0">{
        lb.clients = append(lb.clients, client)
        lb.logger.WithFields(logger.Fields{
                "total_clients": len(lb.clients),
        }).Info("Client added to load balancer")
}</span>

// RemoveClient removes a client from the load balancer
func (lb *LoadBalancer) RemoveClient(client *Client) <span class="cov0" title="0">{
        for i, c := range lb.clients </span><span class="cov0" title="0">{
                if c == client </span><span class="cov0" title="0">{
                        lb.clients = append(lb.clients[:i], lb.clients[i+1:]...)
                        if lb.current &gt;= len(lb.clients) </span><span class="cov0" title="0">{
                                lb.current = 0
                        }</span>
                        <span class="cov0" title="0">lb.logger.WithFields(logger.Fields{
                                "total_clients": len(lb.clients),
                        }).Info("Client removed from load balancer")
                        break</span>
                }
        }
}

// CloseAll closes all clients in the load balancer
func (lb *LoadBalancer) CloseAll() error <span class="cov0" title="0">{
        for _, client := range lb.clients </span><span class="cov0" title="0">{
                if err := client.Close(); err != nil </span><span class="cov0" title="0">{
                        lb.logger.WithError(err).Error("Failed to close client in load balancer")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CircuitBreaker provides circuit breaker functionality
type CircuitBreaker struct {
        client           *Client
        failureThreshold int
        resetTimeout     time.Duration
        failures         int
        lastFailureTime  time.Time
        state            string // "closed", "open", "half-open"
        logger           *logger.Logger
}

// NewCircuitBreaker creates a new circuit breaker
func NewCircuitBreaker(client *Client, failureThreshold int, resetTimeout time.Duration, log *logger.Logger) *CircuitBreaker <span class="cov0" title="0">{
        return &amp;CircuitBreaker{
                client:           client,
                failureThreshold: failureThreshold,
                resetTimeout:     resetTimeout,
                failures:         0,
                state:            "closed",
                logger:           log,
        }
}</span>

// Call executes a call through the circuit breaker
func (cb *CircuitBreaker) Call(ctx context.Context, call func() error) error <span class="cov0" title="0">{
        // Check circuit state
        if cb.state == "open" </span><span class="cov0" title="0">{
                if time.Since(cb.lastFailureTime) &gt; cb.resetTimeout </span><span class="cov0" title="0">{
                        cb.state = "half-open"
                        cb.logger.WithContext(ctx).Info("Circuit breaker state changed to half-open")
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("circuit breaker is open")
                }</span>
        }

        // Execute the call
        <span class="cov0" title="0">err := call()

        if err != nil </span><span class="cov0" title="0">{
                cb.failures++
                cb.lastFailureTime = time.Now()

                if cb.failures &gt;= cb.failureThreshold </span><span class="cov0" title="0">{
                        cb.state = "open"
                        cb.logger.WithContext(ctx).WithFields(logger.Fields{
                                "failures":  cb.failures,
                                "threshold": cb.failureThreshold,
                        }).Warn("Circuit breaker opened")
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        // Success - reset circuit breaker
        <span class="cov0" title="0">if cb.state == "half-open" </span><span class="cov0" title="0">{
                cb.state = "closed"
                cb.logger.WithContext(ctx).Info("Circuit breaker state changed to closed")
        }</span>
        <span class="cov0" title="0">cb.failures = 0

        return nil</span>
}

// GetState returns the current circuit breaker state
func (cb *CircuitBreaker) GetState() string <span class="cov0" title="0">{
        return cb.state
}</span>

// Reset resets the circuit breaker
func (cb *CircuitBreaker) Reset() <span class="cov0" title="0">{
        cb.failures = 0
        cb.state = "closed"
        cb.logger.Logger.Info("Circuit breaker reset")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package grpc

import (
        "context"
        "fmt"
        "net"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/keepalive"
        "google.golang.org/grpc/reflection"
        "google.golang.org/grpc/status"
        "github.com/rideshare-platform/shared/logger"
)

// ServerConfig holds gRPC server configuration
type ServerConfig struct {
        Port                int
        MaxRecvMsgSize      int
        MaxSendMsgSize      int
        ConnectionTimeout   time.Duration
        MaxConnectionIdle   time.Duration
        MaxConnectionAge    time.Duration
        MaxConnectionAgeGrace time.Duration
        Time                time.Duration
        Timeout             time.Duration
}

// DefaultServerConfig returns default server configuration
func DefaultServerConfig() *ServerConfig <span class="cov0" title="0">{
        return &amp;ServerConfig{
                Port:                  50051,
                MaxRecvMsgSize:        4 * 1024 * 1024, // 4MB
                MaxSendMsgSize:        4 * 1024 * 1024, // 4MB
                ConnectionTimeout:     5 * time.Second,
                MaxConnectionIdle:     15 * time.Second,
                MaxConnectionAge:      30 * time.Second,
                MaxConnectionAgeGrace: 5 * time.Second,
                Time:                  5 * time.Second,
                Timeout:               1 * time.Second,
        }
}</span>

// Server wraps gRPC server with additional functionality
type Server struct {
        server *grpc.Server
        config *ServerConfig
        logger *logger.Logger
}

// NewServer creates a new gRPC server
func NewServer(config *ServerConfig, log *logger.Logger) *Server <span class="cov0" title="0">{
        // Server options
        opts := []grpc.ServerOption{
                grpc.MaxRecvMsgSize(config.MaxRecvMsgSize),
                grpc.MaxSendMsgSize(config.MaxSendMsgSize),
                grpc.ConnectionTimeout(config.ConnectionTimeout),
                grpc.KeepaliveParams(keepalive.ServerParameters{
                        MaxConnectionIdle:     config.MaxConnectionIdle,
                        MaxConnectionAge:      config.MaxConnectionAge,
                        MaxConnectionAgeGrace: config.MaxConnectionAgeGrace,
                        Time:                  config.Time,
                        Timeout:               config.Timeout,
                }),
                grpc.KeepaliveEnforcementPolicy(keepalive.EnforcementPolicy{
                        MinTime:             5 * time.Second,
                        PermitWithoutStream: true,
                }),
                grpc.UnaryInterceptor(unaryServerInterceptor(log)),
                grpc.StreamInterceptor(streamServerInterceptor(log)),
        }

        server := grpc.NewServer(opts...)
        
        // Enable reflection for development
        reflection.Register(server)

        return &amp;Server{
                server: server,
                config: config,
                logger: log,
        }
}</span>

// GetServer returns the underlying gRPC server
func (s *Server) GetServer() *grpc.Server <span class="cov0" title="0">{
        return s.server
}</span>

// Start starts the gRPC server
func (s *Server) Start() error <span class="cov0" title="0">{
        lis, err := net.Listen("tcp", fmt.Sprintf(":%d", s.config.Port))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to listen on port %d: %w", s.config.Port, err)
        }</span>

        <span class="cov0" title="0">s.logger.WithFields(logger.Fields{
                "port": s.config.Port,
        }).Info("Starting gRPC server")

        if err := s.server.Serve(lis); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serve gRPC server: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the gRPC server gracefully
func (s *Server) Stop() <span class="cov0" title="0">{
        s.logger.Logger.Info("Stopping gRPC server")
        s.server.GracefulStop()
}</span>

// ForceStop stops the gRPC server immediately
func (s *Server) ForceStop() <span class="cov0" title="0">{
        s.logger.Logger.Info("Force stopping gRPC server")
        s.server.Stop()
}</span>

// unaryServerInterceptor provides logging and metrics for unary RPCs
func unaryServerInterceptor(log *logger.Logger) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) </span><span class="cov0" title="0">{
                start := time.Now()

                // Call the handler
                resp, err := handler(ctx, req)

                // Calculate duration
                duration := time.Since(start)

                // Log the request
                log.LogGRPCRequest(ctx, info.FullMethod, duration, err)

                return resp, err
        }</span>
}

// streamServerInterceptor provides logging and metrics for streaming RPCs
func streamServerInterceptor(log *logger.Logger) grpc.StreamServerInterceptor <span class="cov0" title="0">{
        return func(srv interface{}, stream grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error </span><span class="cov0" title="0">{
                start := time.Now()

                // Call the handler
                err := handler(srv, stream)

                // Calculate duration
                duration := time.Since(start)

                // Log the request
                log.LogGRPCRequest(stream.Context(), info.FullMethod, duration, err)

                return err
        }</span>
}

// HealthServer implements gRPC health checking
type HealthServer struct {
        logger *logger.Logger
}

// NewHealthServer creates a new health server
func NewHealthServer(log *logger.Logger) *HealthServer <span class="cov0" title="0">{
        return &amp;HealthServer{
                logger: log,
        }
}</span>

// Check implements the health check
func (h *HealthServer) Check(ctx context.Context, req interface{}) (interface{}, error) <span class="cov0" title="0">{
        h.logger.WithContext(ctx).Debug("Health check requested")
        
        // Simple health check - in production, check dependencies
        return map[string]string{
                "status": "SERVING",
        }, nil
}</span>

// Watch implements the health watch (streaming)
func (h *HealthServer) Watch(req interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        h.logger.WithContext(stream.Context()).Debug("Health watch requested")
        
        // Send periodic health updates
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-stream.Context().Done():<span class="cov0" title="0">
                        return stream.Context().Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Send health status
                        // In a real implementation, you would send proper health status messages
                        h.logger.WithContext(stream.Context()).Debug("Sending health status")</span>
                }
        }
}

// ErrorHandler provides standardized error handling
type ErrorHandler struct {
        logger *logger.Logger
}

// NewErrorHandler creates a new error handler
func NewErrorHandler(log *logger.Logger) *ErrorHandler <span class="cov0" title="0">{
        return &amp;ErrorHandler{
                logger: log,
        }
}</span>

// HandleError converts application errors to gRPC errors
func (eh *ErrorHandler) HandleError(ctx context.Context, err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">eh.logger.WithContext(ctx).WithError(err).Error("gRPC error occurred")

        // Convert to appropriate gRPC status
        switch </span>{
        case isNotFoundError(err):<span class="cov0" title="0">
                return status.Error(codes.NotFound, err.Error())</span>
        case isValidationError(err):<span class="cov0" title="0">
                return status.Error(codes.InvalidArgument, err.Error())</span>
        case isUnauthorizedError(err):<span class="cov0" title="0">
                return status.Error(codes.Unauthenticated, err.Error())</span>
        case isForbiddenError(err):<span class="cov0" title="0">
                return status.Error(codes.PermissionDenied, err.Error())</span>
        case isConflictError(err):<span class="cov0" title="0">
                return status.Error(codes.AlreadyExists, err.Error())</span>
        case isTimeoutError(err):<span class="cov0" title="0">
                return status.Error(codes.DeadlineExceeded, err.Error())</span>
        default:<span class="cov0" title="0">
                return status.Error(codes.Internal, "Internal server error")</span>
        }
}

// Helper functions to identify error types
func isNotFoundError(err error) bool <span class="cov0" title="0">{
        // Implement based on your error types
        return false
}</span>

func isValidationError(err error) bool <span class="cov0" title="0">{
        // Implement based on your error types
        return false
}</span>

func isUnauthorizedError(err error) bool <span class="cov0" title="0">{
        // Implement based on your error types
        return false
}</span>

func isForbiddenError(err error) bool <span class="cov0" title="0">{
        // Implement based on your error types
        return false
}</span>

func isConflictError(err error) bool <span class="cov0" title="0">{
        // Implement based on your error types
        return false
}</span>

func isTimeoutError(err error) bool <span class="cov0" title="0">{
        // Implement based on your error types
        return false
}</span>

// ServiceRegistry manages service registration and discovery
type ServiceRegistry struct {
        services map[string]string // service name -&gt; address
        logger   *logger.Logger
}

// NewServiceRegistry creates a new service registry
func NewServiceRegistry(log *logger.Logger) *ServiceRegistry <span class="cov0" title="0">{
        return &amp;ServiceRegistry{
                services: make(map[string]string),
                logger:   log,
        }
}</span>

// Register registers a service
func (sr *ServiceRegistry) Register(serviceName, address string) <span class="cov0" title="0">{
        sr.services[serviceName] = address
        sr.logger.WithFields(logger.Fields{
                "service": serviceName,
                "address": address,
        }).Info("Service registered")
}</span>

// Discover discovers a service address
func (sr *ServiceRegistry) Discover(serviceName string) (string, bool) <span class="cov0" title="0">{
        address, exists := sr.services[serviceName]
        if exists </span><span class="cov0" title="0">{
                sr.logger.WithFields(logger.Fields{
                        "service": serviceName,
                        "address": address,
                }).Debug("Service discovered")
        }</span> else<span class="cov0" title="0"> {
                sr.logger.WithFields(logger.Fields{
                        "service": serviceName,
                }).Warn("Service not found")
        }</span>
        <span class="cov0" title="0">return address, exists</span>
}

// Unregister unregisters a service
func (sr *ServiceRegistry) Unregister(serviceName string) <span class="cov0" title="0">{
        delete(sr.services, serviceName)
        sr.logger.WithFields(logger.Fields{
                "service": serviceName,
        }).Info("Service unregistered")
}</span>

// ListServices lists all registered services
func (sr *ServiceRegistry) ListServices() map[string]string <span class="cov0" title="0">{
        return sr.services
}</span>

// ServerManager manages multiple gRPC servers
type ServerManager struct {
        servers map[string]*Server
        logger  *logger.Logger
}

// NewServerManager creates a new server manager
func NewServerManager(log *logger.Logger) *ServerManager <span class="cov0" title="0">{
        return &amp;ServerManager{
                servers: make(map[string]*Server),
                logger:  log,
        }
}</span>

// AddServer adds a server to the manager
func (sm *ServerManager) AddServer(name string, server *Server) <span class="cov0" title="0">{
        sm.servers[name] = server
        sm.logger.WithFields(logger.Fields{
                "server": name,
        }).Info("Server added to manager")
}</span>

// StartAll starts all servers
func (sm *ServerManager) StartAll() error <span class="cov0" title="0">{
        for name, server := range sm.servers </span><span class="cov0" title="0">{
                go func(serverName string, srv *Server) </span><span class="cov0" title="0">{
                        if err := srv.Start(); err != nil </span><span class="cov0" title="0">{
                                sm.logger.WithError(err).WithFields(logger.Fields{
                                        "server": serverName,
                                }).Error("Failed to start server")
                        }</span>
                }(name, server)
        }
        <span class="cov0" title="0">return nil</span>
}

// StopAll stops all servers gracefully
func (sm *ServerManager) StopAll() <span class="cov0" title="0">{
        for name, server := range sm.servers </span><span class="cov0" title="0">{
                sm.logger.WithFields(logger.Fields{
                        "server": name,
                }).Info("Stopping server")
                server.Stop()
        }</span>
}

// ForceStopAll force stops all servers
func (sm *ServerManager) ForceStopAll() <span class="cov0" title="0">{
        for name, server := range sm.servers </span><span class="cov0" title="0">{
                sm.logger.WithFields(logger.Fields{
                        "server": name,
                }).Info("Force stopping server")
                server.ForceStop()
        }</span>
}

// GetServer gets a server by name
func (sm *ServerManager) GetServer(name string) (*Server, bool) <span class="cov0" title="0">{
        server, exists := sm.servers[name]
        return server, exists
}</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "context"
        "os"
        "time"

        "github.com/sirupsen/logrus"
)

// Logger represents the application logger
type Logger struct {
        *logrus.Logger
}

// Fields represents log fields
type Fields = logrus.Fields

// ContextKey represents context keys for logger
type ContextKey string

const (
        // CorrelationIDKey is the context key for correlation ID
        CorrelationIDKey ContextKey = "correlation_id"
        // UserIDKey is the context key for user ID
        UserIDKey ContextKey = "user_id"
        // RequestIDKey is the context key for request ID
        RequestIDKey ContextKey = "request_id"
)

// NewLogger creates a new logger instance
func NewLogger(level string, environment string) *Logger <span class="cov0" title="0">{
        log := logrus.New()

        // Set log level
        logLevel, err := logrus.ParseLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                logLevel = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">log.SetLevel(logLevel)

        // Set formatter based on environment
        if environment == "production" </span><span class="cov0" title="0">{
                log.SetFormatter(&amp;logrus.JSONFormatter{
                        TimestampFormat: time.RFC3339,
                        FieldMap: logrus.FieldMap{
                                logrus.FieldKeyTime:  "timestamp",
                                logrus.FieldKeyLevel: "level",
                                logrus.FieldKeyMsg:   "message",
                                logrus.FieldKeyFunc:  "function",
                        },
                })
        }</span> else<span class="cov0" title="0"> {
                log.SetFormatter(&amp;logrus.TextFormatter{
                        FullTimestamp:   true,
                        TimestampFormat: time.RFC3339,
                        ForceColors:     true,
                })
        }</span>

        // Set output
        <span class="cov0" title="0">log.SetOutput(os.Stdout)

        // Add default fields
        log.WithFields(logrus.Fields{
                "service":     "rideshare-platform",
                "environment": environment,
                "version":     "1.0.0",
        })

        return &amp;Logger{Logger: log}</span>
}

// WithContext creates a logger with context values
func (l *Logger) WithContext(ctx context.Context) *logrus.Entry <span class="cov0" title="0">{
        entry := l.Logger.WithFields(logrus.Fields{})

        // Add correlation ID if present
        if correlationID := ctx.Value(CorrelationIDKey); correlationID != nil </span><span class="cov0" title="0">{
                entry = entry.WithField("correlation_id", correlationID)
        }</span>

        // Add user ID if present
        <span class="cov0" title="0">if userID := ctx.Value(UserIDKey); userID != nil </span><span class="cov0" title="0">{
                entry = entry.WithField("user_id", userID)
        }</span>

        // Add request ID if present
        <span class="cov0" title="0">if requestID := ctx.Value(RequestIDKey); requestID != nil </span><span class="cov0" title="0">{
                entry = entry.WithField("request_id", requestID)
        }</span>

        <span class="cov0" title="0">return entry</span>
}

// WithFields creates a logger with additional fields
func (l *Logger) WithFields(fields Fields) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithFields(logrus.Fields(fields))
}</span>

// WithError creates a logger with error field
func (l *Logger) WithError(err error) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithError(err)
}</span>

// WithService creates a logger with service field
func (l *Logger) WithService(service string) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithField("service", service)
}</span>

// WithComponent creates a logger with component field
func (l *Logger) WithComponent(component string) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithField("component", component)
}</span>

// WithOperation creates a logger with operation field
func (l *Logger) WithOperation(operation string) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithField("operation", operation)
}</span>

// WithDuration creates a logger with duration field
func (l *Logger) WithDuration(duration time.Duration) *logrus.Entry <span class="cov0" title="0">{
        return l.Logger.WithField("duration_ms", duration.Milliseconds())
}</span>

// LogRequest logs an HTTP request
func (l *Logger) LogRequest(ctx context.Context, method, path string, statusCode int, duration time.Duration) <span class="cov0" title="0">{
        l.WithContext(ctx).WithFields(logrus.Fields{
                "method":      method,
                "path":        path,
                "status_code": statusCode,
                "duration_ms": duration.Milliseconds(),
                "type":        "http_request",
        }).Info("HTTP request processed")
}</span>

// LogGRPCRequest logs a gRPC request
func (l *Logger) LogGRPCRequest(ctx context.Context, method string, duration time.Duration, err error) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "method":      method,
                "duration_ms": duration.Milliseconds(),
                "type":        "grpc_request",
        })

        if err != nil </span><span class="cov0" title="0">{
                entry.WithError(err).Error("gRPC request failed")
        }</span> else<span class="cov0" title="0"> {
                entry.Info("gRPC request processed")
        }</span>
}

// LogDatabaseQuery logs a database query
func (l *Logger) LogDatabaseQuery(ctx context.Context, query string, duration time.Duration, err error) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "query":       query,
                "duration_ms": duration.Milliseconds(),
                "type":        "database_query",
        })

        if err != nil </span><span class="cov0" title="0">{
                entry.WithError(err).Error("Database query failed")
        }</span> else<span class="cov0" title="0"> {
                entry.Debug("Database query executed")
        }</span>
}

// LogCacheOperation logs a cache operation
func (l *Logger) LogCacheOperation(ctx context.Context, operation, key string, hit bool, duration time.Duration) <span class="cov0" title="0">{
        l.WithContext(ctx).WithFields(logrus.Fields{
                "operation":   operation,
                "key":         key,
                "hit":         hit,
                "duration_ms": duration.Milliseconds(),
                "type":        "cache_operation",
        }).Debug("Cache operation")
}</span>

// LogBusinessEvent logs a business event
func (l *Logger) LogBusinessEvent(ctx context.Context, event string, entityID string, fields Fields) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "event":     event,
                "entity_id": entityID,
                "type":      "business_event",
        })

        if fields != nil </span><span class="cov0" title="0">{
                entry = entry.WithFields(logrus.Fields(fields))
        }</span>

        <span class="cov0" title="0">entry.Info("Business event")</span>
}

// LogSecurityEvent logs a security event
func (l *Logger) LogSecurityEvent(ctx context.Context, event string, severity string, fields Fields) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "event":    event,
                "severity": severity,
                "type":     "security_event",
        })

        if fields != nil </span><span class="cov0" title="0">{
                entry = entry.WithFields(logrus.Fields(fields))
        }</span>

        <span class="cov0" title="0">entry.Warn("Security event")</span>
}

// LogError logs an error with context
func (l *Logger) LogError(ctx context.Context, err error, message string, fields Fields) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithError(err)

        if fields != nil </span><span class="cov0" title="0">{
                entry = entry.WithFields(logrus.Fields(fields))
        }</span>

        <span class="cov0" title="0">entry.Error(message)</span>
}

// LogPanic logs a panic with context
func (l *Logger) LogPanic(ctx context.Context, panicValue interface{}, stack []byte) <span class="cov0" title="0">{
        l.WithContext(ctx).WithFields(logrus.Fields{
                "panic_value": panicValue,
                "stack_trace": string(stack),
                "type":        "panic",
        }).Fatal("Application panic")
}</span>

// LogMetric logs a metric
func (l *Logger) LogMetric(ctx context.Context, name string, value float64, tags map[string]string) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "metric_name":  name,
                "metric_value": value,
                "type":         "metric",
        })

        if tags != nil </span><span class="cov0" title="0">{
                for key, val := range tags </span><span class="cov0" title="0">{
                        entry = entry.WithField("tag_"+key, val)
                }</span>
        }

        <span class="cov0" title="0">entry.Info("Metric recorded")</span>
}

// LogAuditEvent logs an audit event
func (l *Logger) LogAuditEvent(ctx context.Context, action, resource string, fields Fields) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "action":   action,
                "resource": resource,
                "type":     "audit_event",
        })

        if fields != nil </span><span class="cov0" title="0">{
                entry = entry.WithFields(logrus.Fields(fields))
        }</span>

        <span class="cov0" title="0">entry.Info("Audit event")</span>
}

// LogPerformance logs performance metrics
func (l *Logger) LogPerformance(ctx context.Context, operation string, duration time.Duration, fields Fields) <span class="cov0" title="0">{
        entry := l.WithContext(ctx).WithFields(logrus.Fields{
                "operation":   operation,
                "duration_ms": duration.Milliseconds(),
                "type":        "performance",
        })

        if fields != nil </span><span class="cov0" title="0">{
                entry = entry.WithFields(logrus.Fields(fields))
        }</span>

        // Log as warning if operation takes too long
        <span class="cov0" title="0">if duration &gt; 5*time.Second </span><span class="cov0" title="0">{
                entry.Warn("Slow operation detected")
        }</span> else<span class="cov0" title="0"> {
                entry.Debug("Performance metric")
        }</span>
}

// StructuredLog provides structured logging methods
type StructuredLog struct {
        logger *Logger
        ctx    context.Context
        fields Fields
}

// NewStructuredLog creates a new structured log instance
func (l *Logger) NewStructuredLog(ctx context.Context) *StructuredLog <span class="cov0" title="0">{
        return &amp;StructuredLog{
                logger: l,
                ctx:    ctx,
                fields: make(Fields),
        }
}</span>

// WithField adds a field to the structured log
func (sl *StructuredLog) WithField(key string, value interface{}) *StructuredLog <span class="cov0" title="0">{
        sl.fields[key] = value
        return sl
}</span>

// WithFields adds multiple fields to the structured log
func (sl *StructuredLog) WithFields(fields Fields) *StructuredLog <span class="cov0" title="0">{
        for key, value := range fields </span><span class="cov0" title="0">{
                sl.fields[key] = value
        }</span>
        <span class="cov0" title="0">return sl</span>
}

// WithError adds an error to the structured log
func (sl *StructuredLog) WithError(err error) *StructuredLog <span class="cov0" title="0">{
        sl.fields["error"] = err.Error()
        return sl
}</span>

// Info logs an info message
func (sl *StructuredLog) Info(message string) <span class="cov0" title="0">{
        sl.logger.WithContext(sl.ctx).WithFields(logrus.Fields(sl.fields)).Info(message)
}</span>

// Warn logs a warning message
func (sl *StructuredLog) Warn(message string) <span class="cov0" title="0">{
        sl.logger.WithContext(sl.ctx).WithFields(logrus.Fields(sl.fields)).Warn(message)
}</span>

// Error logs an error message
func (sl *StructuredLog) Error(message string) <span class="cov0" title="0">{
        sl.logger.WithContext(sl.ctx).WithFields(logrus.Fields(sl.fields)).Error(message)
}</span>

// Debug logs a debug message
func (sl *StructuredLog) Debug(message string) <span class="cov0" title="0">{
        sl.logger.WithContext(sl.ctx).WithFields(logrus.Fields(sl.fields)).Debug(message)
}</span>

// Fatal logs a fatal message and exits
func (sl *StructuredLog) Fatal(message string) <span class="cov0" title="0">{
        sl.logger.WithContext(sl.ctx).WithFields(logrus.Fields(sl.fields)).Fatal(message)
}</span>

// Global logger instance
var globalLogger *Logger

// InitGlobalLogger initializes the global logger
func InitGlobalLogger(level, environment string) <span class="cov0" title="0">{
        globalLogger = NewLogger(level, environment)
}</span>

// GetGlobalLogger returns the global logger instance
func GetGlobalLogger() *Logger <span class="cov0" title="0">{
        if globalLogger == nil </span><span class="cov0" title="0">{
                globalLogger = NewLogger("info", "development")
        }</span>
        <span class="cov0" title="0">return globalLogger</span>
}

// Convenience functions using global logger

// Info logs an info message using global logger
func Info(message string) <span class="cov0" title="0">{
        GetGlobalLogger().Logger.Info(message)
}</span>

// Warn logs a warning message using global logger
func Warn(message string) <span class="cov0" title="0">{
        GetGlobalLogger().Logger.Warn(message)
}</span>

// Error logs an error message using global logger
func Error(message string) <span class="cov0" title="0">{
        GetGlobalLogger().Logger.Error(message)
}</span>

// Debug logs a debug message using global logger
func Debug(message string) <span class="cov0" title="0">{
        GetGlobalLogger().Logger.Debug(message)
}</span>

// Fatal logs a fatal message and exits using global logger
func Fatal(message string) <span class="cov0" title="0">{
        GetGlobalLogger().Logger.Fatal(message)
}</span>

// WithFields creates a logger with fields using global logger
func WithFields(fields Fields) *logrus.Entry <span class="cov0" title="0">{
        return GetGlobalLogger().WithFields(fields)
}</span>

// WithContext creates a logger with context using global logger
func WithContext(ctx context.Context) *logrus.Entry <span class="cov0" title="0">{
        return GetGlobalLogger().WithContext(ctx)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
        // HTTP metrics
        RequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "endpoint", "status"},
        )

        RequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"method", "endpoint"},
        )

        // Business metrics
        TripsCreated = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "trips_created_total",
                        Help: "Total number of trips created",
                },
                []string{"status"},
        )

        TripsCompleted = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "trips_completed_total",
                        Help: "Total number of trips completed",
                },
                []string{"payment_method"},
        )

        UsersRegistered = promauto.NewCounter(
                prometheus.CounterOpts{
                        Name: "users_registered_total",
                        Help: "Total number of users registered",
                },
        )

        DriversOnline = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "drivers_online",
                        Help: "Number of drivers currently online",
                },
        )

        MatchingAttempts = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "matching_attempts_total",
                        Help: "Total number of driver matching attempts",
                },
                []string{"result"},
        )

        MatchingDuration = promauto.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "matching_duration_seconds",
                        Help:    "Duration of driver matching process",
                        Buckets: []float64{0.1, 0.5, 1.0, 2.0, 5.0, 10.0},
                },
        )

        PaymentProcessingDuration = promauto.NewHistogram(
                prometheus.HistogramOpts{
                        Name:    "payment_processing_duration_seconds",
                        Help:    "Duration of payment processing",
                        Buckets: []float64{0.1, 0.5, 1.0, 2.0, 5.0},
                },
        )

        DatabaseConnectionsActive = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "database_connections_active",
                        Help: "Number of active database connections",
                },
                []string{"database"},
        )

        CacheHits = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cache_hits_total",
                        Help: "Total number of cache hits",
                },
                []string{"cache_type"},
        )

        CacheMisses = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cache_misses_total",
                        Help: "Total number of cache misses",
                },
                []string{"cache_type"},
        )
)

// RecordHTTPRequest records HTTP request metrics
func RecordHTTPRequest(method, endpoint, status string, duration time.Duration) <span class="cov0" title="0">{
        RequestsTotal.WithLabelValues(method, endpoint, status).Inc()
        RequestDuration.WithLabelValues(method, endpoint).Observe(duration.Seconds())
}</span>

// RecordTripCreated records trip creation
func RecordTripCreated(status string) <span class="cov0" title="0">{
        TripsCreated.WithLabelValues(status).Inc()
}</span>

// RecordTripCompleted records trip completion
func RecordTripCompleted(paymentMethod string) <span class="cov0" title="0">{
        TripsCompleted.WithLabelValues(paymentMethod).Inc()
}</span>

// RecordUserRegistration records user registration
func RecordUserRegistration() <span class="cov0" title="0">{
        UsersRegistered.Inc()
}</span>

// SetDriversOnline sets the number of drivers online
func SetDriversOnline(count float64) <span class="cov0" title="0">{
        DriversOnline.Set(count)
}</span>

// RecordMatchingAttempt records driver matching attempt
func RecordMatchingAttempt(result string, duration time.Duration) <span class="cov0" title="0">{
        MatchingAttempts.WithLabelValues(result).Inc()
        MatchingDuration.Observe(duration.Seconds())
}</span>

// RecordPaymentProcessing records payment processing duration
func RecordPaymentProcessing(duration time.Duration) <span class="cov0" title="0">{
        PaymentProcessingDuration.Observe(duration.Seconds())
}</span>

// SetDatabaseConnections sets active database connections
func SetDatabaseConnections(database string, count float64) <span class="cov0" title="0">{
        DatabaseConnectionsActive.WithLabelValues(database).Set(count)
}</span>

// RecordCacheHit records cache hit
func RecordCacheHit(cacheType string) <span class="cov0" title="0">{
        CacheHits.WithLabelValues(cacheType).Inc()
}</span>

// RecordCacheMiss records cache miss
func RecordCacheMiss(cacheType string) <span class="cov0" title="0">{
        CacheMisses.WithLabelValues(cacheType).Inc()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "context"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/dgrijalva/jwt-go"
        "github.com/gin-gonic/gin"
        "github.com/rideshare-platform/shared/logger"
)

// AuthClaims represents JWT claims
type AuthClaims struct {
        UserID   string `json:"user_id"`
        UserType string `json:"user_type"` // "rider" or "driver"
        Email    string `json:"email"`
        jwt.StandardClaims
}

// AuthMiddleware provides authentication middleware
type AuthMiddleware struct {
        jwtSecret []byte
        logger    *logger.Logger
}

// NewAuthMiddleware creates a new authentication middleware
func NewAuthMiddleware(jwtSecret string, log *logger.Logger) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                jwtSecret: []byte(jwtSecret),
                logger:    log,
        }
}</span>

// JWTAuth validates JWT tokens
func (a *AuthMiddleware) JWTAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).Warn("Missing authorization header")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
                        c.Abort()
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).Warn("Invalid authorization header format")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := tokenParts[1]

                // Parse and validate token
                token, err := jwt.ParseWithClaims(tokenString, &amp;AuthClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return a.jwtSecret, nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).WithError(err).Warn("Invalid JWT token")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">claims, ok := token.Claims.(*AuthClaims)
                if !ok || !token.Valid </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).Warn("Invalid JWT claims")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
                        c.Abort()
                        return
                }</span>

                // Check token expiration
                <span class="cov0" title="0">if claims.ExpiresAt &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).Warn("JWT token expired")
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Token expired"})
                        c.Abort()
                        return
                }</span>

                // Add user info to context
                <span class="cov0" title="0">ctx := context.WithValue(c.Request.Context(), logger.UserIDKey, claims.UserID)
                c.Request = c.Request.WithContext(ctx)

                // Set user info in Gin context
                c.Set("user_id", claims.UserID)
                c.Set("user_type", claims.UserType)
                c.Set("email", claims.Email)

                a.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                        "user_id":   claims.UserID,
                        "user_type": claims.UserType,
                }).Debug("User authenticated successfully")

                c.Next()</span>
        }
}

// RequireUserType ensures the user has the required type
func (a *AuthMiddleware) RequireUserType(userType string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                currentUserType, exists := c.Get("user_type")
                if !exists </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).Error("User type not found in context")
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Authentication error"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if currentUserType != userType </span><span class="cov0" title="0">{
                        a.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                                "required_type": userType,
                                "actual_type":   currentUserType,
                        }).Warn("Insufficient permissions")
                        c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// OptionalAuth validates JWT tokens but doesn't require them
func (a *AuthMiddleware) OptionalAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := tokenParts[1]

                // Parse and validate token
                token, err := jwt.ParseWithClaims(tokenString, &amp;AuthClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return a.jwtSecret, nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                <span class="cov0" title="0">claims, ok := token.Claims.(*AuthClaims)
                if !ok || !token.Valid </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Check token expiration
                <span class="cov0" title="0">if claims.ExpiresAt &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Add user info to context
                <span class="cov0" title="0">ctx := context.WithValue(c.Request.Context(), logger.UserIDKey, claims.UserID)
                c.Request = c.Request.WithContext(ctx)

                // Set user info in Gin context
                c.Set("user_id", claims.UserID)
                c.Set("user_type", claims.UserType)
                c.Set("email", claims.Email)

                c.Next()</span>
        }
}

// GenerateToken generates a JWT token for a user
func (a *AuthMiddleware) GenerateToken(userID, userType, email string, expirationHours int) (string, error) <span class="cov0" title="0">{
        claims := &amp;AuthClaims{
                UserID:   userID,
                UserType: userType,
                Email:    email,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour * time.Duration(expirationHours)).Unix(),
                        IssuedAt:  time.Now().Unix(),
                        Issuer:    "rideshare-platform",
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString(a.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// ValidateToken validates a JWT token and returns claims
func (a *AuthMiddleware) ValidateToken(tokenString string) (*AuthClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;AuthClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return a.jwtSecret, nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*AuthClaims)
        if !ok || !token.Valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token claims")
        }</span>

        // Check token expiration
        <span class="cov0" title="0">if claims.ExpiresAt &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token expired")
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// RefreshToken generates a new token with extended expiration
func (a *AuthMiddleware) RefreshToken(tokenString string, expirationHours int) (string, error) <span class="cov0" title="0">{
        claims, err := a.ValidateToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid token for refresh: %w", err)
        }</span>

        // Generate new token with extended expiration
        <span class="cov0" title="0">return a.GenerateToken(claims.UserID, claims.UserType, claims.Email, expirationHours)</span>
}

// GetUserFromContext extracts user information from Gin context
func GetUserFromContext(c *gin.Context) (userID, userType, email string, ok bool) <span class="cov0" title="0">{
        userIDVal, exists1 := c.Get("user_id")
        userTypeVal, exists2 := c.Get("user_type")
        emailVal, exists3 := c.Get("email")

        if !exists1 || !exists2 || !exists3 </span><span class="cov0" title="0">{
                return "", "", "", false
        }</span>

        <span class="cov0" title="0">userID, ok1 := userIDVal.(string)
        userType, ok2 := userTypeVal.(string)
        email, ok3 := emailVal.(string)

        return userID, userType, email, ok1 &amp;&amp; ok2 &amp;&amp; ok3</span>
}

// IsDriver checks if the current user is a driver
func IsDriver(c *gin.Context) bool <span class="cov0" title="0">{
        userType, exists := c.Get("user_type")
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return userType == "driver"</span>
}

// IsRider checks if the current user is a rider
func IsRider(c *gin.Context) bool <span class="cov0" title="0">{
        userType, exists := c.Get("user_type")
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return userType == "rider"</span>
}

// GetUserID extracts user ID from context
func GetUserID(c *gin.Context) (string, bool) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">id, ok := userID.(string)
        return id, ok</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "bytes"
        "context"
        "io"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
        "github.com/rideshare-platform/shared/logger"
)

// LoggingMiddleware provides request logging middleware
type LoggingMiddleware struct {
        logger *logger.Logger
}

// NewLoggingMiddleware creates a new logging middleware
func NewLoggingMiddleware(log *logger.Logger) *LoggingMiddleware <span class="cov0" title="0">{
        return &amp;LoggingMiddleware{
                logger: log,
        }
}</span>

// RequestLogger logs HTTP requests and responses
func (l *LoggingMiddleware) RequestLogger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Generate request ID
                requestID := uuid.New().String()

                // Add request ID to context
                ctx := context.WithValue(c.Request.Context(), logger.RequestIDKey, requestID)
                c.Request = c.Request.WithContext(ctx)

                // Set request ID in response header
                c.Header("X-Request-ID", requestID)

                // Record start time
                start := time.Now()

                // Capture request body if needed (for debugging)
                var requestBody []byte
                if c.Request.Body != nil </span><span class="cov0" title="0">{
                        requestBody, _ = io.ReadAll(c.Request.Body)
                        c.Request.Body = io.NopCloser(bytes.NewBuffer(requestBody))
                }</span>

                // Create response writer wrapper to capture response
                <span class="cov0" title="0">writer := &amp;responseWriter{
                        ResponseWriter: c.Writer,
                        body:           &amp;bytes.Buffer{},
                }
                c.Writer = writer

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Log request details
                l.logger.LogRequest(
                        c.Request.Context(),
                        c.Request.Method,
                        c.Request.URL.Path,
                        c.Writer.Status(),
                        duration,
                )

                // Log additional details for errors
                if c.Writer.Status() &gt;= 400 </span><span class="cov0" title="0">{
                        l.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                                "method":        c.Request.Method,
                                "path":          c.Request.URL.Path,
                                "status_code":   c.Writer.Status(),
                                "duration_ms":   duration.Milliseconds(),
                                "request_body":  string(requestBody),
                                "response_body": writer.body.String(),
                                "user_agent":    c.Request.UserAgent(),
                                "remote_addr":   c.ClientIP(),
                                "query_params":  c.Request.URL.RawQuery,
                        }).Error("HTTP request failed")
                }</span>
        }
}

// CorrelationID adds correlation ID to requests
func (l *LoggingMiddleware) CorrelationID() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Check if correlation ID exists in header
                correlationID := c.GetHeader("X-Correlation-ID")
                if correlationID == "" </span><span class="cov0" title="0">{
                        correlationID = uuid.New().String()
                }</span>

                // Add correlation ID to context
                <span class="cov0" title="0">ctx := context.WithValue(c.Request.Context(), logger.CorrelationIDKey, correlationID)
                c.Request = c.Request.WithContext(ctx)

                // Set correlation ID in response header
                c.Header("X-Correlation-ID", correlationID)

                c.Next()</span>
        }
}

// Recovery handles panics and logs them
func (l *LoggingMiddleware) Recovery() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.CustomRecovery(func(c *gin.Context, recovered interface{}) </span><span class="cov0" title="0">{
                l.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                        "panic_value": recovered,
                        "method":      c.Request.Method,
                        "path":        c.Request.URL.Path,
                        "user_agent":  c.Request.UserAgent(),
                        "remote_addr": c.ClientIP(),
                }).Error("Panic recovered")

                c.AbortWithStatus(500)
        }</span>)
}

// responseWriter wraps gin.ResponseWriter to capture response body
type responseWriter struct {
        gin.ResponseWriter
        body *bytes.Buffer
}

func (w *responseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

// SecurityHeaders adds security headers to responses
func (l *LoggingMiddleware) SecurityHeaders() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("X-Content-Type-Options", "nosniff")
                c.Header("X-Frame-Options", "DENY")
                c.Header("X-XSS-Protection", "1; mode=block")
                c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
                c.Header("Content-Security-Policy", "default-src 'self'")
                c.Header("Referrer-Policy", "strict-origin-when-cross-origin")

                c.Next()
        }</span>
}

// CORS handles Cross-Origin Resource Sharing
func (l *LoggingMiddleware) CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                origin := c.Request.Header.Get("Origin")

                // Allow specific origins (configure as needed)
                allowedOrigins := []string{
                        "http://localhost:3000",
                        "http://localhost:3001",
                        "https://rideshare-app.com",
                }

                allowed := false
                for _, allowedOrigin := range allowedOrigins </span><span class="cov0" title="0">{
                        if origin == allowedOrigin </span><span class="cov0" title="0">{
                                allowed = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if allowed </span><span class="cov0" title="0">{
                        c.Header("Access-Control-Allow-Origin", origin)
                }</span>

                <span class="cov0" title="0">c.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, X-Correlation-ID")
                c.Header("Access-Control-Expose-Headers", "X-Request-ID, X-Correlation-ID")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Max-Age", "86400")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// RateLimiting provides basic rate limiting (simple in-memory implementation)
func (l *LoggingMiddleware) RateLimiting() gin.HandlerFunc <span class="cov0" title="0">{
        // This is a simple implementation - in production, use Redis-based rate limiting
        clients := make(map[string][]time.Time)

        return func(c *gin.Context) </span><span class="cov0" title="0">{
                clientIP := c.ClientIP()
                now := time.Now()

                // Clean old entries (older than 1 minute)
                if requests, exists := clients[clientIP]; exists </span><span class="cov0" title="0">{
                        var validRequests []time.Time
                        for _, reqTime := range requests </span><span class="cov0" title="0">{
                                if now.Sub(reqTime) &lt; time.Minute </span><span class="cov0" title="0">{
                                        validRequests = append(validRequests, reqTime)
                                }</span>
                        }
                        <span class="cov0" title="0">clients[clientIP] = validRequests</span>
                }

                // Check rate limit (100 requests per minute)
                <span class="cov0" title="0">if len(clients[clientIP]) &gt;= 100 </span><span class="cov0" title="0">{
                        l.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                                "client_ip":     clientIP,
                                "request_count": len(clients[clientIP]),
                        }).Warn("Rate limit exceeded")

                        c.JSON(429, gin.H{"error": "Rate limit exceeded"})
                        c.Abort()
                        return
                }</span>

                // Add current request
                <span class="cov0" title="0">clients[clientIP] = append(clients[clientIP], now)

                c.Next()</span>
        }
}

// RequestSize limits request body size
func (l *LoggingMiddleware) RequestSize(maxSize int64) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.ContentLength &gt; maxSize </span><span class="cov0" title="0">{
                        l.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                                "content_length": c.Request.ContentLength,
                                "max_size":       maxSize,
                        }).Warn("Request body too large")

                        c.JSON(413, gin.H{"error": "Request body too large"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, maxSize)
                c.Next()</span>
        }
}

// Timeout adds request timeout
func (l *LoggingMiddleware) Timeout(timeout time.Duration) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
                defer cancel()

                c.Request = c.Request.WithContext(ctx)

                done := make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        c.Next()
                        done &lt;- struct{}{}
                }</span>()

                <span class="cov0" title="0">select </span>{
                case &lt;-done:<span class="cov0" title="0"></span>
                        // Request completed normally
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        l.logger.WithContext(c.Request.Context()).WithFields(logger.Fields{
                                "timeout": timeout,
                                "method":  c.Request.Method,
                                "path":    c.Request.URL.Path,
                        }).Warn("Request timeout")

                        c.JSON(408, gin.H{"error": "Request timeout"})
                        c.Abort()</span>
                }
        }
}

// HealthCheck provides a simple health check endpoint
func (l *LoggingMiddleware) HealthCheck() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                if c.Request.URL.Path == "/health" </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{
                                "status":    "healthy",
                                "timestamp": time.Now().UTC(),
                                "service":   "rideshare-platform",
                        })
                        c.Abort()
                        return
                }</span>
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "strconv"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/rideshare-platform/shared/logger"
)

// MetricsMiddleware provides Prometheus metrics collection
type MetricsMiddleware struct {
        logger           *logger.Logger
        requestDuration  *prometheus.HistogramVec
        requestsTotal    *prometheus.CounterVec
        requestsInFlight prometheus.Gauge
        requestSize      *prometheus.HistogramVec
        responseSize     *prometheus.HistogramVec
}

// NewMetricsMiddleware creates a new metrics middleware
func NewMetricsMiddleware(serviceName string, log *logger.Logger) *MetricsMiddleware <span class="cov0" title="0">{
        requestDuration := promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_duration_seconds",
                        Help:    "Duration of HTTP requests in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"service", "method", "endpoint", "status_code"},
        )

        requestsTotal := promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"service", "method", "endpoint", "status_code"},
        )

        requestsInFlight := promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "http_requests_in_flight",
                        Help: "Number of HTTP requests currently being processed",
                },
        )

        requestSize := promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_request_size_bytes",
                        Help:    "Size of HTTP requests in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"service", "method", "endpoint"},
        )

        responseSize := promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "http_response_size_bytes",
                        Help:    "Size of HTTP responses in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"service", "method", "endpoint", "status_code"},
        )

        return &amp;MetricsMiddleware{
                logger:           log,
                requestDuration:  requestDuration,
                requestsTotal:    requestsTotal,
                requestsInFlight: requestsInFlight,
                requestSize:      requestSize,
                responseSize:     responseSize,
        }
}</span>

// PrometheusMetrics collects Prometheus metrics for HTTP requests
func (m *MetricsMiddleware) PrometheusMetrics(serviceName string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // Skip metrics collection for metrics endpoint
                if c.Request.URL.Path == "/metrics" </span><span class="cov0" title="0">{
                        c.Next()
                        return
                }</span>

                // Increment in-flight requests
                <span class="cov0" title="0">m.requestsInFlight.Inc()
                defer m.requestsInFlight.Dec()

                // Record request size
                if c.Request.ContentLength &gt; 0 </span><span class="cov0" title="0">{
                        m.requestSize.WithLabelValues(
                                serviceName,
                                c.Request.Method,
                                c.FullPath(),
                        ).Observe(float64(c.Request.ContentLength))
                }</span>

                // Create response writer wrapper to capture response size
                <span class="cov0" title="0">writer := &amp;metricsResponseWriter{
                        ResponseWriter: c.Writer,
                        size:          0,
                }
                c.Writer = writer

                // Record start time
                start := time.Now()

                // Process request
                c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Get status code
                statusCode := strconv.Itoa(c.Writer.Status())

                // Record metrics
                m.requestDuration.WithLabelValues(
                        serviceName,
                        c.Request.Method,
                        c.FullPath(),
                        statusCode,
                ).Observe(duration.Seconds())

                m.requestsTotal.WithLabelValues(
                        serviceName,
                        c.Request.Method,
                        c.FullPath(),
                        statusCode,
                ).Inc()

                m.responseSize.WithLabelValues(
                        serviceName,
                        c.Request.Method,
                        c.FullPath(),
                        statusCode,
                ).Observe(float64(writer.size))

                // Log metrics
                m.logger.LogMetric(c.Request.Context(), "http_request_duration", duration.Seconds(), map[string]string{
                        "service":     serviceName,
                        "method":      c.Request.Method,
                        "endpoint":    c.FullPath(),
                        "status_code": statusCode,
                })</span>
        }
}

// metricsResponseWriter wraps gin.ResponseWriter to capture response size
type metricsResponseWriter struct {
        gin.ResponseWriter
        size int
}

func (w *metricsResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        size, err := w.ResponseWriter.Write(b)
        w.size += size
        return size, err
}</span>

// BusinessMetrics provides business-specific metrics
type BusinessMetrics struct {
        logger *logger.Logger
        
        // Trip metrics
        tripsCreated    *prometheus.CounterVec
        tripsCompleted  *prometheus.CounterVec
        tripsCancelled  *prometheus.CounterVec
        tripDuration    *prometheus.HistogramVec
        tripDistance    *prometheus.HistogramVec
        tripFare        *prometheus.HistogramVec
        
        // User metrics
        usersRegistered *prometheus.CounterVec
        usersActive     *prometheus.GaugeVec
        
        // Driver metrics
        driversOnline   prometheus.Gauge
        driversActive   prometheus.Gauge
        
        // Matching metrics
        matchingTime    *prometheus.HistogramVec
        matchingSuccess *prometheus.CounterVec
        matchingFailed  *prometheus.CounterVec
        
        // Payment metrics
        paymentsProcessed *prometheus.CounterVec
        paymentsFailed    *prometheus.CounterVec
        paymentAmount     *prometheus.HistogramVec
}

// NewBusinessMetrics creates business metrics collectors
func NewBusinessMetrics(log *logger.Logger) *BusinessMetrics <span class="cov0" title="0">{
        return &amp;BusinessMetrics{
                logger: log,
                
                tripsCreated: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "trips_created_total",
                                Help: "Total number of trips created",
                        },
                        []string{"service", "user_type"},
                ),
                
                tripsCompleted: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "trips_completed_total",
                                Help: "Total number of trips completed",
                        },
                        []string{"service"},
                ),
                
                tripsCancelled: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "trips_cancelled_total",
                                Help: "Total number of trips cancelled",
                        },
                        []string{"service", "cancelled_by"},
                ),
                
                tripDuration: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "trip_duration_seconds",
                                Help:    "Duration of completed trips in seconds",
                                Buckets: []float64{60, 300, 600, 1200, 1800, 3600, 7200},
                        },
                        []string{"service"},
                ),
                
                tripDistance: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "trip_distance_km",
                                Help:    "Distance of completed trips in kilometers",
                                Buckets: []float64{1, 2, 5, 10, 20, 50, 100},
                        },
                        []string{"service"},
                ),
                
                tripFare: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "trip_fare_amount",
                                Help:    "Fare amount of completed trips",
                                Buckets: []float64{5, 10, 20, 50, 100, 200, 500},
                        },
                        []string{"service", "currency"},
                ),
                
                usersRegistered: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "users_registered_total",
                                Help: "Total number of users registered",
                        },
                        []string{"service", "user_type"},
                ),
                
                usersActive: promauto.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "users_active",
                                Help: "Number of currently active users",
                        },
                        []string{"service", "user_type"},
                ),
                
                driversOnline: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Name: "drivers_online",
                                Help: "Number of drivers currently online",
                        },
                ),
                
                driversActive: promauto.NewGauge(
                        prometheus.GaugeOpts{
                                Name: "drivers_active",
                                Help: "Number of drivers currently on a trip",
                        },
                ),
                
                matchingTime: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "matching_time_seconds",
                                Help:    "Time taken to match rider with driver",
                                Buckets: []float64{1, 5, 10, 30, 60, 120, 300},
                        },
                        []string{"service"},
                ),
                
                matchingSuccess: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "matching_success_total",
                                Help: "Total number of successful matches",
                        },
                        []string{"service"},
                ),
                
                matchingFailed: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "matching_failed_total",
                                Help: "Total number of failed matches",
                        },
                        []string{"service", "reason"},
                ),
                
                paymentsProcessed: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "payments_processed_total",
                                Help: "Total number of payments processed",
                        },
                        []string{"service", "payment_method"},
                ),
                
                paymentsFailed: promauto.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "payments_failed_total",
                                Help: "Total number of failed payments",
                        },
                        []string{"service", "payment_method", "error_type"},
                ),
                
                paymentAmount: promauto.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "payment_amount",
                                Help:    "Amount of processed payments",
                                Buckets: []float64{5, 10, 20, 50, 100, 200, 500},
                        },
                        []string{"service", "currency", "payment_method"},
                ),
        }
}</span>

// RecordTripCreated records a trip creation event
func (bm *BusinessMetrics) RecordTripCreated(service, userType string) <span class="cov0" title="0">{
        bm.tripsCreated.WithLabelValues(service, userType).Inc()
}</span>

// RecordTripCompleted records a trip completion event
func (bm *BusinessMetrics) RecordTripCompleted(service string, duration time.Duration, distance, fare float64, currency string) <span class="cov0" title="0">{
        bm.tripsCompleted.WithLabelValues(service).Inc()
        bm.tripDuration.WithLabelValues(service).Observe(duration.Seconds())
        bm.tripDistance.WithLabelValues(service).Observe(distance)
        bm.tripFare.WithLabelValues(service, currency).Observe(fare)
}</span>

// RecordTripCancelled records a trip cancellation event
func (bm *BusinessMetrics) RecordTripCancelled(service, cancelledBy string) <span class="cov0" title="0">{
        bm.tripsCancelled.WithLabelValues(service, cancelledBy).Inc()
}</span>

// RecordUserRegistration records a user registration event
func (bm *BusinessMetrics) RecordUserRegistration(service, userType string) <span class="cov0" title="0">{
        bm.usersRegistered.WithLabelValues(service, userType).Inc()
}</span>

// SetActiveUsers sets the number of active users
func (bm *BusinessMetrics) SetActiveUsers(service, userType string, count float64) <span class="cov0" title="0">{
        bm.usersActive.WithLabelValues(service, userType).Set(count)
}</span>

// SetDriversOnline sets the number of online drivers
func (bm *BusinessMetrics) SetDriversOnline(count float64) <span class="cov0" title="0">{
        bm.driversOnline.Set(count)
}</span>

// SetDriversActive sets the number of active drivers
func (bm *BusinessMetrics) SetDriversActive(count float64) <span class="cov0" title="0">{
        bm.driversActive.Set(count)
}</span>

// RecordMatchingSuccess records a successful match
func (bm *BusinessMetrics) RecordMatchingSuccess(service string, duration time.Duration) <span class="cov0" title="0">{
        bm.matchingSuccess.WithLabelValues(service).Inc()
        bm.matchingTime.WithLabelValues(service).Observe(duration.Seconds())
}</span>

// RecordMatchingFailed records a failed match
func (bm *BusinessMetrics) RecordMatchingFailed(service, reason string) <span class="cov0" title="0">{
        bm.matchingFailed.WithLabelValues(service, reason).Inc()
}</span>

// RecordPaymentProcessed records a successful payment
func (bm *BusinessMetrics) RecordPaymentProcessed(service, paymentMethod, currency string, amount float64) <span class="cov0" title="0">{
        bm.paymentsProcessed.WithLabelValues(service, paymentMethod).Inc()
        bm.paymentAmount.WithLabelValues(service, currency, paymentMethod).Observe(amount)
}</span>

// RecordPaymentFailed records a failed payment
func (bm *BusinessMetrics) RecordPaymentFailed(service, paymentMethod, errorType string) <span class="cov0" title="0">{
        bm.paymentsFailed.WithLabelValues(service, paymentMethod, errorType).Inc()
}</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "crypto/sha256"
        "fmt"
        "math"
        "time"
)

// Location represents a geographical coordinate
type Location struct {
        Latitude  float64   `json:"latitude" db:"latitude"`
        Longitude float64   `json:"longitude" db:"longitude"`
        Accuracy  float64   `json:"accuracy" db:"accuracy"` // accuracy in meters
        Timestamp time.Time `json:"timestamp" db:"timestamp"`
}

// Address represents a physical address
type Address struct {
        Street      string    `json:"street" db:"street"`
        City        string    `json:"city" db:"city"`
        State       string    `json:"state" db:"state"`
        Country     string    `json:"country" db:"country"`
        PostalCode  string    `json:"postal_code" db:"postal_code"`
        Coordinates *Location `json:"coordinates,omitempty"`
}

// NewLocation creates a new location with current timestamp
func NewLocation(lat, lng, accuracy float64) *Location <span class="cov0" title="0">{
        return &amp;Location{
                Latitude:  lat,
                Longitude: lng,
                Accuracy:  accuracy,
                Timestamp: time.Now(),
        }
}</span>

// NewAddress creates a new address
func NewAddress(street, city, state, country, postalCode string) *Address <span class="cov0" title="0">{
        return &amp;Address{
                Street:     street,
                City:       city,
                State:      state,
                Country:    country,
                PostalCode: postalCode,
        }
}</span>

// IsValid checks if the location coordinates are valid
func (l *Location) IsValid() bool <span class="cov0" title="0">{
        return l.Latitude &gt;= -90 &amp;&amp; l.Latitude &lt;= 90 &amp;&amp;
                l.Longitude &gt;= -180 &amp;&amp; l.Longitude &lt;= 180
}</span>

// DistanceTo calculates the distance to another location using Haversine formula
func (l *Location) DistanceTo(other *Location) float64 <span class="cov0" title="0">{
        if !l.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">const earthRadiusKm = 6371.0

        // Convert degrees to radians
        lat1Rad := l.Latitude * math.Pi / 180
        lon1Rad := l.Longitude * math.Pi / 180
        lat2Rad := other.Latitude * math.Pi / 180
        lon2Rad := other.Longitude * math.Pi / 180

        // Haversine formula
        dlat := lat2Rad - lat1Rad
        dlon := lon2Rad - lon1Rad

        a := math.Sin(dlat/2)*math.Sin(dlat/2) +
                math.Cos(lat1Rad)*math.Cos(lat2Rad)*
                        math.Sin(dlon/2)*math.Sin(dlon/2)

        c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
        distance := earthRadiusKm * c

        return distance</span>
}

// Bearing calculates the initial bearing from this location to another
func (l *Location) Bearing(other *Location) float64 <span class="cov0" title="0">{
        if !l.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">lat1Rad := l.Latitude * math.Pi / 180
        lat2Rad := other.Latitude * math.Pi / 180
        deltaLonRad := (other.Longitude - l.Longitude) * math.Pi / 180

        y := math.Sin(deltaLonRad) * math.Cos(lat2Rad)
        x := math.Cos(lat1Rad)*math.Sin(lat2Rad) -
                math.Sin(lat1Rad)*math.Cos(lat2Rad)*math.Cos(deltaLonRad)

        bearing := math.Atan2(y, x) * 180 / math.Pi
        return math.Mod(bearing+360, 360)</span>
}

// Geohash generates a geohash for the location with specified precision
func (l *Location) Geohash(precision int) string <span class="cov0" title="0">{
        if !l.IsValid() || precision &lt;= 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">const base32 = "0123456789bcdefghjkmnpqrstuvwxyz"

        latRange := []float64{-90.0, 90.0}
        lonRange := []float64{-180.0, 180.0}

        var geohash string
        var bit int
        var ch int
        even := true

        for len(geohash) &lt; precision </span><span class="cov0" title="0">{
                if even </span><span class="cov0" title="0">{
                        // longitude
                        mid := (lonRange[0] + lonRange[1]) / 2
                        if l.Longitude &gt;= mid </span><span class="cov0" title="0">{
                                ch |= 1 &lt;&lt; (4 - bit)
                                lonRange[0] = mid
                        }</span> else<span class="cov0" title="0"> {
                                lonRange[1] = mid
                        }</span>
                } else<span class="cov0" title="0"> {
                        // latitude
                        mid := (latRange[0] + latRange[1]) / 2
                        if l.Latitude &gt;= mid </span><span class="cov0" title="0">{
                                ch |= 1 &lt;&lt; (4 - bit)
                                latRange[0] = mid
                        }</span> else<span class="cov0" title="0"> {
                                latRange[1] = mid
                        }</span>
                }

                <span class="cov0" title="0">even = !even
                bit++

                if bit == 5 </span><span class="cov0" title="0">{
                        geohash += string(base32[ch])
                        bit = 0
                        ch = 0
                }</span>
        }

        <span class="cov0" title="0">return geohash</span>
}

// Hash generates a hash for the location (useful for caching)
func (l *Location) Hash() string <span class="cov0" title="0">{
        data := fmt.Sprintf("%.6f,%.6f", l.Latitude, l.Longitude)
        hash := sha256.Sum256([]byte(data))
        return fmt.Sprintf("%x", hash)[:16] // Return first 16 characters
}</span>

// IsWithinRadius checks if the location is within a specified radius of another location
func (l *Location) IsWithinRadius(other *Location, radiusKm float64) bool <span class="cov0" title="0">{
        return l.DistanceTo(other) &lt;= radiusKm
}</span>

// MidpointTo calculates the midpoint between this location and another
func (l *Location) MidpointTo(other *Location) *Location <span class="cov0" title="0">{
        if !l.IsValid() || !other.IsValid() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">lat1Rad := l.Latitude * math.Pi / 180
        lon1Rad := l.Longitude * math.Pi / 180
        lat2Rad := other.Latitude * math.Pi / 180
        deltaLonRad := (other.Longitude - l.Longitude) * math.Pi / 180

        bx := math.Cos(lat2Rad) * math.Cos(deltaLonRad)
        by := math.Cos(lat2Rad) * math.Sin(deltaLonRad)

        lat3Rad := math.Atan2(
                math.Sin(lat1Rad)+math.Sin(lat2Rad),
                math.Sqrt((math.Cos(lat1Rad)+bx)*(math.Cos(lat1Rad)+bx)+by*by),
        )
        lon3Rad := lon1Rad + math.Atan2(by, math.Cos(lat1Rad)+bx)

        return &amp;Location{
                Latitude:  lat3Rad * 180 / math.Pi,
                Longitude: lon3Rad * 180 / math.Pi,
                Timestamp: time.Now(),
        }</span>
}

// String returns a string representation of the location
func (l *Location) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("(%.6f, %.6f)", l.Latitude, l.Longitude)
}</span>

// String returns a string representation of the address
func (a *Address) String() string <span class="cov0" title="0">{
        parts := []string{}
        if a.Street != "" </span><span class="cov0" title="0">{
                parts = append(parts, a.Street)
        }</span>
        <span class="cov0" title="0">if a.City != "" </span><span class="cov0" title="0">{
                parts = append(parts, a.City)
        }</span>
        <span class="cov0" title="0">if a.State != "" </span><span class="cov0" title="0">{
                parts = append(parts, a.State)
        }</span>
        <span class="cov0" title="0">if a.PostalCode != "" </span><span class="cov0" title="0">{
                parts = append(parts, a.PostalCode)
        }</span>
        <span class="cov0" title="0">if a.Country != "" </span><span class="cov0" title="0">{
                parts = append(parts, a.Country)
        }</span>

        <span class="cov0" title="0">result := ""
        for i, part := range parts </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        result += ", "
                }</span>
                <span class="cov0" title="0">result += part</span>
        }
        <span class="cov0" title="0">return result</span>
}

// IsComplete checks if the address has all required fields
func (a *Address) IsComplete() bool <span class="cov0" title="0">{
        return a.Street != "" &amp;&amp; a.City != "" &amp;&amp; a.State != "" &amp;&amp; a.Country != ""
}</span>

// DecodeGeohash decodes a geohash string back to a location
func DecodeGeohash(geohash string) *Location <span class="cov0" title="0">{
        if geohash == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">const base32 = "0123456789bcdefghjkmnpqrstuvwxyz"

        latRange := []float64{-90.0, 90.0}
        lonRange := []float64{-180.0, 180.0}

        even := true

        for _, char := range geohash </span><span class="cov0" title="0">{
                idx := -1
                for i, c := range base32 </span><span class="cov0" title="0">{
                        if c == char </span><span class="cov0" title="0">{
                                idx = i
                                break</span>
                        }
                }

                <span class="cov0" title="0">if idx == -1 </span><span class="cov0" title="0">{
                        return nil // Invalid character
                }</span>

                <span class="cov0" title="0">for i := 4; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        bit := (idx &gt;&gt; i) &amp; 1

                        if even </span><span class="cov0" title="0">{
                                // longitude
                                mid := (lonRange[0] + lonRange[1]) / 2
                                if bit == 1 </span><span class="cov0" title="0">{
                                        lonRange[0] = mid
                                }</span> else<span class="cov0" title="0"> {
                                        lonRange[1] = mid
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // latitude
                                mid := (latRange[0] + latRange[1]) / 2
                                if bit == 1 </span><span class="cov0" title="0">{
                                        latRange[0] = mid
                                }</span> else<span class="cov0" title="0"> {
                                        latRange[1] = mid
                                }</span>
                        }

                        <span class="cov0" title="0">even = !even</span>
                }
        }

        <span class="cov0" title="0">return &amp;Location{
                Latitude:  (latRange[0] + latRange[1]) / 2,
                Longitude: (lonRange[0] + lonRange[1]) / 2,
                Timestamp: time.Now(),
        }</span>
}

// DriverLocation represents a driver's real-time location with additional metadata
type DriverLocation struct {
        DriverID           string    `json:"driver_id" db:"driver_id"`
        VehicleID          string    `json:"vehicle_id" db:"vehicle_id"`
        Location           *Location `json:"location" db:"location"`
        DistanceFromCenter float64   `json:"distance_from_center" db:"distance_from_center"`
        Status             string    `json:"status" db:"status"`
        VehicleType        string    `json:"vehicle_type" db:"vehicle_type"`
        Rating             float32   `json:"rating" db:"rating"`
        LastUpdated        time.Time `json:"last_updated" db:"last_updated"`
}

// NewDriverLocation creates a new driver location entry
func NewDriverLocation(driverID, vehicleID string, location *Location, status, vehicleType string, rating float32) *DriverLocation <span class="cov0" title="0">{
        return &amp;DriverLocation{
                DriverID:    driverID,
                VehicleID:   vehicleID,
                Location:    location,
                Status:      status,
                VehicleType: vehicleType,
                Rating:      rating,
                LastUpdated: time.Now(),
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "time"
)

// PaymentMethodType represents the type of payment method
type PaymentMethodType string

const (
        PaymentMethodCreditCard    PaymentMethodType = "credit_card"
        PaymentMethodDebitCard     PaymentMethodType = "debit_card"
        PaymentMethodDigitalWallet PaymentMethodType = "digital_wallet"
        PaymentMethodCash          PaymentMethodType = "cash"
        PaymentMethodBankTransfer  PaymentMethodType = "bank_transfer"
)

// PaymentStatus represents the current status of a payment
type PaymentStatus string

const (
        PaymentStatusPending    PaymentStatus = "pending"
        PaymentStatusProcessing PaymentStatus = "processing"
        PaymentStatusCompleted  PaymentStatus = "completed"
        PaymentStatusFailed     PaymentStatus = "failed"
        PaymentStatusCancelled  PaymentStatus = "cancelled"
        PaymentStatusRefunded   PaymentStatus = "refunded"
)

// PaymentMethod represents a payment method for a user
type PaymentMethod struct {
        ID                      string            `json:"id" db:"id"`
        UserID                  string            `json:"user_id" db:"user_id"`
        Type                    PaymentMethodType `json:"type" db:"type"`
        Provider                *string           `json:"provider" db:"provider"`
        ProviderPaymentMethodID *string           `json:"provider_payment_method_id" db:"provider_payment_method_id"`
        LastFour                string            `json:"last_four" db:"last_four"`
        Brand                   string            `json:"brand" db:"brand"`
        IsDefault               bool              `json:"is_default" db:"is_default"`
        ExpiresAt               *time.Time        `json:"expires_at" db:"expires_at"`
        BillingAddress          map[string]string `json:"billing_address" db:"billing_address"`
        CreatedAt               time.Time         `json:"created_at" db:"created_at"`
        UpdatedAt               time.Time         `json:"updated_at" db:"updated_at"`
}

// Payment represents a payment transaction
type Payment struct {
        ID                   string                 `json:"id" db:"id"`
        TripID               string                 `json:"trip_id" db:"trip_id"`
        UserID               string                 `json:"user_id" db:"user_id"`
        PaymentMethodID      *string                `json:"payment_method_id" db:"payment_method_id"`
        AmountCents          int64                  `json:"amount_cents" db:"amount_cents"`
        Currency             string                 `json:"currency" db:"currency"`
        Status               PaymentStatus          `json:"status" db:"status"`
        GatewayProvider      *string                `json:"gateway_provider" db:"gateway_provider"`
        GatewayTransactionID *string                `json:"gateway_transaction_id" db:"gateway_transaction_id"`
        GatewayResponse      map[string]interface{} `json:"gateway_response" db:"gateway_response"`
        FailureCode          *string                `json:"failure_code" db:"failure_code"`
        FailureReason        *string                `json:"failure_reason" db:"failure_reason"`
        RefundedAmountCents  int64                  `json:"refunded_amount_cents" db:"refunded_amount_cents"`
        RefundReason         *string                `json:"refund_reason" db:"refund_reason"`
        CreatedAt            time.Time              `json:"created_at" db:"created_at"`
        UpdatedAt            time.Time              `json:"updated_at" db:"updated_at"`
        ProcessedAt          *time.Time             `json:"processed_at" db:"processed_at"`
        FailedAt             *time.Time             `json:"failed_at" db:"failed_at"`
}

// NewPaymentMethod creates a new payment method
func NewPaymentMethod(userID string, methodType PaymentMethodType, lastFour, brand string) *PaymentMethod <span class="cov0" title="0">{
        return &amp;PaymentMethod{
                ID:             generateID(),
                UserID:         userID,
                Type:           methodType,
                LastFour:       lastFour,
                Brand:          brand,
                IsDefault:      false,
                BillingAddress: make(map[string]string),
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }
}</span>

// NewPayment creates a new payment
func NewPayment(tripID, userID string, amountCents int64, currency string) *Payment <span class="cov0" title="0">{
        return &amp;Payment{
                ID:                  generateID(),
                TripID:              tripID,
                UserID:              userID,
                AmountCents:         amountCents,
                Currency:            currency,
                Status:              PaymentStatusPending,
                RefundedAmountCents: 0,
                GatewayResponse:     make(map[string]interface{}),
                CreatedAt:           time.Now(),
                UpdatedAt:           time.Now(),
        }
}</span>

// IsActive returns true if the payment method is active
func (pm *PaymentMethod) IsActive() bool <span class="cov0" title="0">{
        if pm.ExpiresAt != nil &amp;&amp; time.Now().After(*pm.ExpiresAt) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// SetAsDefault sets this payment method as the default for the user
func (pm *PaymentMethod) SetAsDefault() <span class="cov0" title="0">{
        pm.IsDefault = true
        pm.UpdatedAt = time.Now()
}</span>

// UnsetAsDefault removes the default status from this payment method
func (pm *PaymentMethod) UnsetAsDefault() <span class="cov0" title="0">{
        pm.IsDefault = false
        pm.UpdatedAt = time.Now()
}</span>

// SetProvider sets the payment provider information
func (pm *PaymentMethod) SetProvider(provider, providerPaymentMethodID string) <span class="cov0" title="0">{
        pm.Provider = &amp;provider
        pm.ProviderPaymentMethodID = &amp;providerPaymentMethodID
        pm.UpdatedAt = time.Now()
}</span>

// SetBillingAddress sets the billing address
func (pm *PaymentMethod) SetBillingAddress(address map[string]string) <span class="cov0" title="0">{
        pm.BillingAddress = address
        pm.UpdatedAt = time.Now()
}</span>

// SetExpiry sets the expiry date for the payment method
func (pm *PaymentMethod) SetExpiry(expiresAt time.Time) <span class="cov0" title="0">{
        pm.ExpiresAt = &amp;expiresAt
        pm.UpdatedAt = time.Now()
}</span>

// GetDisplayName returns a display name for the payment method
func (pm *PaymentMethod) GetDisplayName() string <span class="cov0" title="0">{
        switch pm.Type </span>{
        case PaymentMethodCreditCard, PaymentMethodDebitCard:<span class="cov0" title="0">
                return pm.Brand + " ending in " + pm.LastFour</span>
        case PaymentMethodDigitalWallet:<span class="cov0" title="0">
                return string(pm.Type) + " (" + pm.Brand + ")"</span>
        case PaymentMethodCash:<span class="cov0" title="0">
                return "Cash"</span>
        case PaymentMethodBankTransfer:<span class="cov0" title="0">
                return "Bank Transfer"</span>
        default:<span class="cov0" title="0">
                return string(pm.Type)</span>
        }
}

// IsPending returns true if the payment is pending
func (p *Payment) IsPending() bool <span class="cov0" title="0">{
        return p.Status == PaymentStatusPending
}</span>

// IsProcessing returns true if the payment is processing
func (p *Payment) IsProcessing() bool <span class="cov0" title="0">{
        return p.Status == PaymentStatusProcessing
}</span>

// IsCompleted returns true if the payment is completed
func (p *Payment) IsCompleted() bool <span class="cov0" title="0">{
        return p.Status == PaymentStatusCompleted
}</span>

// IsFailed returns true if the payment failed
func (p *Payment) IsFailed() bool <span class="cov0" title="0">{
        return p.Status == PaymentStatusFailed
}</span>

// IsCancelled returns true if the payment was cancelled
func (p *Payment) IsCancelled() bool <span class="cov0" title="0">{
        return p.Status == PaymentStatusCancelled
}</span>

// IsRefunded returns true if the payment was refunded
func (p *Payment) IsRefunded() bool <span class="cov0" title="0">{
        return p.Status == PaymentStatusRefunded
}</span>

// GetAmount returns the payment amount as Money
func (p *Payment) GetAmount() Money <span class="cov0" title="0">{
        return Money{
                Amount:   p.AmountCents,
                Currency: p.Currency,
        }
}</span>

// GetRefundedAmount returns the refunded amount as Money
func (p *Payment) GetRefundedAmount() Money <span class="cov0" title="0">{
        return Money{
                Amount:   p.RefundedAmountCents,
                Currency: p.Currency,
        }
}</span>

// GetNetAmount returns the net amount (amount - refunded) as Money
func (p *Payment) GetNetAmount() Money <span class="cov0" title="0">{
        return Money{
                Amount:   p.AmountCents - p.RefundedAmountCents,
                Currency: p.Currency,
        }
}</span>

// UpdateStatus updates the payment status
func (p *Payment) UpdateStatus(status PaymentStatus) <span class="cov0" title="0">{
        p.Status = status
        p.UpdatedAt = time.Now()

        now := time.Now()
        switch status </span>{
        case PaymentStatusCompleted:<span class="cov0" title="0">
                p.ProcessedAt = &amp;now</span>
        case PaymentStatusFailed:<span class="cov0" title="0">
                p.FailedAt = &amp;now</span>
        }
}

// SetPaymentMethod sets the payment method for this payment
func (p *Payment) SetPaymentMethod(paymentMethodID string) <span class="cov0" title="0">{
        p.PaymentMethodID = &amp;paymentMethodID
        p.UpdatedAt = time.Now()
}</span>

// SetGatewayInfo sets the payment gateway information
func (p *Payment) SetGatewayInfo(provider, transactionID string, response map[string]interface{}) <span class="cov0" title="0">{
        p.GatewayProvider = &amp;provider
        p.GatewayTransactionID = &amp;transactionID
        p.GatewayResponse = response
        p.UpdatedAt = time.Now()
}</span>

// SetFailure sets the failure information
func (p *Payment) SetFailure(code, reason string) <span class="cov0" title="0">{
        p.FailureCode = &amp;code
        p.FailureReason = &amp;reason
        p.UpdateStatus(PaymentStatusFailed)
}</span>

// AddRefund adds a refund amount to the payment
func (p *Payment) AddRefund(refundAmountCents int64, reason string) <span class="cov0" title="0">{
        p.RefundedAmountCents += refundAmountCents
        p.RefundReason = &amp;reason

        // If fully refunded, update status
        if p.RefundedAmountCents &gt;= p.AmountCents </span><span class="cov0" title="0">{
                p.UpdateStatus(PaymentStatusRefunded)
        }</span>

        <span class="cov0" title="0">p.UpdatedAt = time.Now()</span>
}

// CanBeRefunded returns true if the payment can be refunded
func (p *Payment) CanBeRefunded() bool <span class="cov0" title="0">{
        return p.IsCompleted() &amp;&amp; p.RefundedAmountCents &lt; p.AmountCents
}</span>

// GetRefundableAmount returns the amount that can still be refunded
func (p *Payment) GetRefundableAmount() int64 <span class="cov0" title="0">{
        if !p.CanBeRefunded() </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return p.AmountCents - p.RefundedAmountCents</span>
}

// IsPartiallyRefunded returns true if the payment is partially refunded
func (p *Payment) IsPartiallyRefunded() bool <span class="cov0" title="0">{
        return p.RefundedAmountCents &gt; 0 &amp;&amp; p.RefundedAmountCents &lt; p.AmountCents
}</span>

// IsFullyRefunded returns true if the payment is fully refunded
func (p *Payment) IsFullyRefunded() bool <span class="cov0" title="0">{
        return p.RefundedAmountCents &gt;= p.AmountCents
}</span>

// GetProcessingDuration returns the duration it took to process the payment
func (p *Payment) GetProcessingDuration() *time.Duration <span class="cov0" title="0">{
        if p.ProcessedAt == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">duration := p.ProcessedAt.Sub(p.CreatedAt)
        return &amp;duration</span>
}

// IsValidPaymentMethodType checks if a payment method type is valid
func IsValidPaymentMethodType(methodType string) bool <span class="cov0" title="0">{
        validTypes := []PaymentMethodType{
                PaymentMethodCreditCard,
                PaymentMethodDebitCard,
                PaymentMethodDigitalWallet,
                PaymentMethodCash,
                PaymentMethodBankTransfer,
        }

        for _, validType := range validTypes </span><span class="cov0" title="0">{
                if PaymentMethodType(methodType) == validType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsValidPaymentStatus checks if a payment status is valid
func IsValidPaymentStatus(status string) bool <span class="cov0" title="0">{
        validStatuses := []PaymentStatus{
                PaymentStatusPending,
                PaymentStatusProcessing,
                PaymentStatusCompleted,
                PaymentStatusFailed,
                PaymentStatusCancelled,
                PaymentStatusRefunded,
        }

        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if PaymentStatus(status) == validStatus </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetPaymentMethodTypes returns all valid payment method types
func GetPaymentMethodTypes() []PaymentMethodType <span class="cov0" title="0">{
        return []PaymentMethodType{
                PaymentMethodCreditCard,
                PaymentMethodDebitCard,
                PaymentMethodDigitalWallet,
                PaymentMethodCash,
                PaymentMethodBankTransfer,
        }
}</span>

// GetPaymentStatuses returns all valid payment statuses
func GetPaymentStatuses() []PaymentStatus <span class="cov0" title="0">{
        return []PaymentStatus{
                PaymentStatusPending,
                PaymentStatusProcessing,
                PaymentStatusCompleted,
                PaymentStatusFailed,
                PaymentStatusCancelled,
                PaymentStatusRefunded,
        }
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

import (
        "fmt"
        "time"
)

// Money represents a monetary value
type Money struct {
        Amount   int64  `json:"amount" db:"amount"`     // amount in cents
        Currency string `json:"currency" db:"currency"` // ISO 4217 currency code
}

// PricingFactors represents the factors used in fare calculation
type PricingFactors struct {
        BaseFare        float64 `json:"base_fare" db:"base_fare"`
        PerKmRate       float64 `json:"per_km_rate" db:"per_km_rate"`
        PerMinuteRate   float64 `json:"per_minute_rate" db:"per_minute_rate"`
        SurgeMultiplier float64 `json:"surge_multiplier" db:"surge_multiplier"`
        BookingFee      float64 `json:"booking_fee" db:"booking_fee"`
        ServiceFee      float64 `json:"service_fee" db:"service_fee"`
}

// FareBreakdown represents a detailed breakdown of fare calculation
type FareBreakdown struct {
        BaseFare     Money `json:"base_fare" db:"base_fare"`
        DistanceFare Money `json:"distance_fare" db:"distance_fare"`
        TimeFare     Money `json:"time_fare" db:"time_fare"`
        SurgeAmount  Money `json:"surge_amount" db:"surge_amount"`
        BookingFee   Money `json:"booking_fee" db:"booking_fee"`
        ServiceFee   Money `json:"service_fee" db:"service_fee"`
        Discount     Money `json:"discount" db:"discount"`
        Total        Money `json:"total" db:"total"`
}

// PricingRule represents a pricing rule for a specific vehicle type and location
type PricingRule struct {
        ID                 string             `json:"id" db:"id"`
        Name               string             `json:"name" db:"name"`
        VehicleType        VehicleType        `json:"vehicle_type" db:"vehicle_type"`
        City               *string            `json:"city" db:"city"`
        BaseFareCents      int64              `json:"base_fare_cents" db:"base_fare_cents"`
        PerKmRateCents     int64              `json:"per_km_rate_cents" db:"per_km_rate_cents"`
        PerMinuteRateCents int64              `json:"per_minute_rate_cents" db:"per_minute_rate_cents"`
        BookingFeeCents    int64              `json:"booking_fee_cents" db:"booking_fee_cents"`
        ServiceFeeCents    int64              `json:"service_fee_cents" db:"service_fee_cents"`
        TimeMultipliers    map[string]float64 `json:"time_multipliers" db:"time_multipliers"`
        DayMultipliers     map[string]float64 `json:"day_multipliers" db:"day_multipliers"`
        MinFareCents       *int64             `json:"min_fare_cents" db:"min_fare_cents"`
        MaxFareCents       *int64             `json:"max_fare_cents" db:"max_fare_cents"`
        ValidFrom          time.Time          `json:"valid_from" db:"valid_from"`
        ValidUntil         *time.Time         `json:"valid_until" db:"valid_until"`
        IsActive           bool               `json:"is_active" db:"is_active"`
        CreatedAt          time.Time          `json:"created_at" db:"created_at"`
        UpdatedAt          time.Time          `json:"updated_at" db:"updated_at"`
}

// SurgePricing represents surge pricing information
type SurgePricing struct {
        ID              string      `json:"id" db:"id"`
        LocationGeohash string      `json:"location_geohash" db:"location_geohash"`
        VehicleType     VehicleType `json:"vehicle_type" db:"vehicle_type"`
        Multiplier      float64     `json:"multiplier" db:"multiplier"`
        Reason          *string     `json:"reason" db:"reason"`
        DemandLevel     string      `json:"demand_level" db:"demand_level"`
        SupplyLevel     string      `json:"supply_level" db:"supply_level"`
        StartsAt        time.Time   `json:"starts_at" db:"starts_at"`
        ExpiresAt       time.Time   `json:"expires_at" db:"expires_at"`
        Active          bool        `json:"is_active" db:"is_active"`
        CreatedAt       time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time   `json:"updated_at" db:"updated_at"`
}

// PromoCode represents a promotional discount code
type PromoCode struct {
        ID                     string        `json:"id" db:"id"`
        Code                   string        `json:"code" db:"code"`
        Description            *string       `json:"description" db:"description"`
        DiscountType           string        `json:"discount_type" db:"discount_type"` // "percentage" or "fixed_amount"
        DiscountValue          float64       `json:"discount_value" db:"discount_value"`
        MaxDiscountCents       *int64        `json:"max_discount_cents" db:"max_discount_cents"`
        MinTripAmountCents     *int64        `json:"min_trip_amount_cents" db:"min_trip_amount_cents"`
        MaxUses                *int          `json:"max_uses" db:"max_uses"`
        MaxUsesPerUser         int           `json:"max_uses_per_user" db:"max_uses_per_user"`
        CurrentUses            int           `json:"current_uses" db:"current_uses"`
        ValidFrom              time.Time     `json:"valid_from" db:"valid_from"`
        ValidUntil             time.Time     `json:"valid_until" db:"valid_until"`
        Active                 bool          `json:"is_active" db:"is_active"`
        ApplicableVehicleTypes []VehicleType `json:"applicable_vehicle_types" db:"applicable_vehicle_types"`
        ApplicableCities       []string      `json:"applicable_cities" db:"applicable_cities"`
        FirstRideOnly          bool          `json:"first_ride_only" db:"first_ride_only"`
        CreatedAt              time.Time     `json:"created_at" db:"created_at"`
        UpdatedAt              time.Time     `json:"updated_at" db:"updated_at"`
}

// NewMoney creates a new Money instance
func NewMoney(amountCents int64, currency string) Money <span class="cov0" title="0">{
        return Money{
                Amount:   amountCents,
                Currency: currency,
        }
}</span>

// NewPricingRule creates a new pricing rule
func NewPricingRule(name string, vehicleType VehicleType, city *string) *PricingRule <span class="cov0" title="0">{
        return &amp;PricingRule{
                ID:              generateID(),
                Name:            name,
                VehicleType:     vehicleType,
                City:            city,
                TimeMultipliers: make(map[string]float64),
                DayMultipliers:  make(map[string]float64),
                ValidFrom:       time.Now(),
                IsActive:        true,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }
}</span>

// NewSurgePricing creates a new surge pricing instance
func NewSurgePricing(locationGeohash string, vehicleType VehicleType, multiplier float64, durationMinutes int) *SurgePricing <span class="cov0" title="0">{
        now := time.Now()
        return &amp;SurgePricing{
                ID:              generateID(),
                LocationGeohash: locationGeohash,
                VehicleType:     vehicleType,
                Multiplier:      multiplier,
                StartsAt:        now,
                ExpiresAt:       now.Add(time.Duration(durationMinutes) * time.Minute),
                Active:          true,
                CreatedAt:       now,
                UpdatedAt:       now,
        }
}</span>

// NewPromoCode creates a new promo code
func NewPromoCode(code, discountType string, discountValue float64) *PromoCode <span class="cov0" title="0">{
        return &amp;PromoCode{
                ID:             generateID(),
                Code:           code,
                DiscountType:   discountType,
                DiscountValue:  discountValue,
                MaxUsesPerUser: 1,
                CurrentUses:    0,
                ValidFrom:      time.Now(),
                ValidUntil:     time.Now().AddDate(0, 1, 0), // Valid for 1 month by default
                Active:         true,
                FirstRideOnly:  false,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }
}</span>

// ToFloat64 converts Money to float64 (in major currency units)
func (m Money) ToFloat64() float64 <span class="cov0" title="0">{
        return float64(m.Amount) / 100.0
}</span>

// Add adds another Money amount (must be same currency)
func (m Money) Add(other Money) Money <span class="cov0" title="0">{
        if m.Currency != other.Currency </span><span class="cov0" title="0">{
                return m // Return original if currencies don't match
        }</span>
        <span class="cov0" title="0">return Money{
                Amount:   m.Amount + other.Amount,
                Currency: m.Currency,
        }</span>
}

// Subtract subtracts another Money amount (must be same currency)
func (m Money) Subtract(other Money) Money <span class="cov0" title="0">{
        if m.Currency != other.Currency </span><span class="cov0" title="0">{
                return m // Return original if currencies don't match
        }</span>
        <span class="cov0" title="0">return Money{
                Amount:   m.Amount - other.Amount,
                Currency: m.Currency,
        }</span>
}

// Multiply multiplies the money amount by a factor
func (m Money) Multiply(factor float64) Money <span class="cov0" title="0">{
        return Money{
                Amount:   int64(float64(m.Amount) * factor),
                Currency: m.Currency,
        }
}</span>

// IsZero returns true if the amount is zero
func (m Money) IsZero() bool <span class="cov0" title="0">{
        return m.Amount == 0
}</span>

// IsPositive returns true if the amount is positive
func (m Money) IsPositive() bool <span class="cov0" title="0">{
        return m.Amount &gt; 0
}</span>

// IsNegative returns true if the amount is negative
func (m Money) IsNegative() bool <span class="cov0" title="0">{
        return m.Amount &lt; 0
}</span>

// Formatted returns a formatted string representation
func (m Money) Formatted() string <span class="cov0" title="0">{
        switch m.Currency </span>{
        case "USD":<span class="cov0" title="0">
                return fmt.Sprintf("$%.2f", m.ToFloat64())</span>
        case "EUR":<span class="cov0" title="0">
                return fmt.Sprintf("%.2f", m.ToFloat64())</span>
        case "GBP":<span class="cov0" title="0">
                return fmt.Sprintf("%.2f", m.ToFloat64())</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%.2f %s", m.ToFloat64(), m.Currency)</span>
        }
}

// IsCurrentlyActive returns true if the pricing rule is currently active
func (pr *PricingRule) IsCurrentlyActive() bool <span class="cov0" title="0">{
        if !pr.IsActive </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if now.Before(pr.ValidFrom) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if pr.ValidUntil != nil &amp;&amp; now.After(*pr.ValidUntil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// GetTimeMultiplier returns the time-based multiplier for the current hour
func (pr *PricingRule) GetTimeMultiplier(hour int) float64 <span class="cov0" title="0">{
        if multiplier, exists := pr.TimeMultipliers[fmt.Sprintf("%d", hour)]; exists </span><span class="cov0" title="0">{
                return multiplier
        }</span>
        <span class="cov0" title="0">return 1.0</span> // Default multiplier
}

// GetDayMultiplier returns the day-based multiplier for the current day
func (pr *PricingRule) GetDayMultiplier(weekday time.Weekday) float64 <span class="cov0" title="0">{
        dayName := weekday.String()
        if multiplier, exists := pr.DayMultipliers[dayName]; exists </span><span class="cov0" title="0">{
                return multiplier
        }</span>
        <span class="cov0" title="0">return 1.0</span> // Default multiplier
}

// SetTimeMultiplier sets a time-based multiplier
func (pr *PricingRule) SetTimeMultiplier(hour int, multiplier float64) <span class="cov0" title="0">{
        if pr.TimeMultipliers == nil </span><span class="cov0" title="0">{
                pr.TimeMultipliers = make(map[string]float64)
        }</span>
        <span class="cov0" title="0">pr.TimeMultipliers[fmt.Sprintf("%d", hour)] = multiplier
        pr.UpdatedAt = time.Now()</span>
}

// SetDayMultiplier sets a day-based multiplier
func (pr *PricingRule) SetDayMultiplier(weekday time.Weekday, multiplier float64) <span class="cov0" title="0">{
        if pr.DayMultipliers == nil </span><span class="cov0" title="0">{
                pr.DayMultipliers = make(map[string]float64)
        }</span>
        <span class="cov0" title="0">pr.DayMultipliers[weekday.String()] = multiplier
        pr.UpdatedAt = time.Now()</span>
}

// IsCurrentlyActive returns true if the surge pricing is currently active
func (sp *SurgePricing) IsCurrentlyActive() bool <span class="cov0" title="0">{
        if !sp.Active </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()
        return now.After(sp.StartsAt) &amp;&amp; now.Before(sp.ExpiresAt)</span>
}

// Extend extends the surge pricing duration
func (sp *SurgePricing) Extend(additionalMinutes int) <span class="cov0" title="0">{
        sp.ExpiresAt = sp.ExpiresAt.Add(time.Duration(additionalMinutes) * time.Minute)
        sp.UpdatedAt = time.Now()
}</span>

// UpdateMultiplier updates the surge multiplier
func (sp *SurgePricing) UpdateMultiplier(multiplier float64) <span class="cov0" title="0">{
        sp.Multiplier = multiplier
        sp.UpdatedAt = time.Now()
}</span>

// IsValid returns true if the promo code is currently valid
func (pc *PromoCode) IsValid() bool <span class="cov0" title="0">{
        if !pc.Active </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">now := time.Now()
        if now.Before(pc.ValidFrom) || now.After(pc.ValidUntil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if pc.MaxUses != nil &amp;&amp; pc.CurrentUses &gt;= *pc.MaxUses </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// CanBeUsedBy returns true if the promo code can be used by the specified user
func (pc *PromoCode) CanBeUsedBy(userID string, userUsageCount int, isFirstRide bool) bool <span class="cov0" title="0">{
        if !pc.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if userUsageCount &gt;= pc.MaxUsesPerUser </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if pc.FirstRideOnly &amp;&amp; !isFirstRide </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// CalculateDiscount calculates the discount amount for a given trip amount
func (pc *PromoCode) CalculateDiscount(tripAmountCents int64) int64 <span class="cov0" title="0">{
        if !pc.IsValid() </span><span class="cov0" title="0">{
                return 0
        }</span>

        // Check minimum trip amount
        <span class="cov0" title="0">if pc.MinTripAmountCents != nil &amp;&amp; tripAmountCents &lt; *pc.MinTripAmountCents </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">var discountCents int64

        switch pc.DiscountType </span>{
        case "percentage":<span class="cov0" title="0">
                discountCents = int64(float64(tripAmountCents) * pc.DiscountValue / 100.0)</span>
        case "fixed_amount":<span class="cov0" title="0">
                discountCents = int64(pc.DiscountValue * 100)</span> // Convert to cents
        default:<span class="cov0" title="0">
                return 0</span>
        }

        // Apply maximum discount limit
        <span class="cov0" title="0">if pc.MaxDiscountCents != nil &amp;&amp; discountCents &gt; *pc.MaxDiscountCents </span><span class="cov0" title="0">{
                discountCents = *pc.MaxDiscountCents
        }</span>

        // Discount cannot exceed trip amount
        <span class="cov0" title="0">if discountCents &gt; tripAmountCents </span><span class="cov0" title="0">{
                discountCents = tripAmountCents
        }</span>

        <span class="cov0" title="0">return discountCents</span>
}

// IncrementUsage increments the usage count
func (pc *PromoCode) IncrementUsage() <span class="cov0" title="0">{
        pc.CurrentUses++
        pc.UpdatedAt = time.Now()
}</span>

// IsApplicableForVehicleType checks if the promo code is applicable for the vehicle type
func (pc *PromoCode) IsApplicableForVehicleType(vehicleType VehicleType) bool <span class="cov0" title="0">{
        if len(pc.ApplicableVehicleTypes) == 0 </span><span class="cov0" title="0">{
                return true // Applicable to all vehicle types
        }</span>

        <span class="cov0" title="0">for _, applicableType := range pc.ApplicableVehicleTypes </span><span class="cov0" title="0">{
                if applicableType == vehicleType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsApplicableForCity checks if the promo code is applicable for the city
func (pc *PromoCode) IsApplicableForCity(city string) bool <span class="cov0" title="0">{
        if len(pc.ApplicableCities) == 0 </span><span class="cov0" title="0">{
                return true // Applicable to all cities
        }</span>

        <span class="cov0" title="0">for _, applicableCity := range pc.ApplicableCities </span><span class="cov0" title="0">{
                if applicableCity == city </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package models

import (
        "encoding/json"
        "time"
)

// TripStatus represents the current status of a trip
type TripStatus string

const (
        TripStatusRequested      TripStatus = "requested"
        TripStatusMatched        TripStatus = "matched"
        TripStatusDriverAssigned TripStatus = "driver_assigned"
        TripStatusDriverArriving TripStatus = "driver_arriving"
        TripStatusDriverArrived  TripStatus = "driver_arrived"
        TripStatusTripStarted    TripStatus = "trip_started"
        TripStatusInProgress     TripStatus = "in_progress"
        TripStatusCompleted      TripStatus = "completed"
        TripStatusCancelled      TripStatus = "cancelled"
        TripStatusFailed         TripStatus = "failed"
)

// Trip represents a trip in the rideshare platform
type Trip struct {
        ID                       string      `json:"id" db:"id"`
        RiderID                  string      `json:"rider_id" db:"rider_id"`
        DriverID                 *string     `json:"driver_id" db:"driver_id"`
        VehicleID                *string     `json:"vehicle_id" db:"vehicle_id"`
        PickupLocation           Location    `json:"pickup_location" db:"pickup_location"`
        Destination              Location    `json:"destination" db:"destination"`
        ActualRoute              *[]Location `json:"actual_route,omitempty" db:"actual_route"`
        Status                   TripStatus  `json:"status" db:"status"`
        EstimatedFareCents       *int64      `json:"estimated_fare_cents" db:"estimated_fare_cents"`
        ActualFareCents          *int64      `json:"actual_fare_cents" db:"actual_fare_cents"`
        Currency                 string      `json:"currency" db:"currency"`
        EstimatedDistanceKm      *float64    `json:"estimated_distance_km" db:"estimated_distance_km"`
        ActualDistanceKm         *float64    `json:"actual_distance_km" db:"actual_distance_km"`
        EstimatedDurationSeconds *int        `json:"estimated_duration_seconds" db:"estimated_duration_seconds"`
        ActualDurationSeconds    *int        `json:"actual_duration_seconds" db:"actual_duration_seconds"`
        RequestedAt              time.Time   `json:"requested_at" db:"requested_at"`
        MatchedAt                *time.Time  `json:"matched_at" db:"matched_at"`
        DriverAssignedAt         *time.Time  `json:"driver_assigned_at" db:"driver_assigned_at"`
        DriverArrivedAt          *time.Time  `json:"driver_arrived_at" db:"driver_arrived_at"`
        StartedAt                *time.Time  `json:"started_at" db:"started_at"`
        CompletedAt              *time.Time  `json:"completed_at" db:"completed_at"`
        CancelledBy              *string     `json:"cancelled_by" db:"cancelled_by"`
        CancellationReason       *string     `json:"cancellation_reason" db:"cancellation_reason"`
        PassengerCount           int         `json:"passenger_count" db:"passenger_count"`
        SpecialRequests          *string     `json:"special_requests" db:"special_requests"`
        PromoCode                *string     `json:"promo_code" db:"promo_code"`
        CreatedAt                time.Time   `json:"created_at" db:"created_at"`
        UpdatedAt                time.Time   `json:"updated_at" db:"updated_at"`
}

// TripEvent represents an event in the trip lifecycle for event sourcing
type TripEvent struct {
        ID           string                 `json:"id" db:"id"`
        TripID       string                 `json:"trip_id" db:"trip_id"`
        EventType    string                 `json:"event_type" db:"event_type"`
        EventData    map[string]interface{} `json:"event_data" db:"event_data"`
        EventVersion int                    `json:"event_version" db:"event_version"`
        UserID       *string                `json:"user_id" db:"user_id"`
        Timestamp    time.Time              `json:"timestamp" db:"timestamp"`
        Metadata     map[string]string      `json:"metadata" db:"metadata"`
}

// NewTrip creates a new trip with default values
func NewTrip(riderID string, pickupLocation, destination Location, passengerCount int) *Trip <span class="cov0" title="0">{
        return &amp;Trip{
                ID:             generateID(),
                RiderID:        riderID,
                PickupLocation: pickupLocation,
                Destination:    destination,
                Status:         TripStatusRequested,
                Currency:       "USD",
                PassengerCount: passengerCount,
                RequestedAt:    time.Now(),
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }
}</span>

// NewTripEvent creates a new trip event
func NewTripEvent(tripID, eventType string, eventData map[string]interface{}, userID *string) *TripEvent <span class="cov0" title="0">{
        return &amp;TripEvent{
                ID:        generateID(),
                TripID:    tripID,
                EventType: eventType,
                EventData: eventData,
                UserID:    userID,
                Timestamp: time.Now(),
                Metadata:  make(map[string]string),
        }
}</span>

// IsActive returns true if the trip is in an active state
func (t *Trip) IsActive() bool <span class="cov0" title="0">{
        activeStatuses := []TripStatus{
                TripStatusRequested,
                TripStatusMatched,
                TripStatusDriverAssigned,
                TripStatusDriverArriving,
                TripStatusDriverArrived,
                TripStatusTripStarted,
                TripStatusInProgress,
        }

        for _, status := range activeStatuses </span><span class="cov0" title="0">{
                if t.Status == status </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsCompleted returns true if the trip is completed
func (t *Trip) IsCompleted() bool <span class="cov0" title="0">{
        return t.Status == TripStatusCompleted
}</span>

// IsCancelled returns true if the trip is cancelled
func (t *Trip) IsCancelled() bool <span class="cov0" title="0">{
        return t.Status == TripStatusCancelled
}</span>

// HasDriver returns true if the trip has a driver assigned
func (t *Trip) HasDriver() bool <span class="cov0" title="0">{
        return t.DriverID != nil
}</span>

// HasVehicle returns true if the trip has a vehicle assigned
func (t *Trip) HasVehicle() bool <span class="cov0" title="0">{
        return t.VehicleID != nil
}</span>

// UpdateStatus updates the trip status and sets appropriate timestamps
func (t *Trip) UpdateStatus(status TripStatus, userID *string) *TripEvent <span class="cov0" title="0">{
        oldStatus := t.Status
        t.Status = status
        t.UpdatedAt = time.Now()

        // Set appropriate timestamps based on status
        now := time.Now()
        switch status </span>{
        case TripStatusMatched:<span class="cov0" title="0">
                t.MatchedAt = &amp;now</span>
        case TripStatusDriverAssigned:<span class="cov0" title="0">
                t.DriverAssignedAt = &amp;now</span>
        case TripStatusDriverArrived:<span class="cov0" title="0">
                t.DriverArrivedAt = &amp;now</span>
        case TripStatusTripStarted:<span class="cov0" title="0">
                t.StartedAt = &amp;now</span>
        case TripStatusCompleted:<span class="cov0" title="0">
                t.CompletedAt = &amp;now</span>
        }

        // Create event
        <span class="cov0" title="0">eventData := map[string]interface{}{
                "old_status": string(oldStatus),
                "new_status": string(status),
                "timestamp":  now,
        }

        return NewTripEvent(t.ID, "status_changed", eventData, userID)</span>
}

// AssignDriver assigns a driver and vehicle to the trip
func (t *Trip) AssignDriver(driverID, vehicleID string, userID *string) *TripEvent <span class="cov0" title="0">{
        t.DriverID = &amp;driverID
        t.VehicleID = &amp;vehicleID
        t.UpdatedAt = time.Now()

        eventData := map[string]interface{}{
                "driver_id":  driverID,
                "vehicle_id": vehicleID,
                "timestamp":  time.Now(),
        }

        return NewTripEvent(t.ID, "driver_assigned", eventData, userID)
}</span>

// SetEstimatedFare sets the estimated fare for the trip
func (t *Trip) SetEstimatedFare(fareCents int64) <span class="cov0" title="0">{
        t.EstimatedFareCents = &amp;fareCents
        t.UpdatedAt = time.Now()
}</span>

// SetActualFare sets the actual fare for the trip
func (t *Trip) SetActualFare(fareCents int64) <span class="cov0" title="0">{
        t.ActualFareCents = &amp;fareCents
        t.UpdatedAt = time.Now()
}</span>

// SetEstimatedDistance sets the estimated distance for the trip
func (t *Trip) SetEstimatedDistance(distanceKm float64) <span class="cov0" title="0">{
        t.EstimatedDistanceKm = &amp;distanceKm
        t.UpdatedAt = time.Now()
}</span>

// SetActualDistance sets the actual distance for the trip
func (t *Trip) SetActualDistance(distanceKm float64) <span class="cov0" title="0">{
        t.ActualDistanceKm = &amp;distanceKm
        t.UpdatedAt = time.Now()
}</span>

// SetEstimatedDuration sets the estimated duration for the trip
func (t *Trip) SetEstimatedDuration(durationSeconds int) <span class="cov0" title="0">{
        t.EstimatedDurationSeconds = &amp;durationSeconds
        t.UpdatedAt = time.Now()
}</span>

// SetActualDuration sets the actual duration for the trip
func (t *Trip) SetActualDuration(durationSeconds int) <span class="cov0" title="0">{
        t.ActualDurationSeconds = &amp;durationSeconds
        t.UpdatedAt = time.Now()
}</span>

// Cancel cancels the trip with a reason
func (t *Trip) Cancel(cancelledBy, reason string, userID *string) *TripEvent <span class="cov0" title="0">{
        t.Status = TripStatusCancelled
        t.CancelledBy = &amp;cancelledBy
        t.CancellationReason = &amp;reason
        t.UpdatedAt = time.Now()

        eventData := map[string]interface{}{
                "cancelled_by": cancelledBy,
                "reason":       reason,
                "timestamp":    time.Now(),
        }

        return NewTripEvent(t.ID, "trip_cancelled", eventData, userID)
}</span>

// AddRoutePoint adds a point to the actual route
func (t *Trip) AddRoutePoint(location Location) <span class="cov0" title="0">{
        if t.ActualRoute == nil </span><span class="cov0" title="0">{
                t.ActualRoute = &amp;[]Location{}
        }</span>
        <span class="cov0" title="0">*t.ActualRoute = append(*t.ActualRoute, location)
        t.UpdatedAt = time.Now()</span>
}

// GetDuration returns the trip duration in seconds
func (t *Trip) GetDuration() *int <span class="cov0" title="0">{
        if t.StartedAt != nil &amp;&amp; t.CompletedAt != nil </span><span class="cov0" title="0">{
                duration := int(t.CompletedAt.Sub(*t.StartedAt).Seconds())
                return &amp;duration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDistance returns the distance between pickup and destination
func (t *Trip) GetDistance() float64 <span class="cov0" title="0">{
        return t.PickupLocation.DistanceTo(&amp;t.Destination)
}</span>

// SetPromoCode sets the promo code for the trip
func (t *Trip) SetPromoCode(promoCode string) <span class="cov0" title="0">{
        t.PromoCode = &amp;promoCode
        t.UpdatedAt = time.Now()
}</span>

// SetSpecialRequests sets special requests for the trip
func (t *Trip) SetSpecialRequests(requests string) <span class="cov0" title="0">{
        t.SpecialRequests = &amp;requests
        t.UpdatedAt = time.Now()
}</span>

// MarshalEventData marshals event data to JSON
func (te *TripEvent) MarshalEventData() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(te.EventData)
}</span>

// UnmarshalEventData unmarshals event data from JSON
func (te *TripEvent) UnmarshalEventData(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, &amp;te.EventData)
}</span>

// IsValidTripStatus checks if a trip status is valid
func IsValidTripStatus(status string) bool <span class="cov0" title="0">{
        validStatuses := []TripStatus{
                TripStatusRequested,
                TripStatusMatched,
                TripStatusDriverAssigned,
                TripStatusDriverArriving,
                TripStatusDriverArrived,
                TripStatusTripStarted,
                TripStatusInProgress,
                TripStatusCompleted,
                TripStatusCancelled,
                TripStatusFailed,
        }

        for _, validStatus := range validStatuses </span><span class="cov0" title="0">{
                if TripStatus(status) == validStatus </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// GetTripStatuses returns all valid trip statuses
func GetTripStatuses() []TripStatus <span class="cov0" title="0">{
        return []TripStatus{
                TripStatusRequested,
                TripStatusMatched,
                TripStatusDriverAssigned,
                TripStatusDriverArriving,
                TripStatusDriverArrived,
                TripStatusTripStarted,
                TripStatusInProgress,
                TripStatusCompleted,
                TripStatusCancelled,
                TripStatusFailed,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package models

import (
        "crypto/rand"
        "encoding/hex"
        "time"
)

// generateID generates a simple ID for models
func generateID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// UserType represents the type of user in the system
type UserType string

const (
        UserTypeRider  UserType = "rider"
        UserTypeDriver UserType = "driver"
        UserTypeAdmin  UserType = "admin"
)

// UserStatus represents the current status of a user
type UserStatus string

const (
        UserStatusInactive  UserStatus = "inactive"
        UserStatusActive    UserStatus = "active"
        UserStatusSuspended UserStatus = "suspended"
        UserStatusBanned    UserStatus = "banned"
)

// DriverStatus represents the current status of a driver
type DriverStatus string

const (
        DriverStatusOffline DriverStatus = "offline"
        DriverStatusOnline  DriverStatus = "online"
        DriverStatusBusy    DriverStatus = "busy"
        DriverStatusBreak   DriverStatus = "break"
)

// User represents a user in the rideshare platform
type User struct {
        ID              string     `json:"id" db:"id"`
        Email           string     `json:"email" db:"email"`
        Phone           string     `json:"phone" db:"phone"`
        PasswordHash    string     `json:"-" db:"password_hash"`
        FirstName       string     `json:"first_name" db:"first_name"`
        LastName        string     `json:"last_name" db:"last_name"`
        UserType        UserType   `json:"user_type" db:"user_type"`
        Status          UserStatus `json:"status" db:"status"`
        ProfileImageURL string     `json:"profile_image_url" db:"profile_image_url"`
        EmailVerified   bool       `json:"email_verified" db:"email_verified"`
        PhoneVerified   bool       `json:"phone_verified" db:"phone_verified"`
        CreatedAt       time.Time  `json:"created_at" db:"created_at"`
        UpdatedAt       time.Time  `json:"updated_at" db:"updated_at"`
}

// Driver represents a driver profile
type Driver struct {
        UserID                  string       `json:"user_id" db:"user_id"`
        LicenseNumber           string       `json:"license_number" db:"license_number"`
        LicenseExpiry           time.Time    `json:"license_expiry" db:"license_expiry"`
        Status                  DriverStatus `json:"status" db:"status"`
        Rating                  float64      `json:"rating" db:"rating"`
        TotalTrips              int          `json:"total_trips" db:"total_trips"`
        TotalEarningsCents      int64        `json:"total_earnings_cents" db:"total_earnings_cents"`
        CurrentLatitude         *float64     `json:"current_latitude" db:"current_latitude"`
        CurrentLongitude        *float64     `json:"current_longitude" db:"current_longitude"`
        CurrentLocationAccuracy *float64     `json:"current_location_accuracy" db:"current_location_accuracy"`
        LastLocationUpdate      *time.Time   `json:"last_location_update" db:"last_location_update"`
        BackgroundCheckStatus   string       `json:"background_check_status" db:"background_check_status"`
        BackgroundCheckDate     *time.Time   `json:"background_check_date" db:"background_check_date"`
        CreatedAt               time.Time    `json:"created_at" db:"created_at"`
        UpdatedAt               time.Time    `json:"updated_at" db:"updated_at"`
}

// NewUser creates a new user with default values
func NewUser(email, phone, firstName, lastName string, userType UserType) *User <span class="cov0" title="0">{
        return &amp;User{
                ID:            generateID(),
                Email:         email,
                Phone:         phone,
                FirstName:     firstName,
                LastName:      lastName,
                UserType:      userType,
                Status:        UserStatusActive,
                EmailVerified: false,
                PhoneVerified: false,
                CreatedAt:     time.Now(),
                UpdatedAt:     time.Now(),
        }
}</span>

// NewDriver creates a new driver profile
func NewDriver(userID, licenseNumber string, licenseExpiry time.Time) *Driver <span class="cov0" title="0">{
        return &amp;Driver{
                UserID:                userID,
                LicenseNumber:         licenseNumber,
                LicenseExpiry:         licenseExpiry,
                Status:                DriverStatusOffline,
                Rating:                5.0,
                TotalTrips:            0,
                TotalEarningsCents:    0,
                BackgroundCheckStatus: "pending",
                CreatedAt:             time.Now(),
                UpdatedAt:             time.Now(),
        }
}</span>

// FullName returns the user's full name
func (u *User) FullName() string <span class="cov0" title="0">{
        return u.FirstName + " " + u.LastName
}</span>

// IsActive returns true if the user is active
func (u *User) IsActive() bool <span class="cov0" title="0">{
        return u.Status == UserStatusActive
}</span>

// IsDriver returns true if the user is a driver
func (u *User) IsDriver() bool <span class="cov0" title="0">{
        return u.UserType == UserTypeDriver
}</span>

// IsRider returns true if the user is a rider
func (u *User) IsRider() bool <span class="cov0" title="0">{
        return u.UserType == UserTypeRider
}</span>

// IsOnline returns true if the driver is online
func (d *Driver) IsOnline() bool <span class="cov0" title="0">{
        return d.Status == DriverStatusOnline
}</span>

// IsAvailable returns true if the driver is available for trips
func (d *Driver) IsAvailable() bool <span class="cov0" title="0">{
        return d.Status == DriverStatusOnline
}</span>

// HasCurrentLocation returns true if the driver has a current location
func (d *Driver) HasCurrentLocation() bool <span class="cov0" title="0">{
        return d.CurrentLatitude != nil &amp;&amp; d.CurrentLongitude != nil
}</span>

// GetCurrentLocation returns the driver's current location
func (d *Driver) GetCurrentLocation() *Location <span class="cov0" title="0">{
        if !d.HasCurrentLocation() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">location := &amp;Location{
                Latitude:  *d.CurrentLatitude,
                Longitude: *d.CurrentLongitude,
        }

        if d.CurrentLocationAccuracy != nil </span><span class="cov0" title="0">{
                location.Accuracy = *d.CurrentLocationAccuracy
        }</span>

        <span class="cov0" title="0">if d.LastLocationUpdate != nil </span><span class="cov0" title="0">{
                location.Timestamp = *d.LastLocationUpdate
        }</span>

        <span class="cov0" title="0">return location</span>
}

// UpdateLocation updates the driver's current location
func (d *Driver) UpdateLocation(lat, lng, accuracy float64) <span class="cov0" title="0">{
        d.CurrentLatitude = &amp;lat
        d.CurrentLongitude = &amp;lng
        d.CurrentLocationAccuracy = &amp;accuracy
        now := time.Now()
        d.LastLocationUpdate = &amp;now
        d.UpdatedAt = now
}</span>

// UpdateStatus updates the driver's status
func (d *Driver) UpdateStatus(status DriverStatus) <span class="cov0" title="0">{
        d.Status = status
        d.UpdatedAt = time.Now()
}</span>

// UpdateRating updates the driver's rating
func (d *Driver) UpdateRating(newRating float64, totalRatings int) <span class="cov0" title="0">{
        // Calculate weighted average
        currentTotal := d.Rating * float64(d.TotalTrips)
        d.Rating = (currentTotal + newRating) / float64(d.TotalTrips+1)
        d.UpdatedAt = time.Now()
}</span>

// AddEarnings adds earnings to the driver's total
func (d *Driver) AddEarnings(amountCents int64) <span class="cov0" title="0">{
        d.TotalEarningsCents += amountCents
        d.UpdatedAt = time.Now()
}</span>

// IncrementTripCount increments the driver's trip count
func (d *Driver) IncrementTripCount() <span class="cov0" title="0">{
        d.TotalTrips++
        d.UpdatedAt = time.Now()
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package models

import (
        "time"
)

// VehicleType represents the type of vehicle
type VehicleType string

const (
        VehicleTypeSedan     VehicleType = "sedan"
        VehicleTypeSUV       VehicleType = "suv"
        VehicleTypeHatchback VehicleType = "hatchback"
        VehicleTypeLuxury    VehicleType = "luxury"
        VehicleTypeVan       VehicleType = "van"
)

// VehicleStatus represents the current status of a vehicle
type VehicleStatus string

const (
        VehicleStatusInactive    VehicleStatus = "inactive"
        VehicleStatusActive      VehicleStatus = "active"
        VehicleStatusMaintenance VehicleStatus = "maintenance"
        VehicleStatusRetired     VehicleStatus = "retired"
)

// Vehicle represents a vehicle in the rideshare platform
type Vehicle struct {
        ID                    string        `json:"id" db:"id"`
        DriverID              string        `json:"driver_id" db:"driver_id"`
        Make                  string        `json:"make" db:"make"`
        Model                 string        `json:"model" db:"model"`
        Year                  int           `json:"year" db:"year"`
        Color                 string        `json:"color" db:"color"`
        LicensePlate          string        `json:"license_plate" db:"license_plate"`
        VehicleType           VehicleType   `json:"vehicle_type" db:"vehicle_type"`
        Status                VehicleStatus `json:"status" db:"status"`
        Capacity              int           `json:"capacity" db:"capacity"`
        InsurancePolicyNumber string        `json:"insurance_policy_number" db:"insurance_policy_number"`
        InsuranceExpiry       *time.Time    `json:"insurance_expiry" db:"insurance_expiry"`
        RegistrationExpiry    *time.Time    `json:"registration_expiry" db:"registration_expiry"`
        CreatedAt             time.Time     `json:"created_at" db:"created_at"`
        UpdatedAt             time.Time     `json:"updated_at" db:"updated_at"`
}

// NewVehicle creates a new vehicle with default values
func NewVehicle(driverID, make, model string, year int, color, licensePlate string, vehicleType VehicleType, capacity int) *Vehicle <span class="cov0" title="0">{
        return &amp;Vehicle{
                ID:           generateID(),
                DriverID:     driverID,
                Make:         make,
                Model:        model,
                Year:         year,
                Color:        color,
                LicensePlate: licensePlate,
                VehicleType:  vehicleType,
                Status:       VehicleStatusActive,
                Capacity:     capacity,
                CreatedAt:    time.Now(),
                UpdatedAt:    time.Now(),
        }
}</span>

// IsActive returns true if the vehicle is active
func (v *Vehicle) IsActive() bool <span class="cov0" title="0">{
        return v.Status == VehicleStatusActive
}</span>

// IsAvailable returns true if the vehicle is available for trips
func (v *Vehicle) IsAvailable() bool <span class="cov0" title="0">{
        return v.Status == VehicleStatusActive
}</span>

// UpdateStatus updates the vehicle's status
func (v *Vehicle) UpdateStatus(status VehicleStatus) <span class="cov0" title="0">{
        v.Status = status
        v.UpdatedAt = time.Now()
}</span>

// SetInsuranceInfo sets the vehicle's insurance information
func (v *Vehicle) SetInsuranceInfo(policyNumber string, expiry time.Time) <span class="cov0" title="0">{
        v.InsurancePolicyNumber = policyNumber
        v.InsuranceExpiry = &amp;expiry
        v.UpdatedAt = time.Now()
}</span>

// SetRegistrationExpiry sets the vehicle's registration expiry
func (v *Vehicle) SetRegistrationExpiry(expiry time.Time) <span class="cov0" title="0">{
        v.RegistrationExpiry = &amp;expiry
        v.UpdatedAt = time.Now()
}</span>

// IsInsuranceValid checks if the vehicle's insurance is valid
func (v *Vehicle) IsInsuranceValid() bool <span class="cov0" title="0">{
        if v.InsuranceExpiry == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return v.InsuranceExpiry.After(time.Now())</span>
}

// IsRegistrationValid checks if the vehicle's registration is valid
func (v *Vehicle) IsRegistrationValid() bool <span class="cov0" title="0">{
        if v.RegistrationExpiry == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return v.RegistrationExpiry.After(time.Now())</span>
}

// IsValidForService checks if the vehicle is valid for service
func (v *Vehicle) IsValidForService() bool <span class="cov0" title="0">{
        return v.IsActive() &amp;&amp; v.IsInsuranceValid() &amp;&amp; v.IsRegistrationValid()
}</span>

// GetDisplayName returns a display name for the vehicle
func (v *Vehicle) GetDisplayName() string <span class="cov0" title="0">{
        return v.Color + " " + v.Make + " " + v.Model
}</span>

// GetVehicleTypeCapacity returns the default capacity for a vehicle type
func GetVehicleTypeCapacity(vehicleType VehicleType) int <span class="cov0" title="0">{
        switch vehicleType </span>{
        case VehicleTypeSedan:<span class="cov0" title="0">
                return 4</span>
        case VehicleTypeSUV:<span class="cov0" title="0">
                return 6</span>
        case VehicleTypeHatchback:<span class="cov0" title="0">
                return 4</span>
        case VehicleTypeLuxury:<span class="cov0" title="0">
                return 4</span>
        case VehicleTypeVan:<span class="cov0" title="0">
                return 8</span>
        default:<span class="cov0" title="0">
                return 4</span>
        }
}

// IsValidVehicleType checks if a vehicle type is valid
func IsValidVehicleType(vehicleType string) bool <span class="cov0" title="0">{
        switch VehicleType(vehicleType) </span>{
        case VehicleTypeSedan, VehicleTypeSUV, VehicleTypeHatchback, VehicleTypeLuxury, VehicleTypeVan:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetVehicleTypes returns all valid vehicle types
func GetVehicleTypes() []VehicleType <span class="cov0" title="0">{
        return []VehicleType{
                VehicleTypeSedan,
                VehicleTypeSUV,
                VehicleTypeHatchback,
                VehicleTypeLuxury,
                VehicleTypeVan,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v3.21.12
// source: shared/proto/geo/geo.proto

package geo

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Location represents a geographical coordinate
type Location struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Latitude      float64                `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude     float64                `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
        Accuracy      float64                `protobuf:"fixed64,3,opt,name=accuracy,proto3" json:"accuracy,omitempty"` // accuracy in meters
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Address       string                 `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Location) Reset() <span class="cov0" title="0">{
        *x = Location{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Location) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Location) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Location) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Location) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetAccuracy() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Accuracy
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Location) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Distance calculation request
type DistanceRequest struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Origin            *Location              `protobuf:"bytes,1,opt,name=origin,proto3" json:"origin,omitempty"`
        Destination       *Location              `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
        CalculationMethod string                 `protobuf:"bytes,3,opt,name=calculation_method,json=calculationMethod,proto3" json:"calculation_method,omitempty"` // "haversine", "manhattan", "euclidean"
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *DistanceRequest) Reset() <span class="cov0" title="0">{
        *x = DistanceRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DistanceRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DistanceRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DistanceRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DistanceRequest.ProtoReflect.Descriptor instead.
func (*DistanceRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{1}
}</span>

func (x *DistanceRequest) GetOrigin() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Origin
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DistanceRequest) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DistanceRequest) GetCalculationMethod() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CalculationMethod
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Distance calculation response
type DistanceResponse struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        DistanceMeters    float64                `protobuf:"fixed64,1,opt,name=distance_meters,json=distanceMeters,proto3" json:"distance_meters,omitempty"`
        DistanceKm        float64                `protobuf:"fixed64,2,opt,name=distance_km,json=distanceKm,proto3" json:"distance_km,omitempty"`
        BearingDegrees    float64                `protobuf:"fixed64,3,opt,name=bearing_degrees,json=bearingDegrees,proto3" json:"bearing_degrees,omitempty"`
        CalculationMethod string                 `protobuf:"bytes,4,opt,name=calculation_method,json=calculationMethod,proto3" json:"calculation_method,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *DistanceResponse) Reset() <span class="cov0" title="0">{
        *x = DistanceResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DistanceResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DistanceResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DistanceResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DistanceResponse.ProtoReflect.Descriptor instead.
func (*DistanceResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{2}
}</span>

func (x *DistanceResponse) GetDistanceMeters() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceMeters
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DistanceResponse) GetDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DistanceResponse) GetBearingDegrees() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BearingDegrees
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DistanceResponse) GetCalculationMethod() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CalculationMethod
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ETA calculation request
type ETARequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Origin         *Location              `protobuf:"bytes,1,opt,name=origin,proto3" json:"origin,omitempty"`
        Destination    *Location              `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
        VehicleType    string                 `protobuf:"bytes,3,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"` // "car", "bike", "walking"
        DepartureTime  *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=departure_time,json=departureTime,proto3" json:"departure_time,omitempty"`
        IncludeTraffic bool                   `protobuf:"varint,5,opt,name=include_traffic,json=includeTraffic,proto3" json:"include_traffic,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *ETARequest) Reset() <span class="cov0" title="0">{
        *x = ETARequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ETARequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ETARequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ETARequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ETARequest.ProtoReflect.Descriptor instead.
func (*ETARequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ETARequest) GetOrigin() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Origin
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ETARequest) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ETARequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ETARequest) GetDepartureTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DepartureTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ETARequest) GetIncludeTraffic() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IncludeTraffic
        }</span>
        <span class="cov0" title="0">return false</span>
}

// ETA calculation response
type ETAResponse struct {
        state            protoimpl.MessageState `protogen:"open.v1"`
        DurationSeconds  int32                  `protobuf:"varint,1,opt,name=duration_seconds,json=durationSeconds,proto3" json:"duration_seconds,omitempty"`
        DistanceMeters   float64                `protobuf:"fixed64,2,opt,name=distance_meters,json=distanceMeters,proto3" json:"distance_meters,omitempty"`
        RouteSummary     string                 `protobuf:"bytes,3,opt,name=route_summary,json=routeSummary,proto3" json:"route_summary,omitempty"`
        Waypoints        []*Location            `protobuf:"bytes,4,rep,name=waypoints,proto3" json:"waypoints,omitempty"`
        EstimatedArrival *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=estimated_arrival,json=estimatedArrival,proto3" json:"estimated_arrival,omitempty"`
        unknownFields    protoimpl.UnknownFields
        sizeCache        protoimpl.SizeCache
}

func (x *ETAResponse) Reset() <span class="cov0" title="0">{
        *x = ETAResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ETAResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ETAResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ETAResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ETAResponse.ProtoReflect.Descriptor instead.
func (*ETAResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{4}
}</span>

func (x *ETAResponse) GetDurationSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DurationSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ETAResponse) GetDistanceMeters() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceMeters
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ETAResponse) GetRouteSummary() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RouteSummary
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ETAResponse) GetWaypoints() []*Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Waypoints
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ETAResponse) GetEstimatedArrival() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EstimatedArrival
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Nearby drivers request
type NearbyDriversRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Center        *Location              `protobuf:"bytes,1,opt,name=center,proto3" json:"center,omitempty"`
        RadiusKm      float64                `protobuf:"fixed64,2,opt,name=radius_km,json=radiusKm,proto3" json:"radius_km,omitempty"`
        Limit         int32                  `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
        VehicleTypes  []string               `protobuf:"bytes,4,rep,name=vehicle_types,json=vehicleTypes,proto3" json:"vehicle_types,omitempty"`
        OnlyAvailable bool                   `protobuf:"varint,5,opt,name=only_available,json=onlyAvailable,proto3" json:"only_available,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *NearbyDriversRequest) Reset() <span class="cov0" title="0">{
        *x = NearbyDriversRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NearbyDriversRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NearbyDriversRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NearbyDriversRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NearbyDriversRequest.ProtoReflect.Descriptor instead.
func (*NearbyDriversRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{5}
}</span>

func (x *NearbyDriversRequest) GetCenter() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Center
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *NearbyDriversRequest) GetRadiusKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RadiusKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NearbyDriversRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NearbyDriversRequest) GetVehicleTypes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleTypes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *NearbyDriversRequest) GetOnlyAvailable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OnlyAvailable
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Driver location information
type DriverLocation struct {
        state              protoimpl.MessageState `protogen:"open.v1"`
        DriverId           string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        VehicleId          string                 `protobuf:"bytes,2,opt,name=vehicle_id,json=vehicleId,proto3" json:"vehicle_id,omitempty"`
        Location           *Location              `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
        DistanceFromCenter float64                `protobuf:"fixed64,4,opt,name=distance_from_center,json=distanceFromCenter,proto3" json:"distance_from_center,omitempty"`
        Status             string                 `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"` // "online", "busy", "offline"
        VehicleType        string                 `protobuf:"bytes,6,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        Rating             float64                `protobuf:"fixed64,7,opt,name=rating,proto3" json:"rating,omitempty"`
        unknownFields      protoimpl.UnknownFields
        sizeCache          protoimpl.SizeCache
}

func (x *DriverLocation) Reset() <span class="cov0" title="0">{
        *x = DriverLocation{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DriverLocation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DriverLocation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DriverLocation) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DriverLocation.ProtoReflect.Descriptor instead.
func (*DriverLocation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{6}
}</span>

func (x *DriverLocation) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocation) GetVehicleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocation) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DriverLocation) GetDistanceFromCenter() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceFromCenter
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DriverLocation) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocation) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocation) GetRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Nearby drivers response
type NearbyDriversResponse struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Drivers        []*DriverLocation      `protobuf:"bytes,1,rep,name=drivers,proto3" json:"drivers,omitempty"`
        TotalCount     int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        SearchRadiusKm float64                `protobuf:"fixed64,3,opt,name=search_radius_km,json=searchRadiusKm,proto3" json:"search_radius_km,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *NearbyDriversResponse) Reset() <span class="cov0" title="0">{
        *x = NearbyDriversResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *NearbyDriversResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NearbyDriversResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NearbyDriversResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use NearbyDriversResponse.ProtoReflect.Descriptor instead.
func (*NearbyDriversResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{7}
}</span>

func (x *NearbyDriversResponse) GetDrivers() []*DriverLocation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Drivers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *NearbyDriversResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *NearbyDriversResponse) GetSearchRadiusKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SearchRadiusKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Update driver location request
type UpdateDriverLocationRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Location      *Location              `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
        Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
        VehicleId     string                 `protobuf:"bytes,4,opt,name=vehicle_id,json=vehicleId,proto3" json:"vehicle_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateDriverLocationRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateDriverLocationRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateDriverLocationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateDriverLocationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateDriverLocationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateDriverLocationRequest.ProtoReflect.Descriptor instead.
func (*UpdateDriverLocationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{8}
}</span>

func (x *UpdateDriverLocationRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateDriverLocationRequest) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateDriverLocationRequest) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateDriverLocationRequest) GetVehicleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Update driver location response
type UpdateDriverLocationResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateDriverLocationResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateDriverLocationResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateDriverLocationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateDriverLocationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateDriverLocationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateDriverLocationResponse.ProtoReflect.Descriptor instead.
func (*UpdateDriverLocationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UpdateDriverLocationResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateDriverLocationResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateDriverLocationResponse) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Geohash request
type GeohashRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Location      *Location              `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
        Precision     int32                  `protobuf:"varint,2,opt,name=precision,proto3" json:"precision,omitempty"` // 1-12, higher = more precise
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GeohashRequest) Reset() <span class="cov0" title="0">{
        *x = GeohashRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GeohashRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GeohashRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GeohashRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GeohashRequest.ProtoReflect.Descriptor instead.
func (*GeohashRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GeohashRequest) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GeohashRequest) GetPrecision() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Precision
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Geohash response
type GeohashResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Geohash       string                 `protobuf:"bytes,1,opt,name=geohash,proto3" json:"geohash,omitempty"`
        Center        *Location              `protobuf:"bytes,2,opt,name=center,proto3" json:"center,omitempty"`
        WidthMeters   float64                `protobuf:"fixed64,3,opt,name=width_meters,json=widthMeters,proto3" json:"width_meters,omitempty"`
        HeightMeters  float64                `protobuf:"fixed64,4,opt,name=height_meters,json=heightMeters,proto3" json:"height_meters,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GeohashResponse) Reset() <span class="cov0" title="0">{
        *x = GeohashResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GeohashResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GeohashResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GeohashResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GeohashResponse.ProtoReflect.Descriptor instead.
func (*GeohashResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GeohashResponse) GetGeohash() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Geohash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GeohashResponse) GetCenter() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Center
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GeohashResponse) GetWidthMeters() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WidthMeters
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GeohashResponse) GetHeightMeters() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HeightMeters
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Route optimization request
type RouteOptimizationRequest struct {
        state            protoimpl.MessageState `protogen:"open.v1"`
        Start            *Location              `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
        Waypoints        []*Location            `protobuf:"bytes,2,rep,name=waypoints,proto3" json:"waypoints,omitempty"`
        End              *Location              `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
        OptimizationType string                 `protobuf:"bytes,4,opt,name=optimization_type,json=optimizationType,proto3" json:"optimization_type,omitempty"` // "shortest", "fastest", "fuel_efficient"
        VehicleType      string                 `protobuf:"bytes,5,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        unknownFields    protoimpl.UnknownFields
        sizeCache        protoimpl.SizeCache
}

func (x *RouteOptimizationRequest) Reset() <span class="cov0" title="0">{
        *x = RouteOptimizationRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RouteOptimizationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RouteOptimizationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RouteOptimizationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RouteOptimizationRequest.ProtoReflect.Descriptor instead.
func (*RouteOptimizationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{12}
}</span>

func (x *RouteOptimizationRequest) GetStart() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Start
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RouteOptimizationRequest) GetWaypoints() []*Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Waypoints
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RouteOptimizationRequest) GetEnd() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.End
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RouteOptimizationRequest) GetOptimizationType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OptimizationType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RouteOptimizationRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Route optimization response
type RouteOptimizationResponse struct {
        state                    protoimpl.MessageState `protogen:"open.v1"`
        OptimizedRoute           []*Location            `protobuf:"bytes,1,rep,name=optimized_route,json=optimizedRoute,proto3" json:"optimized_route,omitempty"`
        TotalDistanceKm          float64                `protobuf:"fixed64,2,opt,name=total_distance_km,json=totalDistanceKm,proto3" json:"total_distance_km,omitempty"`
        EstimatedDurationSeconds int32                  `protobuf:"varint,3,opt,name=estimated_duration_seconds,json=estimatedDurationSeconds,proto3" json:"estimated_duration_seconds,omitempty"`
        OptimizationAlgorithm    string                 `protobuf:"bytes,4,opt,name=optimization_algorithm,json=optimizationAlgorithm,proto3" json:"optimization_algorithm,omitempty"`
        unknownFields            protoimpl.UnknownFields
        sizeCache                protoimpl.SizeCache
}

func (x *RouteOptimizationResponse) Reset() <span class="cov0" title="0">{
        *x = RouteOptimizationResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RouteOptimizationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RouteOptimizationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RouteOptimizationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RouteOptimizationResponse.ProtoReflect.Descriptor instead.
func (*RouteOptimizationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{13}
}</span>

func (x *RouteOptimizationResponse) GetOptimizedRoute() []*Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OptimizedRoute
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RouteOptimizationResponse) GetTotalDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalDistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RouteOptimizationResponse) GetEstimatedDurationSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EstimatedDurationSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RouteOptimizationResponse) GetOptimizationAlgorithm() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OptimizationAlgorithm
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Driver location update subscription request
type SubscribeToDriverLocationRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        AreaId        string                 `protobuf:"bytes,1,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`          // Geographic area to monitor (geohash or area identifier)
        RadiusKm      float64                `protobuf:"fixed64,2,opt,name=radius_km,json=radiusKm,proto3" json:"radius_km,omitempty"`  // Radius around the area
        DriverIds     []string               `protobuf:"bytes,3,rep,name=driver_ids,json=driverIds,proto3" json:"driver_ids,omitempty"` // Specific drivers to track (optional)
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToDriverLocationRequest) Reset() <span class="cov0" title="0">{
        *x = SubscribeToDriverLocationRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SubscribeToDriverLocationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubscribeToDriverLocationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubscribeToDriverLocationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubscribeToDriverLocationRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToDriverLocationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{14}
}</span>

func (x *SubscribeToDriverLocationRequest) GetAreaId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AreaId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubscribeToDriverLocationRequest) GetRadiusKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RadiusKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SubscribeToDriverLocationRequest) GetDriverIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Real-time driver location event
type DriverLocationEvent struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Location      *Location              `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
        Status        string                 `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"` // "available", "busy", "offline"
        VehicleId     string                 `protobuf:"bytes,4,opt,name=vehicle_id,json=vehicleId,proto3" json:"vehicle_id,omitempty"`
        SpeedKmh      float64                `protobuf:"fixed64,5,opt,name=speed_kmh,json=speedKmh,proto3" json:"speed_kmh,omitempty"`
        Heading       float64                `protobuf:"fixed64,6,opt,name=heading,proto3" json:"heading,omitempty"` // Direction in degrees
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Metadata      map[string]string      `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DriverLocationEvent) Reset() <span class="cov0" title="0">{
        *x = DriverLocationEvent{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DriverLocationEvent) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DriverLocationEvent) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DriverLocationEvent) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DriverLocationEvent.ProtoReflect.Descriptor instead.
func (*DriverLocationEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{15}
}</span>

func (x *DriverLocationEvent) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocationEvent) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DriverLocationEvent) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocationEvent) GetVehicleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocationEvent) GetSpeedKmh() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SpeedKmh
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DriverLocationEvent) GetHeading() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Heading
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DriverLocationEvent) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DriverLocationEvent) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Location tracking session request
type StartLocationTrackingRequest struct {
        state                 protoimpl.MessageState `protogen:"open.v1"`
        DriverId              string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        UpdateIntervalSeconds int32                  `protobuf:"varint,2,opt,name=update_interval_seconds,json=updateIntervalSeconds,proto3" json:"update_interval_seconds,omitempty"` // How often to send updates
        unknownFields         protoimpl.UnknownFields
        sizeCache             protoimpl.SizeCache
}

func (x *StartLocationTrackingRequest) Reset() <span class="cov0" title="0">{
        *x = StartLocationTrackingRequest{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StartLocationTrackingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StartLocationTrackingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StartLocationTrackingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StartLocationTrackingRequest.ProtoReflect.Descriptor instead.
func (*StartLocationTrackingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{16}
}</span>

func (x *StartLocationTrackingRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StartLocationTrackingRequest) GetUpdateIntervalSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdateIntervalSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Location tracking session response
type StartLocationTrackingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        SessionId     string                 `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StartLocationTrackingResponse) Reset() <span class="cov0" title="0">{
        *x = StartLocationTrackingResponse{}
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StartLocationTrackingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StartLocationTrackingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StartLocationTrackingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_geo_geo_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StartLocationTrackingResponse.ProtoReflect.Descriptor instead.
func (*StartLocationTrackingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_geo_geo_proto_rawDescGZIP(), []int{17}
}</span>

func (x *StartLocationTrackingResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *StartLocationTrackingResponse) GetSessionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SessionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StartLocationTrackingResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_shared_proto_geo_geo_proto protoreflect.FileDescriptor

const file_shared_proto_geo_geo_proto_rawDesc = "" +
        "\n" +
        "\x1ashared/proto/geo/geo.proto\x12\x03geo\x1a\x1fgoogle/protobuf/timestamp.proto\"\xb4\x01\n" +
        "\bLocation\x12\x1a\n" +
        "\blatitude\x18\x01 \x01(\x01R\blatitude\x12\x1c\n" +
        "\tlongitude\x18\x02 \x01(\x01R\tlongitude\x12\x1a\n" +
        "\baccuracy\x18\x03 \x01(\x01R\baccuracy\x128\n" +
        "\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x18\n" +
        "\aaddress\x18\x05 \x01(\tR\aaddress\"\x98\x01\n" +
        "\x0fDistanceRequest\x12%\n" +
        "\x06origin\x18\x01 \x01(\v2\r.geo.LocationR\x06origin\x12/\n" +
        "\vdestination\x18\x02 \x01(\v2\r.geo.LocationR\vdestination\x12-\n" +
        "\x12calculation_method\x18\x03 \x01(\tR\x11calculationMethod\"\xb4\x01\n" +
        "\x10DistanceResponse\x12'\n" +
        "\x0fdistance_meters\x18\x01 \x01(\x01R\x0edistanceMeters\x12\x1f\n" +
        "\vdistance_km\x18\x02 \x01(\x01R\n" +
        "distanceKm\x12'\n" +
        "\x0fbearing_degrees\x18\x03 \x01(\x01R\x0ebearingDegrees\x12-\n" +
        "\x12calculation_method\x18\x04 \x01(\tR\x11calculationMethod\"\xf3\x01\n" +
        "\n" +
        "ETARequest\x12%\n" +
        "\x06origin\x18\x01 \x01(\v2\r.geo.LocationR\x06origin\x12/\n" +
        "\vdestination\x18\x02 \x01(\v2\r.geo.LocationR\vdestination\x12!\n" +
        "\fvehicle_type\x18\x03 \x01(\tR\vvehicleType\x12A\n" +
        "\x0edeparture_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\rdepartureTime\x12'\n" +
        "\x0finclude_traffic\x18\x05 \x01(\bR\x0eincludeTraffic\"\xfc\x01\n" +
        "\vETAResponse\x12)\n" +
        "\x10duration_seconds\x18\x01 \x01(\x05R\x0fdurationSeconds\x12'\n" +
        "\x0fdistance_meters\x18\x02 \x01(\x01R\x0edistanceMeters\x12#\n" +
        "\rroute_summary\x18\x03 \x01(\tR\frouteSummary\x12+\n" +
        "\twaypoints\x18\x04 \x03(\v2\r.geo.LocationR\twaypoints\x12G\n" +
        "\x11estimated_arrival\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x10estimatedArrival\"\xbc\x01\n" +
        "\x14NearbyDriversRequest\x12%\n" +
        "\x06center\x18\x01 \x01(\v2\r.geo.LocationR\x06center\x12\x1b\n" +
        "\tradius_km\x18\x02 \x01(\x01R\bradiusKm\x12\x14\n" +
        "\x05limit\x18\x03 \x01(\x05R\x05limit\x12#\n" +
        "\rvehicle_types\x18\x04 \x03(\tR\fvehicleTypes\x12%\n" +
        "\x0eonly_available\x18\x05 \x01(\bR\ronlyAvailable\"\xfc\x01\n" +
        "\x0eDriverLocation\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x12\x1d\n" +
        "\n" +
        "vehicle_id\x18\x02 \x01(\tR\tvehicleId\x12)\n" +
        "\blocation\x18\x03 \x01(\v2\r.geo.LocationR\blocation\x120\n" +
        "\x14distance_from_center\x18\x04 \x01(\x01R\x12distanceFromCenter\x12\x16\n" +
        "\x06status\x18\x05 \x01(\tR\x06status\x12!\n" +
        "\fvehicle_type\x18\x06 \x01(\tR\vvehicleType\x12\x16\n" +
        "\x06rating\x18\a \x01(\x01R\x06rating\"\x91\x01\n" +
        "\x15NearbyDriversResponse\x12-\n" +
        "\adrivers\x18\x01 \x03(\v2\x13.geo.DriverLocationR\adrivers\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x12(\n" +
        "\x10search_radius_km\x18\x03 \x01(\x01R\x0esearchRadiusKm\"\x9c\x01\n" +
        "\x1bUpdateDriverLocationRequest\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x12)\n" +
        "\blocation\x18\x02 \x01(\v2\r.geo.LocationR\blocation\x12\x16\n" +
        "\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
        "\n" +
        "vehicle_id\x18\x04 \x01(\tR\tvehicleId\"\x8d\x01\n" +
        "\x1cUpdateDriverLocationResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\x129\n" +
        "\n" +
        "updated_at\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\"Y\n" +
        "\x0eGeohashRequest\x12)\n" +
        "\blocation\x18\x01 \x01(\v2\r.geo.LocationR\blocation\x12\x1c\n" +
        "\tprecision\x18\x02 \x01(\x05R\tprecision\"\x9a\x01\n" +
        "\x0fGeohashResponse\x12\x18\n" +
        "\ageohash\x18\x01 \x01(\tR\ageohash\x12%\n" +
        "\x06center\x18\x02 \x01(\v2\r.geo.LocationR\x06center\x12!\n" +
        "\fwidth_meters\x18\x03 \x01(\x01R\vwidthMeters\x12#\n" +
        "\rheight_meters\x18\x04 \x01(\x01R\fheightMeters\"\xdd\x01\n" +
        "\x18RouteOptimizationRequest\x12#\n" +
        "\x05start\x18\x01 \x01(\v2\r.geo.LocationR\x05start\x12+\n" +
        "\twaypoints\x18\x02 \x03(\v2\r.geo.LocationR\twaypoints\x12\x1f\n" +
        "\x03end\x18\x03 \x01(\v2\r.geo.LocationR\x03end\x12+\n" +
        "\x11optimization_type\x18\x04 \x01(\tR\x10optimizationType\x12!\n" +
        "\fvehicle_type\x18\x05 \x01(\tR\vvehicleType\"\xf4\x01\n" +
        "\x19RouteOptimizationResponse\x126\n" +
        "\x0foptimized_route\x18\x01 \x03(\v2\r.geo.LocationR\x0eoptimizedRoute\x12*\n" +
        "\x11total_distance_km\x18\x02 \x01(\x01R\x0ftotalDistanceKm\x12&lt;\n" +
        "\x1aestimated_duration_seconds\x18\x03 \x01(\x05R\x18estimatedDurationSeconds\x125\n" +
        "\x16optimization_algorithm\x18\x04 \x01(\tR\x15optimizationAlgorithm\"w\n" +
        " SubscribeToDriverLocationRequest\x12\x17\n" +
        "\aarea_id\x18\x01 \x01(\tR\x06areaId\x12\x1b\n" +
        "\tradius_km\x18\x02 \x01(\x01R\bradiusKm\x12\x1d\n" +
        "\n" +
        "driver_ids\x18\x03 \x03(\tR\tdriverIds\"\x86\x03\n" +
        "\x13DriverLocationEvent\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x12)\n" +
        "\blocation\x18\x02 \x01(\v2\r.geo.LocationR\blocation\x12\x16\n" +
        "\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
        "\n" +
        "vehicle_id\x18\x04 \x01(\tR\tvehicleId\x12\x1b\n" +
        "\tspeed_kmh\x18\x05 \x01(\x01R\bspeedKmh\x12\x18\n" +
        "\aheading\x18\x06 \x01(\x01R\aheading\x128\n" +
        "\ttimestamp\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12B\n" +
        "\bmetadata\x18\b \x03(\v2&amp;.geo.DriverLocationEvent.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"s\n" +
        "\x1cStartLocationTrackingRequest\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x126\n" +
        "\x17update_interval_seconds\x18\x02 \x01(\x05R\x15updateIntervalSeconds\"r\n" +
        "\x1dStartLocationTrackingResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x1d\n" +
        "\n" +
        "session_id\x18\x02 \x01(\tR\tsessionId\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage2\x80\x05\n" +
        "\x11GeospatialService\x12@\n" +
        "\x11CalculateDistance\x12\x14.geo.DistanceRequest\x1a\x15.geo.DistanceResponse\x121\n" +
        "\fCalculateETA\x12\x0f.geo.ETARequest\x1a\x10.geo.ETAResponse\x12J\n" +
        "\x11FindNearbyDrivers\x12\x19.geo.NearbyDriversRequest\x1a\x1a.geo.NearbyDriversResponse\x12[\n" +
        "\x14UpdateDriverLocation\x12 .geo.UpdateDriverLocationRequest\x1a!.geo.UpdateDriverLocationResponse\x12&lt;\n" +
        "\x0fGenerateGeohash\x12\x13.geo.GeohashRequest\x1a\x14.geo.GeohashResponse\x12N\n" +
        "\rOptimizeRoute\x12\x1d.geo.RouteOptimizationRequest\x1a\x1e.geo.RouteOptimizationResponse\x12_\n" +
        "\x1aSubscribeToDriverLocations\x12%.geo.SubscribeToDriverLocationRequest\x1a\x18.geo.DriverLocationEvent0\x01\x12^\n" +
        "\x15StartLocationTracking\x12!.geo.StartLocationTrackingRequest\x1a\".geo.StartLocationTrackingResponseB0Z.github.com/rideshare-platform/shared/proto/geob\x06proto3"

var (
        file_shared_proto_geo_geo_proto_rawDescOnce sync.Once
        file_shared_proto_geo_geo_proto_rawDescData []byte
)

func file_shared_proto_geo_geo_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_shared_proto_geo_geo_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_shared_proto_geo_geo_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_geo_geo_proto_rawDesc), len(file_shared_proto_geo_geo_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_shared_proto_geo_geo_proto_rawDescData</span>
}

var file_shared_proto_geo_geo_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_shared_proto_geo_geo_proto_goTypes = []any{
        (*Location)(nil),                         // 0: geo.Location
        (*DistanceRequest)(nil),                  // 1: geo.DistanceRequest
        (*DistanceResponse)(nil),                 // 2: geo.DistanceResponse
        (*ETARequest)(nil),                       // 3: geo.ETARequest
        (*ETAResponse)(nil),                      // 4: geo.ETAResponse
        (*NearbyDriversRequest)(nil),             // 5: geo.NearbyDriversRequest
        (*DriverLocation)(nil),                   // 6: geo.DriverLocation
        (*NearbyDriversResponse)(nil),            // 7: geo.NearbyDriversResponse
        (*UpdateDriverLocationRequest)(nil),      // 8: geo.UpdateDriverLocationRequest
        (*UpdateDriverLocationResponse)(nil),     // 9: geo.UpdateDriverLocationResponse
        (*GeohashRequest)(nil),                   // 10: geo.GeohashRequest
        (*GeohashResponse)(nil),                  // 11: geo.GeohashResponse
        (*RouteOptimizationRequest)(nil),         // 12: geo.RouteOptimizationRequest
        (*RouteOptimizationResponse)(nil),        // 13: geo.RouteOptimizationResponse
        (*SubscribeToDriverLocationRequest)(nil), // 14: geo.SubscribeToDriverLocationRequest
        (*DriverLocationEvent)(nil),              // 15: geo.DriverLocationEvent
        (*StartLocationTrackingRequest)(nil),     // 16: geo.StartLocationTrackingRequest
        (*StartLocationTrackingResponse)(nil),    // 17: geo.StartLocationTrackingResponse
        nil,                                      // 18: geo.DriverLocationEvent.MetadataEntry
        (*timestamppb.Timestamp)(nil),            // 19: google.protobuf.Timestamp
}
var file_shared_proto_geo_geo_proto_depIdxs = []int32{
        19, // 0: geo.Location.timestamp:type_name -&gt; google.protobuf.Timestamp
        0,  // 1: geo.DistanceRequest.origin:type_name -&gt; geo.Location
        0,  // 2: geo.DistanceRequest.destination:type_name -&gt; geo.Location
        0,  // 3: geo.ETARequest.origin:type_name -&gt; geo.Location
        0,  // 4: geo.ETARequest.destination:type_name -&gt; geo.Location
        19, // 5: geo.ETARequest.departure_time:type_name -&gt; google.protobuf.Timestamp
        0,  // 6: geo.ETAResponse.waypoints:type_name -&gt; geo.Location
        19, // 7: geo.ETAResponse.estimated_arrival:type_name -&gt; google.protobuf.Timestamp
        0,  // 8: geo.NearbyDriversRequest.center:type_name -&gt; geo.Location
        0,  // 9: geo.DriverLocation.location:type_name -&gt; geo.Location
        6,  // 10: geo.NearbyDriversResponse.drivers:type_name -&gt; geo.DriverLocation
        0,  // 11: geo.UpdateDriverLocationRequest.location:type_name -&gt; geo.Location
        19, // 12: geo.UpdateDriverLocationResponse.updated_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 13: geo.GeohashRequest.location:type_name -&gt; geo.Location
        0,  // 14: geo.GeohashResponse.center:type_name -&gt; geo.Location
        0,  // 15: geo.RouteOptimizationRequest.start:type_name -&gt; geo.Location
        0,  // 16: geo.RouteOptimizationRequest.waypoints:type_name -&gt; geo.Location
        0,  // 17: geo.RouteOptimizationRequest.end:type_name -&gt; geo.Location
        0,  // 18: geo.RouteOptimizationResponse.optimized_route:type_name -&gt; geo.Location
        0,  // 19: geo.DriverLocationEvent.location:type_name -&gt; geo.Location
        19, // 20: geo.DriverLocationEvent.timestamp:type_name -&gt; google.protobuf.Timestamp
        18, // 21: geo.DriverLocationEvent.metadata:type_name -&gt; geo.DriverLocationEvent.MetadataEntry
        1,  // 22: geo.GeospatialService.CalculateDistance:input_type -&gt; geo.DistanceRequest
        3,  // 23: geo.GeospatialService.CalculateETA:input_type -&gt; geo.ETARequest
        5,  // 24: geo.GeospatialService.FindNearbyDrivers:input_type -&gt; geo.NearbyDriversRequest
        8,  // 25: geo.GeospatialService.UpdateDriverLocation:input_type -&gt; geo.UpdateDriverLocationRequest
        10, // 26: geo.GeospatialService.GenerateGeohash:input_type -&gt; geo.GeohashRequest
        12, // 27: geo.GeospatialService.OptimizeRoute:input_type -&gt; geo.RouteOptimizationRequest
        14, // 28: geo.GeospatialService.SubscribeToDriverLocations:input_type -&gt; geo.SubscribeToDriverLocationRequest
        16, // 29: geo.GeospatialService.StartLocationTracking:input_type -&gt; geo.StartLocationTrackingRequest
        2,  // 30: geo.GeospatialService.CalculateDistance:output_type -&gt; geo.DistanceResponse
        4,  // 31: geo.GeospatialService.CalculateETA:output_type -&gt; geo.ETAResponse
        7,  // 32: geo.GeospatialService.FindNearbyDrivers:output_type -&gt; geo.NearbyDriversResponse
        9,  // 33: geo.GeospatialService.UpdateDriverLocation:output_type -&gt; geo.UpdateDriverLocationResponse
        11, // 34: geo.GeospatialService.GenerateGeohash:output_type -&gt; geo.GeohashResponse
        13, // 35: geo.GeospatialService.OptimizeRoute:output_type -&gt; geo.RouteOptimizationResponse
        15, // 36: geo.GeospatialService.SubscribeToDriverLocations:output_type -&gt; geo.DriverLocationEvent
        17, // 37: geo.GeospatialService.StartLocationTracking:output_type -&gt; geo.StartLocationTrackingResponse
        30, // [30:38] is the sub-list for method output_type
        22, // [22:30] is the sub-list for method input_type
        22, // [22:22] is the sub-list for extension type_name
        22, // [22:22] is the sub-list for extension extendee
        0,  // [0:22] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_shared_proto_geo_geo_proto_init() }</span>
func file_shared_proto_geo_geo_proto_init() <span class="cov0" title="0">{
        if File_shared_proto_geo_geo_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_geo_geo_proto_rawDesc), len(file_shared_proto_geo_geo_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   19,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_shared_proto_geo_geo_proto_goTypes,
                DependencyIndexes: file_shared_proto_geo_geo_proto_depIdxs,
                MessageInfos:      file_shared_proto_geo_geo_proto_msgTypes,
        }.Build()
        File_shared_proto_geo_geo_proto = out.File
        file_shared_proto_geo_geo_proto_goTypes = nil
        file_shared_proto_geo_geo_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/geo/geo.proto

package geo

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        GeospatialService_CalculateDistance_FullMethodName          = "/geo.GeospatialService/CalculateDistance"
        GeospatialService_CalculateETA_FullMethodName               = "/geo.GeospatialService/CalculateETA"
        GeospatialService_FindNearbyDrivers_FullMethodName          = "/geo.GeospatialService/FindNearbyDrivers"
        GeospatialService_UpdateDriverLocation_FullMethodName       = "/geo.GeospatialService/UpdateDriverLocation"
        GeospatialService_GenerateGeohash_FullMethodName            = "/geo.GeospatialService/GenerateGeohash"
        GeospatialService_OptimizeRoute_FullMethodName              = "/geo.GeospatialService/OptimizeRoute"
        GeospatialService_SubscribeToDriverLocations_FullMethodName = "/geo.GeospatialService/SubscribeToDriverLocations"
        GeospatialService_StartLocationTracking_FullMethodName      = "/geo.GeospatialService/StartLocationTracking"
)

// GeospatialServiceClient is the client API for GeospatialService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Geospatial service definition
type GeospatialServiceClient interface {
        // Calculate distance between two points
        CalculateDistance(ctx context.Context, in *DistanceRequest, opts ...grpc.CallOption) (*DistanceResponse, error)
        // Calculate ETA and route
        CalculateETA(ctx context.Context, in *ETARequest, opts ...grpc.CallOption) (*ETAResponse, error)
        // Find nearby drivers
        FindNearbyDrivers(ctx context.Context, in *NearbyDriversRequest, opts ...grpc.CallOption) (*NearbyDriversResponse, error)
        // Update driver location
        UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error)
        // Generate geohash for location
        GenerateGeohash(ctx context.Context, in *GeohashRequest, opts ...grpc.CallOption) (*GeohashResponse, error)
        // Optimize route with multiple waypoints
        OptimizeRoute(ctx context.Context, in *RouteOptimizationRequest, opts ...grpc.CallOption) (*RouteOptimizationResponse, error)
        // Real-time driver location streaming
        SubscribeToDriverLocations(ctx context.Context, in *SubscribeToDriverLocationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DriverLocationEvent], error)
        // Start location tracking session for a driver
        StartLocationTracking(ctx context.Context, in *StartLocationTrackingRequest, opts ...grpc.CallOption) (*StartLocationTrackingResponse, error)
}

type geospatialServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewGeospatialServiceClient(cc grpc.ClientConnInterface) GeospatialServiceClient <span class="cov0" title="0">{
        return &amp;geospatialServiceClient{cc}
}</span>

func (c *geospatialServiceClient) CalculateDistance(ctx context.Context, in *DistanceRequest, opts ...grpc.CallOption) (*DistanceResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DistanceResponse)
        err := c.cc.Invoke(ctx, GeospatialService_CalculateDistance_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *geospatialServiceClient) CalculateETA(ctx context.Context, in *ETARequest, opts ...grpc.CallOption) (*ETAResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ETAResponse)
        err := c.cc.Invoke(ctx, GeospatialService_CalculateETA_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *geospatialServiceClient) FindNearbyDrivers(ctx context.Context, in *NearbyDriversRequest, opts ...grpc.CallOption) (*NearbyDriversResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(NearbyDriversResponse)
        err := c.cc.Invoke(ctx, GeospatialService_FindNearbyDrivers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *geospatialServiceClient) UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateDriverLocationResponse)
        err := c.cc.Invoke(ctx, GeospatialService_UpdateDriverLocation_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *geospatialServiceClient) GenerateGeohash(ctx context.Context, in *GeohashRequest, opts ...grpc.CallOption) (*GeohashResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GeohashResponse)
        err := c.cc.Invoke(ctx, GeospatialService_GenerateGeohash_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *geospatialServiceClient) OptimizeRoute(ctx context.Context, in *RouteOptimizationRequest, opts ...grpc.CallOption) (*RouteOptimizationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(RouteOptimizationResponse)
        err := c.cc.Invoke(ctx, GeospatialService_OptimizeRoute_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *geospatialServiceClient) SubscribeToDriverLocations(ctx context.Context, in *SubscribeToDriverLocationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DriverLocationEvent], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;GeospatialService_ServiceDesc.Streams[0], GeospatialService_SubscribeToDriverLocations_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[SubscribeToDriverLocationRequest, DriverLocationEvent]{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GeospatialService_SubscribeToDriverLocationsClient = grpc.ServerStreamingClient[DriverLocationEvent]

func (c *geospatialServiceClient) StartLocationTracking(ctx context.Context, in *StartLocationTrackingRequest, opts ...grpc.CallOption) (*StartLocationTrackingResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StartLocationTrackingResponse)
        err := c.cc.Invoke(ctx, GeospatialService_StartLocationTracking_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// GeospatialServiceServer is the server API for GeospatialService service.
// All implementations must embed UnimplementedGeospatialServiceServer
// for forward compatibility.
//
// Geospatial service definition
type GeospatialServiceServer interface {
        // Calculate distance between two points
        CalculateDistance(context.Context, *DistanceRequest) (*DistanceResponse, error)
        // Calculate ETA and route
        CalculateETA(context.Context, *ETARequest) (*ETAResponse, error)
        // Find nearby drivers
        FindNearbyDrivers(context.Context, *NearbyDriversRequest) (*NearbyDriversResponse, error)
        // Update driver location
        UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error)
        // Generate geohash for location
        GenerateGeohash(context.Context, *GeohashRequest) (*GeohashResponse, error)
        // Optimize route with multiple waypoints
        OptimizeRoute(context.Context, *RouteOptimizationRequest) (*RouteOptimizationResponse, error)
        // Real-time driver location streaming
        SubscribeToDriverLocations(*SubscribeToDriverLocationRequest, grpc.ServerStreamingServer[DriverLocationEvent]) error
        // Start location tracking session for a driver
        StartLocationTracking(context.Context, *StartLocationTrackingRequest) (*StartLocationTrackingResponse, error)
        mustEmbedUnimplementedGeospatialServiceServer()
}

// UnimplementedGeospatialServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGeospatialServiceServer struct{}

func (UnimplementedGeospatialServiceServer) CalculateDistance(context.Context, *DistanceRequest) (*DistanceResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CalculateDistance not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) CalculateETA(context.Context, *ETARequest) (*ETAResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CalculateETA not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) FindNearbyDrivers(context.Context, *NearbyDriversRequest) (*NearbyDriversResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method FindNearbyDrivers not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateDriverLocation not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) GenerateGeohash(context.Context, *GeohashRequest) (*GeohashResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GenerateGeohash not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) OptimizeRoute(context.Context, *RouteOptimizationRequest) (*RouteOptimizationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method OptimizeRoute not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) SubscribeToDriverLocations(*SubscribeToDriverLocationRequest, grpc.ServerStreamingServer[DriverLocationEvent]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SubscribeToDriverLocations not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) StartLocationTracking(context.Context, *StartLocationTrackingRequest) (*StartLocationTrackingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method StartLocationTracking not implemented")
}</span>
func (UnimplementedGeospatialServiceServer) mustEmbedUnimplementedGeospatialServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedGeospatialServiceServer) testEmbeddedByValue()                           {<span class="cov0" title="0">}</span>

// UnsafeGeospatialServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeospatialServiceServer will
// result in compilation errors.
type UnsafeGeospatialServiceServer interface {
        mustEmbedUnimplementedGeospatialServiceServer()
}

func RegisterGeospatialServiceServer(s grpc.ServiceRegistrar, srv GeospatialServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedGeospatialServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;GeospatialService_ServiceDesc, srv)</span>
}

func _GeospatialService_CalculateDistance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DistanceRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).CalculateDistance(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_CalculateDistance_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).CalculateDistance(ctx, req.(*DistanceRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GeospatialService_CalculateETA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ETARequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).CalculateETA(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_CalculateETA_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).CalculateETA(ctx, req.(*ETARequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GeospatialService_FindNearbyDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(NearbyDriversRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).FindNearbyDrivers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_FindNearbyDrivers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).FindNearbyDrivers(ctx, req.(*NearbyDriversRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GeospatialService_UpdateDriverLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateDriverLocationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).UpdateDriverLocation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_UpdateDriverLocation_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).UpdateDriverLocation(ctx, req.(*UpdateDriverLocationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GeospatialService_GenerateGeohash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GeohashRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).GenerateGeohash(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_GenerateGeohash_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).GenerateGeohash(ctx, req.(*GeohashRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GeospatialService_OptimizeRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(RouteOptimizationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).OptimizeRoute(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_OptimizeRoute_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).OptimizeRoute(ctx, req.(*RouteOptimizationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GeospatialService_SubscribeToDriverLocations_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(SubscribeToDriverLocationRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(GeospatialServiceServer).SubscribeToDriverLocations(m, &amp;grpc.GenericServerStream[SubscribeToDriverLocationRequest, DriverLocationEvent]{ServerStream: stream})</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GeospatialService_SubscribeToDriverLocationsServer = grpc.ServerStreamingServer[DriverLocationEvent]

func _GeospatialService_StartLocationTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StartLocationTrackingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).StartLocationTracking(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GeospatialService_StartLocationTracking_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GeospatialServiceServer).StartLocationTracking(ctx, req.(*StartLocationTrackingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// GeospatialService_ServiceDesc is the grpc.ServiceDesc for GeospatialService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GeospatialService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "geo.GeospatialService",
        HandlerType: (*GeospatialServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CalculateDistance",
                        Handler:    _GeospatialService_CalculateDistance_Handler,
                },
                {
                        MethodName: "CalculateETA",
                        Handler:    _GeospatialService_CalculateETA_Handler,
                },
                {
                        MethodName: "FindNearbyDrivers",
                        Handler:    _GeospatialService_FindNearbyDrivers_Handler,
                },
                {
                        MethodName: "UpdateDriverLocation",
                        Handler:    _GeospatialService_UpdateDriverLocation_Handler,
                },
                {
                        MethodName: "GenerateGeohash",
                        Handler:    _GeospatialService_GenerateGeohash_Handler,
                },
                {
                        MethodName: "OptimizeRoute",
                        Handler:    _GeospatialService_OptimizeRoute_Handler,
                },
                {
                        MethodName: "StartLocationTracking",
                        Handler:    _GeospatialService_StartLocationTracking_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "SubscribeToDriverLocations",
                        Handler:       _GeospatialService_SubscribeToDriverLocations_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "shared/proto/geo/geo.proto",
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v3.21.12
// source: shared/proto/matching/matching.proto

package matching

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Location represents a geographical coordinate
type Location struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Latitude      float64                `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude     float64                `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
        Address       string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Location) Reset() <span class="cov0" title="0">{
        *x = Location{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Location) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Location) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Location) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Location) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Driver information for matching
type Driver struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        UserId          string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        CurrentLocation *Location              `protobuf:"bytes,3,opt,name=current_location,json=currentLocation,proto3" json:"current_location,omitempty"`
        VehicleId       string                 `protobuf:"bytes,4,opt,name=vehicle_id,json=vehicleId,proto3" json:"vehicle_id,omitempty"`
        VehicleType     string                 `protobuf:"bytes,5,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        Rating          float64                `protobuf:"fixed64,6,opt,name=rating,proto3" json:"rating,omitempty"`
        TotalTrips      int32                  `protobuf:"varint,7,opt,name=total_trips,json=totalTrips,proto3" json:"total_trips,omitempty"`
        IsAvailable     bool                   `protobuf:"varint,8,opt,name=is_available,json=isAvailable,proto3" json:"is_available,omitempty"`
        DistanceKm      float64                `protobuf:"fixed64,9,opt,name=distance_km,json=distanceKm,proto3" json:"distance_km,omitempty"`
        EtaMinutes      int32                  `protobuf:"varint,10,opt,name=eta_minutes,json=etaMinutes,proto3" json:"eta_minutes,omitempty"`
        Score           *MatchingScore         `protobuf:"bytes,11,opt,name=score,proto3" json:"score,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Driver) Reset() <span class="cov0" title="0">{
        *x = Driver{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Driver) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Driver) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Driver) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Driver.ProtoReflect.Descriptor instead.
func (*Driver) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Driver) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetCurrentLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Driver) GetVehicleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Driver) GetTotalTrips() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalTrips
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Driver) GetIsAvailable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAvailable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Driver) GetDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Driver) GetEtaMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EtaMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Driver) GetScore() *MatchingScore <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Score
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Matching score breakdown
type MatchingScore struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        TotalScore        float64                `protobuf:"fixed64,1,opt,name=total_score,json=totalScore,proto3" json:"total_score,omitempty"`
        DistanceScore     float64                `protobuf:"fixed64,2,opt,name=distance_score,json=distanceScore,proto3" json:"distance_score,omitempty"`
        RatingScore       float64                `protobuf:"fixed64,3,opt,name=rating_score,json=ratingScore,proto3" json:"rating_score,omitempty"`
        AvailabilityScore float64                `protobuf:"fixed64,4,opt,name=availability_score,json=availabilityScore,proto3" json:"availability_score,omitempty"`
        DemandScore       float64                `protobuf:"fixed64,5,opt,name=demand_score,json=demandScore,proto3" json:"demand_score,omitempty"`
        HistoricalScore   float64                `protobuf:"fixed64,6,opt,name=historical_score,json=historicalScore,proto3" json:"historical_score,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *MatchingScore) Reset() <span class="cov0" title="0">{
        *x = MatchingScore{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchingScore) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchingScore) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchingScore) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchingScore.ProtoReflect.Descriptor instead.
func (*MatchingScore) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{2}
}</span>

func (x *MatchingScore) GetTotalScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingScore) GetDistanceScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingScore) GetRatingScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RatingScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingScore) GetAvailabilityScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvailabilityScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingScore) GetDemandScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DemandScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingScore) GetHistoricalScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HistoricalScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Ride request for matching
type RideRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        RiderId        string                 `protobuf:"bytes,2,opt,name=rider_id,json=riderId,proto3" json:"rider_id,omitempty"`
        PickupLocation *Location              `protobuf:"bytes,3,opt,name=pickup_location,json=pickupLocation,proto3" json:"pickup_location,omitempty"`
        Destination    *Location              `protobuf:"bytes,4,opt,name=destination,proto3" json:"destination,omitempty"`
        VehicleType    string                 `protobuf:"bytes,5,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        PassengerCount int32                  `protobuf:"varint,6,opt,name=passenger_count,json=passengerCount,proto3" json:"passenger_count,omitempty"`
        RequestedAt    *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
        Preferences    map[string]string      `protobuf:"bytes,8,rep,name=preferences,proto3" json:"preferences,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *RideRequest) Reset() <span class="cov0" title="0">{
        *x = RideRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *RideRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RideRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RideRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RideRequest.ProtoReflect.Descriptor instead.
func (*RideRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{3}
}</span>

func (x *RideRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RideRequest) GetRiderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RideRequest) GetPickupLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PickupLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RideRequest) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RideRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RideRequest) GetPassengerCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PassengerCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *RideRequest) GetRequestedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequestedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RideRequest) GetPreferences() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Preferences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Matching result
type MatchResult struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        RequestId      string                 `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
        MatchedDrivers []*Driver              `protobuf:"bytes,2,rep,name=matched_drivers,json=matchedDrivers,proto3" json:"matched_drivers,omitempty"`
        BestMatch      *Driver                `protobuf:"bytes,3,opt,name=best_match,json=bestMatch,proto3" json:"best_match,omitempty"`
        Metadata       *MatchingMetadata      `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
        Success        bool                   `protobuf:"varint,5,opt,name=success,proto3" json:"success,omitempty"`
        Message        string                 `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *MatchResult) Reset() <span class="cov0" title="0">{
        *x = MatchResult{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchResult.ProtoReflect.Descriptor instead.
func (*MatchResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{4}
}</span>

func (x *MatchResult) GetRequestId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequestId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MatchResult) GetMatchedDrivers() []*Driver <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MatchedDrivers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MatchResult) GetBestMatch() *Driver <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BestMatch
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MatchResult) GetMetadata() *MatchingMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MatchResult) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MatchResult) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Matching metadata
type MatchingMetadata struct {
        state                  protoimpl.MessageState `protogen:"open.v1"`
        TotalDriversConsidered int32                  `protobuf:"varint,1,opt,name=total_drivers_considered,json=totalDriversConsidered,proto3" json:"total_drivers_considered,omitempty"`
        AvailableDriversInArea int32                  `protobuf:"varint,2,opt,name=available_drivers_in_area,json=availableDriversInArea,proto3" json:"available_drivers_in_area,omitempty"`
        SearchRadiusKm         float64                `protobuf:"fixed64,3,opt,name=search_radius_km,json=searchRadiusKm,proto3" json:"search_radius_km,omitempty"`
        ProcessingTimeMs       int32                  `protobuf:"varint,4,opt,name=processing_time_ms,json=processingTimeMs,proto3" json:"processing_time_ms,omitempty"`
        AlgorithmVersion       string                 `protobuf:"bytes,5,opt,name=algorithm_version,json=algorithmVersion,proto3" json:"algorithm_version,omitempty"`
        AlgorithmWeights       map[string]float64     `protobuf:"bytes,6,rep,name=algorithm_weights,json=algorithmWeights,proto3" json:"algorithm_weights,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
        unknownFields          protoimpl.UnknownFields
        sizeCache              protoimpl.SizeCache
}

func (x *MatchingMetadata) Reset() <span class="cov0" title="0">{
        *x = MatchingMetadata{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchingMetadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchingMetadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchingMetadata) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchingMetadata.ProtoReflect.Descriptor instead.
func (*MatchingMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{5}
}</span>

func (x *MatchingMetadata) GetTotalDriversConsidered() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalDriversConsidered
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingMetadata) GetAvailableDriversInArea() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvailableDriversInArea
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingMetadata) GetSearchRadiusKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SearchRadiusKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingMetadata) GetProcessingTimeMs() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProcessingTimeMs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingMetadata) GetAlgorithmVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AlgorithmVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MatchingMetadata) GetAlgorithmWeights() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AlgorithmWeights
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Real-time driver tracking
type DriverLocationUpdate struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Location      *Location              `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
        IsAvailable   bool                   `protobuf:"varint,3,opt,name=is_available,json=isAvailable,proto3" json:"is_available,omitempty"`
        Status        string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DriverLocationUpdate) Reset() <span class="cov0" title="0">{
        *x = DriverLocationUpdate{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DriverLocationUpdate) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DriverLocationUpdate) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DriverLocationUpdate) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DriverLocationUpdate.ProtoReflect.Descriptor instead.
func (*DriverLocationUpdate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{6}
}</span>

func (x *DriverLocationUpdate) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocationUpdate) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DriverLocationUpdate) GetIsAvailable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAvailable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *DriverLocationUpdate) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DriverLocationUpdate) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request/Response messages
type FindNearbyDriversRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        PickupLocation *Location              `protobuf:"bytes,1,opt,name=pickup_location,json=pickupLocation,proto3" json:"pickup_location,omitempty"`
        VehicleType    string                 `protobuf:"bytes,2,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        RadiusKm       float64                `protobuf:"fixed64,3,opt,name=radius_km,json=radiusKm,proto3" json:"radius_km,omitempty"`
        MaxDrivers     int32                  `protobuf:"varint,4,opt,name=max_drivers,json=maxDrivers,proto3" json:"max_drivers,omitempty"`
        Filters        map[string]string      `protobuf:"bytes,5,rep,name=filters,proto3" json:"filters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *FindNearbyDriversRequest) Reset() <span class="cov0" title="0">{
        *x = FindNearbyDriversRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FindNearbyDriversRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FindNearbyDriversRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FindNearbyDriversRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FindNearbyDriversRequest.ProtoReflect.Descriptor instead.
func (*FindNearbyDriversRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{7}
}</span>

func (x *FindNearbyDriversRequest) GetPickupLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PickupLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FindNearbyDriversRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FindNearbyDriversRequest) GetRadiusKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RadiusKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FindNearbyDriversRequest) GetMaxDrivers() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxDrivers
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FindNearbyDriversRequest) GetFilters() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Filters
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FindNearbyDriversResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Drivers       []*Driver              `protobuf:"bytes,1,rep,name=drivers,proto3" json:"drivers,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        Metadata      *MatchingMetadata      `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FindNearbyDriversResponse) Reset() <span class="cov0" title="0">{
        *x = FindNearbyDriversResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FindNearbyDriversResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FindNearbyDriversResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FindNearbyDriversResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FindNearbyDriversResponse.ProtoReflect.Descriptor instead.
func (*FindNearbyDriversResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{8}
}</span>

func (x *FindNearbyDriversResponse) GetDrivers() []*Driver <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Drivers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FindNearbyDriversResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FindNearbyDriversResponse) GetMetadata() *MatchingMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MatchDriverRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        RideRequest   *RideRequest           `protobuf:"bytes,1,opt,name=ride_request,json=rideRequest,proto3" json:"ride_request,omitempty"`
        Preferences   *MatchingPreferences   `protobuf:"bytes,2,opt,name=preferences,proto3" json:"preferences,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MatchDriverRequest) Reset() <span class="cov0" title="0">{
        *x = MatchDriverRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchDriverRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchDriverRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchDriverRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchDriverRequest.ProtoReflect.Descriptor instead.
func (*MatchDriverRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{9}
}</span>

func (x *MatchDriverRequest) GetRideRequest() *RideRequest <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RideRequest
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MatchDriverRequest) GetPreferences() *MatchingPreferences <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Preferences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MatchingPreferences struct {
        state                    protoimpl.MessageState `protogen:"open.v1"`
        MaxPickupDistanceKm      float64                `protobuf:"fixed64,1,opt,name=max_pickup_distance_km,json=maxPickupDistanceKm,proto3" json:"max_pickup_distance_km,omitempty"`
        MinDriverRating          float64                `protobuf:"fixed64,2,opt,name=min_driver_rating,json=minDriverRating,proto3" json:"min_driver_rating,omitempty"`
        PreferExperiencedDrivers bool                   `protobuf:"varint,3,opt,name=prefer_experienced_drivers,json=preferExperiencedDrivers,proto3" json:"prefer_experienced_drivers,omitempty"`
        AllowPoolMatching        bool                   `protobuf:"varint,4,opt,name=allow_pool_matching,json=allowPoolMatching,proto3" json:"allow_pool_matching,omitempty"`
        CustomPreferences        map[string]string      `protobuf:"bytes,5,rep,name=custom_preferences,json=customPreferences,proto3" json:"custom_preferences,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields            protoimpl.UnknownFields
        sizeCache                protoimpl.SizeCache
}

func (x *MatchingPreferences) Reset() <span class="cov0" title="0">{
        *x = MatchingPreferences{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchingPreferences) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchingPreferences) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchingPreferences) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchingPreferences.ProtoReflect.Descriptor instead.
func (*MatchingPreferences) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{10}
}</span>

func (x *MatchingPreferences) GetMaxPickupDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxPickupDistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingPreferences) GetMinDriverRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinDriverRating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingPreferences) GetPreferExperiencedDrivers() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PreferExperiencedDrivers
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MatchingPreferences) GetAllowPoolMatching() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AllowPoolMatching
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MatchingPreferences) GetCustomPreferences() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CustomPreferences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MatchDriverResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Result        *MatchResult           `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *MatchDriverResponse) Reset() <span class="cov0" title="0">{
        *x = MatchDriverResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchDriverResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchDriverResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchDriverResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchDriverResponse.ProtoReflect.Descriptor instead.
func (*MatchDriverResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{11}
}</span>

func (x *MatchDriverResponse) GetResult() *MatchResult <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Result
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MatchDriverResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *MatchDriverResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *MatchDriverResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateDriverLocationRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Location      *Location              `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
        IsAvailable   bool                   `protobuf:"varint,3,opt,name=is_available,json=isAvailable,proto3" json:"is_available,omitempty"`
        Status        string                 `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateDriverLocationRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateDriverLocationRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateDriverLocationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateDriverLocationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateDriverLocationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateDriverLocationRequest.ProtoReflect.Descriptor instead.
func (*UpdateDriverLocationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{12}
}</span>

func (x *UpdateDriverLocationRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateDriverLocationRequest) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateDriverLocationRequest) GetIsAvailable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAvailable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateDriverLocationRequest) GetStatus() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateDriverLocationResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateDriverLocationResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateDriverLocationResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateDriverLocationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateDriverLocationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateDriverLocationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateDriverLocationResponse.ProtoReflect.Descriptor instead.
func (*UpdateDriverLocationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{13}
}</span>

func (x *UpdateDriverLocationResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateDriverLocationResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetDriverRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetDriverRequest) Reset() <span class="cov0" title="0">{
        *x = GetDriverRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetDriverRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetDriverRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetDriverRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetDriverRequest.ProtoReflect.Descriptor instead.
func (*GetDriverRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetDriverRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetDriverResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Driver        *Driver                `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetDriverResponse) Reset() <span class="cov0" title="0">{
        *x = GetDriverResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetDriverResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetDriverResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetDriverResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetDriverResponse.ProtoReflect.Descriptor instead.
func (*GetDriverResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{15}
}</span>

func (x *GetDriverResponse) GetDriver() *Driver <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Driver
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetDriverResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetActiveDriversRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Center        *Location              `protobuf:"bytes,1,opt,name=center,proto3" json:"center,omitempty"`
        RadiusKm      float64                `protobuf:"fixed64,2,opt,name=radius_km,json=radiusKm,proto3" json:"radius_km,omitempty"`
        VehicleType   string                 `protobuf:"bytes,3,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        Limit         int32                  `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetActiveDriversRequest) Reset() <span class="cov0" title="0">{
        *x = GetActiveDriversRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetActiveDriversRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetActiveDriversRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetActiveDriversRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetActiveDriversRequest.ProtoReflect.Descriptor instead.
func (*GetActiveDriversRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetActiveDriversRequest) GetCenter() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Center
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetActiveDriversRequest) GetRadiusKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RadiusKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetActiveDriversRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetActiveDriversRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetActiveDriversResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Drivers       []*Driver              `protobuf:"bytes,1,rep,name=drivers,proto3" json:"drivers,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        Metadata      *MatchingMetadata      `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetActiveDriversResponse) Reset() <span class="cov0" title="0">{
        *x = GetActiveDriversResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetActiveDriversResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetActiveDriversResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetActiveDriversResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetActiveDriversResponse.ProtoReflect.Descriptor instead.
func (*GetActiveDriversResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{17}
}</span>

func (x *GetActiveDriversResponse) GetDrivers() []*Driver <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Drivers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetActiveDriversResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetActiveDriversResponse) GetMetadata() *MatchingMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Batch operations
type BatchUpdateDriversRequest struct {
        state         protoimpl.MessageState  `protogen:"open.v1"`
        Updates       []*DriverLocationUpdate `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *BatchUpdateDriversRequest) Reset() <span class="cov0" title="0">{
        *x = BatchUpdateDriversRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchUpdateDriversRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchUpdateDriversRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchUpdateDriversRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchUpdateDriversRequest.ProtoReflect.Descriptor instead.
func (*BatchUpdateDriversRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{18}
}</span>

func (x *BatchUpdateDriversRequest) GetUpdates() []*DriverLocationUpdate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Updates
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BatchUpdateDriversResponse struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        SuccessfulUpdates int32                  `protobuf:"varint,1,opt,name=successful_updates,json=successfulUpdates,proto3" json:"successful_updates,omitempty"`
        FailedUpdates     int32                  `protobuf:"varint,2,opt,name=failed_updates,json=failedUpdates,proto3" json:"failed_updates,omitempty"`
        Errors            []string               `protobuf:"bytes,3,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *BatchUpdateDriversResponse) Reset() <span class="cov0" title="0">{
        *x = BatchUpdateDriversResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BatchUpdateDriversResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BatchUpdateDriversResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BatchUpdateDriversResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BatchUpdateDriversResponse.ProtoReflect.Descriptor instead.
func (*BatchUpdateDriversResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{19}
}</span>

func (x *BatchUpdateDriversResponse) GetSuccessfulUpdates() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SuccessfulUpdates
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BatchUpdateDriversResponse) GetFailedUpdates() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FailedUpdates
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *BatchUpdateDriversResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Performance metrics
type GetMatchingStatsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        FromTime      *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=from_time,json=fromTime,proto3" json:"from_time,omitempty"`
        ToTime        *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=to_time,json=toTime,proto3" json:"to_time,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetMatchingStatsRequest) Reset() <span class="cov0" title="0">{
        *x = GetMatchingStatsRequest{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMatchingStatsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMatchingStatsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMatchingStatsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMatchingStatsRequest.ProtoReflect.Descriptor instead.
func (*GetMatchingStatsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{20}
}</span>

func (x *GetMatchingStatsRequest) GetFromTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMatchingStatsRequest) GetToTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MatchingStats struct {
        state                   protoimpl.MessageState `protogen:"open.v1"`
        TotalRequests           int32                  `protobuf:"varint,1,opt,name=total_requests,json=totalRequests,proto3" json:"total_requests,omitempty"`
        SuccessfulMatches       int32                  `protobuf:"varint,2,opt,name=successful_matches,json=successfulMatches,proto3" json:"successful_matches,omitempty"`
        FailedMatches           int32                  `protobuf:"varint,3,opt,name=failed_matches,json=failedMatches,proto3" json:"failed_matches,omitempty"`
        AverageMatchTimeMs      float64                `protobuf:"fixed64,4,opt,name=average_match_time_ms,json=averageMatchTimeMs,proto3" json:"average_match_time_ms,omitempty"`
        AveragePickupDistanceKm float64                `protobuf:"fixed64,5,opt,name=average_pickup_distance_km,json=averagePickupDistanceKm,proto3" json:"average_pickup_distance_km,omitempty"`
        MatchSuccessRate        float64                `protobuf:"fixed64,6,opt,name=match_success_rate,json=matchSuccessRate,proto3" json:"match_success_rate,omitempty"`
        VehicleTypeDistribution map[string]int32       `protobuf:"bytes,7,rep,name=vehicle_type_distribution,json=vehicleTypeDistribution,proto3" json:"vehicle_type_distribution,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
        unknownFields           protoimpl.UnknownFields
        sizeCache               protoimpl.SizeCache
}

func (x *MatchingStats) Reset() <span class="cov0" title="0">{
        *x = MatchingStats{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *MatchingStats) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MatchingStats) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MatchingStats) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use MatchingStats.ProtoReflect.Descriptor instead.
func (*MatchingStats) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{21}
}</span>

func (x *MatchingStats) GetTotalRequests() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalRequests
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingStats) GetSuccessfulMatches() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SuccessfulMatches
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingStats) GetFailedMatches() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FailedMatches
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingStats) GetAverageMatchTimeMs() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AverageMatchTimeMs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingStats) GetAveragePickupDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AveragePickupDistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingStats) GetMatchSuccessRate() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MatchSuccessRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *MatchingStats) GetVehicleTypeDistribution() map[string]int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleTypeDistribution
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetMatchingStatsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Stats         *MatchingStats         `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetMatchingStatsResponse) Reset() <span class="cov0" title="0">{
        *x = GetMatchingStatsResponse{}
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMatchingStatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMatchingStatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMatchingStatsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_matching_matching_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMatchingStatsResponse.ProtoReflect.Descriptor instead.
func (*GetMatchingStatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_matching_matching_proto_rawDescGZIP(), []int{22}
}</span>

func (x *GetMatchingStatsResponse) GetStats() *MatchingStats <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stats
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMatchingStatsResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_shared_proto_matching_matching_proto protoreflect.FileDescriptor

const file_shared_proto_matching_matching_proto_rawDesc = "" +
        "\n" +
        "$shared/proto/matching/matching.proto\x12\bmatching\x1a\x1fgoogle/protobuf/timestamp.proto\"^\n" +
        "\bLocation\x12\x1a\n" +
        "\blatitude\x18\x01 \x01(\x01R\blatitude\x12\x1c\n" +
        "\tlongitude\x18\x02 \x01(\x01R\tlongitude\x12\x18\n" +
        "\aaddress\x18\x03 \x01(\tR\aaddress\"\xff\x02\n" +
        "\x06Driver\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\tR\x06userId\x12=\n" +
        "\x10current_location\x18\x03 \x01(\v2\x12.matching.LocationR\x0fcurrentLocation\x12\x1d\n" +
        "\n" +
        "vehicle_id\x18\x04 \x01(\tR\tvehicleId\x12!\n" +
        "\fvehicle_type\x18\x05 \x01(\tR\vvehicleType\x12\x16\n" +
        "\x06rating\x18\x06 \x01(\x01R\x06rating\x12\x1f\n" +
        "\vtotal_trips\x18\a \x01(\x05R\n" +
        "totalTrips\x12!\n" +
        "\fis_available\x18\b \x01(\bR\visAvailable\x12\x1f\n" +
        "\vdistance_km\x18\t \x01(\x01R\n" +
        "distanceKm\x12\x1f\n" +
        "\veta_minutes\x18\n" +
        " \x01(\x05R\n" +
        "etaMinutes\x12-\n" +
        "\x05score\x18\v \x01(\v2\x17.matching.MatchingScoreR\x05score\"\xf7\x01\n" +
        "\rMatchingScore\x12\x1f\n" +
        "\vtotal_score\x18\x01 \x01(\x01R\n" +
        "totalScore\x12%\n" +
        "\x0edistance_score\x18\x02 \x01(\x01R\rdistanceScore\x12!\n" +
        "\frating_score\x18\x03 \x01(\x01R\vratingScore\x12-\n" +
        "\x12availability_score\x18\x04 \x01(\x01R\x11availabilityScore\x12!\n" +
        "\fdemand_score\x18\x05 \x01(\x01R\vdemandScore\x12)\n" +
        "\x10historical_score\x18\x06 \x01(\x01R\x0fhistoricalScore\"\xc0\x03\n" +
        "\vRideRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x19\n" +
        "\brider_id\x18\x02 \x01(\tR\ariderId\x12;\n" +
        "\x0fpickup_location\x18\x03 \x01(\v2\x12.matching.LocationR\x0epickupLocation\x124\n" +
        "\vdestination\x18\x04 \x01(\v2\x12.matching.LocationR\vdestination\x12!\n" +
        "\fvehicle_type\x18\x05 \x01(\tR\vvehicleType\x12'\n" +
        "\x0fpassenger_count\x18\x06 \x01(\x05R\x0epassengerCount\x12=\n" +
        "\frequested_at\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\vrequestedAt\x12H\n" +
        "\vpreferences\x18\b \x03(\v2&amp;.matching.RideRequest.PreferencesEntryR\vpreferences\x1a&gt;\n" +
        "\x10PreferencesEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x84\x02\n" +
        "\vMatchResult\x12\x1d\n" +
        "\n" +
        "request_id\x18\x01 \x01(\tR\trequestId\x129\n" +
        "\x0fmatched_drivers\x18\x02 \x03(\v2\x10.matching.DriverR\x0ematchedDrivers\x12/\n" +
        "\n" +
        "best_match\x18\x03 \x01(\v2\x10.matching.DriverR\tbestMatch\x126\n" +
        "\bmetadata\x18\x04 \x01(\v2\x1a.matching.MatchingMetadataR\bmetadata\x12\x18\n" +
        "\asuccess\x18\x05 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x06 \x01(\tR\amessage\"\xb0\x03\n" +
        "\x10MatchingMetadata\x128\n" +
        "\x18total_drivers_considered\x18\x01 \x01(\x05R\x16totalDriversConsidered\x129\n" +
        "\x19available_drivers_in_area\x18\x02 \x01(\x05R\x16availableDriversInArea\x12(\n" +
        "\x10search_radius_km\x18\x03 \x01(\x01R\x0esearchRadiusKm\x12,\n" +
        "\x12processing_time_ms\x18\x04 \x01(\x05R\x10processingTimeMs\x12+\n" +
        "\x11algorithm_version\x18\x05 \x01(\tR\x10algorithmVersion\x12]\n" +
        "\x11algorithm_weights\x18\x06 \x03(\v20.matching.MatchingMetadata.AlgorithmWeightsEntryR\x10algorithmWeights\x1aC\n" +
        "\x15AlgorithmWeightsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\"\xd8\x01\n" +
        "\x14DriverLocationUpdate\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x12.\n" +
        "\blocation\x18\x02 \x01(\v2\x12.matching.LocationR\blocation\x12!\n" +
        "\fis_available\x18\x03 \x01(\bR\visAvailable\x12\x16\n" +
        "\x06status\x18\x04 \x01(\tR\x06status\x128\n" +
        "\ttimestamp\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\"\xbf\x02\n" +
        "\x18FindNearbyDriversRequest\x12;\n" +
        "\x0fpickup_location\x18\x01 \x01(\v2\x12.matching.LocationR\x0epickupLocation\x12!\n" +
        "\fvehicle_type\x18\x02 \x01(\tR\vvehicleType\x12\x1b\n" +
        "\tradius_km\x18\x03 \x01(\x01R\bradiusKm\x12\x1f\n" +
        "\vmax_drivers\x18\x04 \x01(\x05R\n" +
        "maxDrivers\x12I\n" +
        "\afilters\x18\x05 \x03(\v2/.matching.FindNearbyDriversRequest.FiltersEntryR\afilters\x1a:\n" +
        "\fFiltersEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa0\x01\n" +
        "\x19FindNearbyDriversResponse\x12*\n" +
        "\adrivers\x18\x01 \x03(\v2\x10.matching.DriverR\adrivers\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x126\n" +
        "\bmetadata\x18\x03 \x01(\v2\x1a.matching.MatchingMetadataR\bmetadata\"\x8f\x01\n" +
        "\x12MatchDriverRequest\x128\n" +
        "\fride_request\x18\x01 \x01(\v2\x15.matching.RideRequestR\vrideRequest\x12?\n" +
        "\vpreferences\x18\x02 \x01(\v2\x1d.matching.MatchingPreferencesR\vpreferences\"\x8f\x03\n" +
        "\x13MatchingPreferences\x123\n" +
        "\x16max_pickup_distance_km\x18\x01 \x01(\x01R\x13maxPickupDistanceKm\x12*\n" +
        "\x11min_driver_rating\x18\x02 \x01(\x01R\x0fminDriverRating\x12&lt;\n" +
        "\x1aprefer_experienced_drivers\x18\x03 \x01(\bR\x18preferExperiencedDrivers\x12.\n" +
        "\x13allow_pool_matching\x18\x04 \x01(\bR\x11allowPoolMatching\x12c\n" +
        "\x12custom_preferences\x18\x05 \x03(\v24.matching.MatchingPreferences.CustomPreferencesEntryR\x11customPreferences\x1aD\n" +
        "\x16CustomPreferencesEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x90\x01\n" +
        "\x13MatchDriverResponse\x12-\n" +
        "\x06result\x18\x01 \x01(\v2\x15.matching.MatchResultR\x06result\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\"\xa5\x01\n" +
        "\x1bUpdateDriverLocationRequest\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x12.\n" +
        "\blocation\x18\x02 \x01(\v2\x12.matching.LocationR\blocation\x12!\n" +
        "\fis_available\x18\x03 \x01(\bR\visAvailable\x12\x16\n" +
        "\x06status\x18\x04 \x01(\tR\x06status\"R\n" +
        "\x1cUpdateDriverLocationResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\"/\n" +
        "\x10GetDriverRequest\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\"S\n" +
        "\x11GetDriverResponse\x12(\n" +
        "\x06driver\x18\x01 \x01(\v2\x10.matching.DriverR\x06driver\x12\x14\n" +
        "\x05found\x18\x02 \x01(\bR\x05found\"\x9b\x01\n" +
        "\x17GetActiveDriversRequest\x12*\n" +
        "\x06center\x18\x01 \x01(\v2\x12.matching.LocationR\x06center\x12\x1b\n" +
        "\tradius_km\x18\x02 \x01(\x01R\bradiusKm\x12!\n" +
        "\fvehicle_type\x18\x03 \x01(\tR\vvehicleType\x12\x14\n" +
        "\x05limit\x18\x04 \x01(\x05R\x05limit\"\x9f\x01\n" +
        "\x18GetActiveDriversResponse\x12*\n" +
        "\adrivers\x18\x01 \x03(\v2\x10.matching.DriverR\adrivers\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x126\n" +
        "\bmetadata\x18\x03 \x01(\v2\x1a.matching.MatchingMetadataR\bmetadata\"U\n" +
        "\x19BatchUpdateDriversRequest\x128\n" +
        "\aupdates\x18\x01 \x03(\v2\x1e.matching.DriverLocationUpdateR\aupdates\"\x8a\x01\n" +
        "\x1aBatchUpdateDriversResponse\x12-\n" +
        "\x12successful_updates\x18\x01 \x01(\x05R\x11successfulUpdates\x12%\n" +
        "\x0efailed_updates\x18\x02 \x01(\x05R\rfailedUpdates\x12\x16\n" +
        "\x06errors\x18\x03 \x03(\tR\x06errors\"\x87\x01\n" +
        "\x17GetMatchingStatsRequest\x127\n" +
        "\tfrom_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\bfromTime\x123\n" +
        "\ato_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x06toTime\"\xe8\x03\n" +
        "\rMatchingStats\x12%\n" +
        "\x0etotal_requests\x18\x01 \x01(\x05R\rtotalRequests\x12-\n" +
        "\x12successful_matches\x18\x02 \x01(\x05R\x11successfulMatches\x12%\n" +
        "\x0efailed_matches\x18\x03 \x01(\x05R\rfailedMatches\x121\n" +
        "\x15average_match_time_ms\x18\x04 \x01(\x01R\x12averageMatchTimeMs\x12;\n" +
        "\x1aaverage_pickup_distance_km\x18\x05 \x01(\x01R\x17averagePickupDistanceKm\x12,\n" +
        "\x12match_success_rate\x18\x06 \x01(\x01R\x10matchSuccessRate\x12p\n" +
        "\x19vehicle_type_distribution\x18\a \x03(\v24.matching.MatchingStats.VehicleTypeDistributionEntryR\x17vehicleTypeDistribution\x1aJ\n" +
        "\x1cVehicleTypeDistributionEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"c\n" +
        "\x18GetMatchingStatsResponse\x12-\n" +
        "\x05stats\x18\x01 \x01(\v2\x17.matching.MatchingStatsR\x05stats\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess2\xe2\x05\n" +
        "\x0fMatchingService\x12\\\n" +
        "\x11FindNearbyDrivers\x12\".matching.FindNearbyDriversRequest\x1a#.matching.FindNearbyDriversResponse\x12J\n" +
        "\vMatchDriver\x12\x1c.matching.MatchDriverRequest\x1a\x1d.matching.MatchDriverResponse\x12e\n" +
        "\x14UpdateDriverLocation\x12%.matching.UpdateDriverLocationRequest\x1a&amp;.matching.UpdateDriverLocationResponse\x12D\n" +
        "\tGetDriver\x12\x1a.matching.GetDriverRequest\x1a\x1b.matching.GetDriverResponse\x12Y\n" +
        "\x10GetActiveDrivers\x12!.matching.GetActiveDriversRequest\x1a\".matching.GetActiveDriversResponse\x12_\n" +
        "\x12BatchUpdateDrivers\x12#.matching.BatchUpdateDriversRequest\x1a$.matching.BatchUpdateDriversResponse\x12Y\n" +
        "\x10GetMatchingStats\x12!.matching.GetMatchingStatsRequest\x1a\".matching.GetMatchingStatsResponse\x12a\n" +
        "\x13StreamDriverUpdates\x12\x1e.matching.DriverLocationUpdate\x1a&amp;.matching.UpdateDriverLocationResponse(\x010\x01B5Z3github.com/rideshare-platform/shared/proto/matchingb\x06proto3"

var (
        file_shared_proto_matching_matching_proto_rawDescOnce sync.Once
        file_shared_proto_matching_matching_proto_rawDescData []byte
)

func file_shared_proto_matching_matching_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_shared_proto_matching_matching_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_shared_proto_matching_matching_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_matching_matching_proto_rawDesc), len(file_shared_proto_matching_matching_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_shared_proto_matching_matching_proto_rawDescData</span>
}

var file_shared_proto_matching_matching_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_shared_proto_matching_matching_proto_goTypes = []any{
        (*Location)(nil),                     // 0: matching.Location
        (*Driver)(nil),                       // 1: matching.Driver
        (*MatchingScore)(nil),                // 2: matching.MatchingScore
        (*RideRequest)(nil),                  // 3: matching.RideRequest
        (*MatchResult)(nil),                  // 4: matching.MatchResult
        (*MatchingMetadata)(nil),             // 5: matching.MatchingMetadata
        (*DriverLocationUpdate)(nil),         // 6: matching.DriverLocationUpdate
        (*FindNearbyDriversRequest)(nil),     // 7: matching.FindNearbyDriversRequest
        (*FindNearbyDriversResponse)(nil),    // 8: matching.FindNearbyDriversResponse
        (*MatchDriverRequest)(nil),           // 9: matching.MatchDriverRequest
        (*MatchingPreferences)(nil),          // 10: matching.MatchingPreferences
        (*MatchDriverResponse)(nil),          // 11: matching.MatchDriverResponse
        (*UpdateDriverLocationRequest)(nil),  // 12: matching.UpdateDriverLocationRequest
        (*UpdateDriverLocationResponse)(nil), // 13: matching.UpdateDriverLocationResponse
        (*GetDriverRequest)(nil),             // 14: matching.GetDriverRequest
        (*GetDriverResponse)(nil),            // 15: matching.GetDriverResponse
        (*GetActiveDriversRequest)(nil),      // 16: matching.GetActiveDriversRequest
        (*GetActiveDriversResponse)(nil),     // 17: matching.GetActiveDriversResponse
        (*BatchUpdateDriversRequest)(nil),    // 18: matching.BatchUpdateDriversRequest
        (*BatchUpdateDriversResponse)(nil),   // 19: matching.BatchUpdateDriversResponse
        (*GetMatchingStatsRequest)(nil),      // 20: matching.GetMatchingStatsRequest
        (*MatchingStats)(nil),                // 21: matching.MatchingStats
        (*GetMatchingStatsResponse)(nil),     // 22: matching.GetMatchingStatsResponse
        nil,                                  // 23: matching.RideRequest.PreferencesEntry
        nil,                                  // 24: matching.MatchingMetadata.AlgorithmWeightsEntry
        nil,                                  // 25: matching.FindNearbyDriversRequest.FiltersEntry
        nil,                                  // 26: matching.MatchingPreferences.CustomPreferencesEntry
        nil,                                  // 27: matching.MatchingStats.VehicleTypeDistributionEntry
        (*timestamppb.Timestamp)(nil),        // 28: google.protobuf.Timestamp
}
var file_shared_proto_matching_matching_proto_depIdxs = []int32{
        0,  // 0: matching.Driver.current_location:type_name -&gt; matching.Location
        2,  // 1: matching.Driver.score:type_name -&gt; matching.MatchingScore
        0,  // 2: matching.RideRequest.pickup_location:type_name -&gt; matching.Location
        0,  // 3: matching.RideRequest.destination:type_name -&gt; matching.Location
        28, // 4: matching.RideRequest.requested_at:type_name -&gt; google.protobuf.Timestamp
        23, // 5: matching.RideRequest.preferences:type_name -&gt; matching.RideRequest.PreferencesEntry
        1,  // 6: matching.MatchResult.matched_drivers:type_name -&gt; matching.Driver
        1,  // 7: matching.MatchResult.best_match:type_name -&gt; matching.Driver
        5,  // 8: matching.MatchResult.metadata:type_name -&gt; matching.MatchingMetadata
        24, // 9: matching.MatchingMetadata.algorithm_weights:type_name -&gt; matching.MatchingMetadata.AlgorithmWeightsEntry
        0,  // 10: matching.DriverLocationUpdate.location:type_name -&gt; matching.Location
        28, // 11: matching.DriverLocationUpdate.timestamp:type_name -&gt; google.protobuf.Timestamp
        0,  // 12: matching.FindNearbyDriversRequest.pickup_location:type_name -&gt; matching.Location
        25, // 13: matching.FindNearbyDriversRequest.filters:type_name -&gt; matching.FindNearbyDriversRequest.FiltersEntry
        1,  // 14: matching.FindNearbyDriversResponse.drivers:type_name -&gt; matching.Driver
        5,  // 15: matching.FindNearbyDriversResponse.metadata:type_name -&gt; matching.MatchingMetadata
        3,  // 16: matching.MatchDriverRequest.ride_request:type_name -&gt; matching.RideRequest
        10, // 17: matching.MatchDriverRequest.preferences:type_name -&gt; matching.MatchingPreferences
        26, // 18: matching.MatchingPreferences.custom_preferences:type_name -&gt; matching.MatchingPreferences.CustomPreferencesEntry
        4,  // 19: matching.MatchDriverResponse.result:type_name -&gt; matching.MatchResult
        0,  // 20: matching.UpdateDriverLocationRequest.location:type_name -&gt; matching.Location
        1,  // 21: matching.GetDriverResponse.driver:type_name -&gt; matching.Driver
        0,  // 22: matching.GetActiveDriversRequest.center:type_name -&gt; matching.Location
        1,  // 23: matching.GetActiveDriversResponse.drivers:type_name -&gt; matching.Driver
        5,  // 24: matching.GetActiveDriversResponse.metadata:type_name -&gt; matching.MatchingMetadata
        6,  // 25: matching.BatchUpdateDriversRequest.updates:type_name -&gt; matching.DriverLocationUpdate
        28, // 26: matching.GetMatchingStatsRequest.from_time:type_name -&gt; google.protobuf.Timestamp
        28, // 27: matching.GetMatchingStatsRequest.to_time:type_name -&gt; google.protobuf.Timestamp
        27, // 28: matching.MatchingStats.vehicle_type_distribution:type_name -&gt; matching.MatchingStats.VehicleTypeDistributionEntry
        21, // 29: matching.GetMatchingStatsResponse.stats:type_name -&gt; matching.MatchingStats
        7,  // 30: matching.MatchingService.FindNearbyDrivers:input_type -&gt; matching.FindNearbyDriversRequest
        9,  // 31: matching.MatchingService.MatchDriver:input_type -&gt; matching.MatchDriverRequest
        12, // 32: matching.MatchingService.UpdateDriverLocation:input_type -&gt; matching.UpdateDriverLocationRequest
        14, // 33: matching.MatchingService.GetDriver:input_type -&gt; matching.GetDriverRequest
        16, // 34: matching.MatchingService.GetActiveDrivers:input_type -&gt; matching.GetActiveDriversRequest
        18, // 35: matching.MatchingService.BatchUpdateDrivers:input_type -&gt; matching.BatchUpdateDriversRequest
        20, // 36: matching.MatchingService.GetMatchingStats:input_type -&gt; matching.GetMatchingStatsRequest
        6,  // 37: matching.MatchingService.StreamDriverUpdates:input_type -&gt; matching.DriverLocationUpdate
        8,  // 38: matching.MatchingService.FindNearbyDrivers:output_type -&gt; matching.FindNearbyDriversResponse
        11, // 39: matching.MatchingService.MatchDriver:output_type -&gt; matching.MatchDriverResponse
        13, // 40: matching.MatchingService.UpdateDriverLocation:output_type -&gt; matching.UpdateDriverLocationResponse
        15, // 41: matching.MatchingService.GetDriver:output_type -&gt; matching.GetDriverResponse
        17, // 42: matching.MatchingService.GetActiveDrivers:output_type -&gt; matching.GetActiveDriversResponse
        19, // 43: matching.MatchingService.BatchUpdateDrivers:output_type -&gt; matching.BatchUpdateDriversResponse
        22, // 44: matching.MatchingService.GetMatchingStats:output_type -&gt; matching.GetMatchingStatsResponse
        13, // 45: matching.MatchingService.StreamDriverUpdates:output_type -&gt; matching.UpdateDriverLocationResponse
        38, // [38:46] is the sub-list for method output_type
        30, // [30:38] is the sub-list for method input_type
        30, // [30:30] is the sub-list for extension type_name
        30, // [30:30] is the sub-list for extension extendee
        0,  // [0:30] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_shared_proto_matching_matching_proto_init() }</span>
func file_shared_proto_matching_matching_proto_init() <span class="cov0" title="0">{
        if File_shared_proto_matching_matching_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_matching_matching_proto_rawDesc), len(file_shared_proto_matching_matching_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   28,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_shared_proto_matching_matching_proto_goTypes,
                DependencyIndexes: file_shared_proto_matching_matching_proto_depIdxs,
                MessageInfos:      file_shared_proto_matching_matching_proto_msgTypes,
        }.Build()
        File_shared_proto_matching_matching_proto = out.File
        file_shared_proto_matching_matching_proto_goTypes = nil
        file_shared_proto_matching_matching_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/matching/matching.proto

package matching

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        MatchingService_FindNearbyDrivers_FullMethodName    = "/matching.MatchingService/FindNearbyDrivers"
        MatchingService_MatchDriver_FullMethodName          = "/matching.MatchingService/MatchDriver"
        MatchingService_UpdateDriverLocation_FullMethodName = "/matching.MatchingService/UpdateDriverLocation"
        MatchingService_GetDriver_FullMethodName            = "/matching.MatchingService/GetDriver"
        MatchingService_GetActiveDrivers_FullMethodName     = "/matching.MatchingService/GetActiveDrivers"
        MatchingService_BatchUpdateDrivers_FullMethodName   = "/matching.MatchingService/BatchUpdateDrivers"
        MatchingService_GetMatchingStats_FullMethodName     = "/matching.MatchingService/GetMatchingStats"
        MatchingService_StreamDriverUpdates_FullMethodName  = "/matching.MatchingService/StreamDriverUpdates"
)

// MatchingServiceClient is the client API for MatchingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MatchingService defines the gRPC service for driver-rider matching
type MatchingServiceClient interface {
        FindNearbyDrivers(ctx context.Context, in *FindNearbyDriversRequest, opts ...grpc.CallOption) (*FindNearbyDriversResponse, error)
        MatchDriver(ctx context.Context, in *MatchDriverRequest, opts ...grpc.CallOption) (*MatchDriverResponse, error)
        UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error)
        GetDriver(ctx context.Context, in *GetDriverRequest, opts ...grpc.CallOption) (*GetDriverResponse, error)
        GetActiveDrivers(ctx context.Context, in *GetActiveDriversRequest, opts ...grpc.CallOption) (*GetActiveDriversResponse, error)
        BatchUpdateDrivers(ctx context.Context, in *BatchUpdateDriversRequest, opts ...grpc.CallOption) (*BatchUpdateDriversResponse, error)
        GetMatchingStats(ctx context.Context, in *GetMatchingStatsRequest, opts ...grpc.CallOption) (*GetMatchingStatsResponse, error)
        // Real-time streaming
        StreamDriverUpdates(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DriverLocationUpdate, UpdateDriverLocationResponse], error)
}

type matchingServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewMatchingServiceClient(cc grpc.ClientConnInterface) MatchingServiceClient <span class="cov0" title="0">{
        return &amp;matchingServiceClient{cc}
}</span>

func (c *matchingServiceClient) FindNearbyDrivers(ctx context.Context, in *FindNearbyDriversRequest, opts ...grpc.CallOption) (*FindNearbyDriversResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(FindNearbyDriversResponse)
        err := c.cc.Invoke(ctx, MatchingService_FindNearbyDrivers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) MatchDriver(ctx context.Context, in *MatchDriverRequest, opts ...grpc.CallOption) (*MatchDriverResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(MatchDriverResponse)
        err := c.cc.Invoke(ctx, MatchingService_MatchDriver_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateDriverLocationResponse)
        err := c.cc.Invoke(ctx, MatchingService_UpdateDriverLocation_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) GetDriver(ctx context.Context, in *GetDriverRequest, opts ...grpc.CallOption) (*GetDriverResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetDriverResponse)
        err := c.cc.Invoke(ctx, MatchingService_GetDriver_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) GetActiveDrivers(ctx context.Context, in *GetActiveDriversRequest, opts ...grpc.CallOption) (*GetActiveDriversResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetActiveDriversResponse)
        err := c.cc.Invoke(ctx, MatchingService_GetActiveDrivers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) BatchUpdateDrivers(ctx context.Context, in *BatchUpdateDriversRequest, opts ...grpc.CallOption) (*BatchUpdateDriversResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(BatchUpdateDriversResponse)
        err := c.cc.Invoke(ctx, MatchingService_BatchUpdateDrivers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) GetMatchingStats(ctx context.Context, in *GetMatchingStatsRequest, opts ...grpc.CallOption) (*GetMatchingStatsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetMatchingStatsResponse)
        err := c.cc.Invoke(ctx, MatchingService_GetMatchingStats_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *matchingServiceClient) StreamDriverUpdates(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[DriverLocationUpdate, UpdateDriverLocationResponse], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;MatchingService_ServiceDesc.Streams[0], MatchingService_StreamDriverUpdates_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[DriverLocationUpdate, UpdateDriverLocationResponse]{ClientStream: stream}
        return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MatchingService_StreamDriverUpdatesClient = grpc.BidiStreamingClient[DriverLocationUpdate, UpdateDriverLocationResponse]

// MatchingServiceServer is the server API for MatchingService service.
// All implementations must embed UnimplementedMatchingServiceServer
// for forward compatibility.
//
// MatchingService defines the gRPC service for driver-rider matching
type MatchingServiceServer interface {
        FindNearbyDrivers(context.Context, *FindNearbyDriversRequest) (*FindNearbyDriversResponse, error)
        MatchDriver(context.Context, *MatchDriverRequest) (*MatchDriverResponse, error)
        UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error)
        GetDriver(context.Context, *GetDriverRequest) (*GetDriverResponse, error)
        GetActiveDrivers(context.Context, *GetActiveDriversRequest) (*GetActiveDriversResponse, error)
        BatchUpdateDrivers(context.Context, *BatchUpdateDriversRequest) (*BatchUpdateDriversResponse, error)
        GetMatchingStats(context.Context, *GetMatchingStatsRequest) (*GetMatchingStatsResponse, error)
        // Real-time streaming
        StreamDriverUpdates(grpc.BidiStreamingServer[DriverLocationUpdate, UpdateDriverLocationResponse]) error
        mustEmbedUnimplementedMatchingServiceServer()
}

// UnimplementedMatchingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMatchingServiceServer struct{}

func (UnimplementedMatchingServiceServer) FindNearbyDrivers(context.Context, *FindNearbyDriversRequest) (*FindNearbyDriversResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method FindNearbyDrivers not implemented")
}</span>
func (UnimplementedMatchingServiceServer) MatchDriver(context.Context, *MatchDriverRequest) (*MatchDriverResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method MatchDriver not implemented")
}</span>
func (UnimplementedMatchingServiceServer) UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateDriverLocation not implemented")
}</span>
func (UnimplementedMatchingServiceServer) GetDriver(context.Context, *GetDriverRequest) (*GetDriverResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetDriver not implemented")
}</span>
func (UnimplementedMatchingServiceServer) GetActiveDrivers(context.Context, *GetActiveDriversRequest) (*GetActiveDriversResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetActiveDrivers not implemented")
}</span>
func (UnimplementedMatchingServiceServer) BatchUpdateDrivers(context.Context, *BatchUpdateDriversRequest) (*BatchUpdateDriversResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateDrivers not implemented")
}</span>
func (UnimplementedMatchingServiceServer) GetMatchingStats(context.Context, *GetMatchingStatsRequest) (*GetMatchingStatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMatchingStats not implemented")
}</span>
func (UnimplementedMatchingServiceServer) StreamDriverUpdates(grpc.BidiStreamingServer[DriverLocationUpdate, UpdateDriverLocationResponse]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method StreamDriverUpdates not implemented")
}</span>
func (UnimplementedMatchingServiceServer) mustEmbedUnimplementedMatchingServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedMatchingServiceServer) testEmbeddedByValue()                         {<span class="cov0" title="0">}</span>

// UnsafeMatchingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MatchingServiceServer will
// result in compilation errors.
type UnsafeMatchingServiceServer interface {
        mustEmbedUnimplementedMatchingServiceServer()
}

func RegisterMatchingServiceServer(s grpc.ServiceRegistrar, srv MatchingServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedMatchingServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;MatchingService_ServiceDesc, srv)</span>
}

func _MatchingService_FindNearbyDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(FindNearbyDriversRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).FindNearbyDrivers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_FindNearbyDrivers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).FindNearbyDrivers(ctx, req.(*FindNearbyDriversRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_MatchDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(MatchDriverRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).MatchDriver(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_MatchDriver_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).MatchDriver(ctx, req.(*MatchDriverRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_UpdateDriverLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateDriverLocationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).UpdateDriverLocation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_UpdateDriverLocation_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).UpdateDriverLocation(ctx, req.(*UpdateDriverLocationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_GetDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetDriverRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).GetDriver(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_GetDriver_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).GetDriver(ctx, req.(*GetDriverRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_GetActiveDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetActiveDriversRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).GetActiveDrivers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_GetActiveDrivers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).GetActiveDrivers(ctx, req.(*GetActiveDriversRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_BatchUpdateDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(BatchUpdateDriversRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).BatchUpdateDrivers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_BatchUpdateDrivers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).BatchUpdateDrivers(ctx, req.(*BatchUpdateDriversRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_GetMatchingStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetMatchingStatsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).GetMatchingStats(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: MatchingService_GetMatchingStats_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MatchingServiceServer).GetMatchingStats(ctx, req.(*GetMatchingStatsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _MatchingService_StreamDriverUpdates_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MatchingServiceServer).StreamDriverUpdates(&amp;grpc.GenericServerStream[DriverLocationUpdate, UpdateDriverLocationResponse]{ServerStream: stream})
}</span>

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MatchingService_StreamDriverUpdatesServer = grpc.BidiStreamingServer[DriverLocationUpdate, UpdateDriverLocationResponse]

// MatchingService_ServiceDesc is the grpc.ServiceDesc for MatchingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MatchingService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "matching.MatchingService",
        HandlerType: (*MatchingServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "FindNearbyDrivers",
                        Handler:    _MatchingService_FindNearbyDrivers_Handler,
                },
                {
                        MethodName: "MatchDriver",
                        Handler:    _MatchingService_MatchDriver_Handler,
                },
                {
                        MethodName: "UpdateDriverLocation",
                        Handler:    _MatchingService_UpdateDriverLocation_Handler,
                },
                {
                        MethodName: "GetDriver",
                        Handler:    _MatchingService_GetDriver_Handler,
                },
                {
                        MethodName: "GetActiveDrivers",
                        Handler:    _MatchingService_GetActiveDrivers_Handler,
                },
                {
                        MethodName: "BatchUpdateDrivers",
                        Handler:    _MatchingService_BatchUpdateDrivers_Handler,
                },
                {
                        MethodName: "GetMatchingStats",
                        Handler:    _MatchingService_GetMatchingStats_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "StreamDriverUpdates",
                        Handler:       _MatchingService_StreamDriverUpdates_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "shared/proto/matching/matching.proto",
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v3.21.12
// source: shared/proto/payment/payment.proto

package payment

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Payment method enumeration
type PaymentMethod int32

const (
        PaymentMethod_UNKNOWN_PAYMENT_METHOD PaymentMethod = 0
        PaymentMethod_CREDIT_CARD            PaymentMethod = 1
        PaymentMethod_DEBIT_CARD             PaymentMethod = 2
        PaymentMethod_DIGITAL_WALLET         PaymentMethod = 3
        PaymentMethod_BANK_TRANSFER          PaymentMethod = 4
        PaymentMethod_CASH                   PaymentMethod = 5
)

// Enum value maps for PaymentMethod.
var (
        PaymentMethod_name = map[int32]string{
                0: "UNKNOWN_PAYMENT_METHOD",
                1: "CREDIT_CARD",
                2: "DEBIT_CARD",
                3: "DIGITAL_WALLET",
                4: "BANK_TRANSFER",
                5: "CASH",
        }
        PaymentMethod_value = map[string]int32{
                "UNKNOWN_PAYMENT_METHOD": 0,
                "CREDIT_CARD":            1,
                "DEBIT_CARD":             2,
                "DIGITAL_WALLET":         3,
                "BANK_TRANSFER":          4,
                "CASH":                   5,
        }
)

func (x PaymentMethod) Enum() *PaymentMethod <span class="cov0" title="0">{
        p := new(PaymentMethod)
        *p = x
        return p
}</span>

func (x PaymentMethod) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (PaymentMethod) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_enumTypes[0].Descriptor()
}</span>

func (PaymentMethod) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_payment_payment_proto_enumTypes[0]
}</span>

func (x PaymentMethod) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use PaymentMethod.Descriptor instead.
func (PaymentMethod) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{0}
}</span>

// Payment status enumeration
type PaymentStatus int32

const (
        PaymentStatus_UNKNOWN_PAYMENT_STATUS PaymentStatus = 0
        PaymentStatus_PENDING                PaymentStatus = 1
        PaymentStatus_PROCESSING             PaymentStatus = 2
        PaymentStatus_COMPLETED              PaymentStatus = 3
        PaymentStatus_FAILED                 PaymentStatus = 4
        PaymentStatus_REFUNDED               PaymentStatus = 5
        PaymentStatus_CANCELLED              PaymentStatus = 6
        PaymentStatus_CHARGEBACK             PaymentStatus = 7
)

// Enum value maps for PaymentStatus.
var (
        PaymentStatus_name = map[int32]string{
                0: "UNKNOWN_PAYMENT_STATUS",
                1: "PENDING",
                2: "PROCESSING",
                3: "COMPLETED",
                4: "FAILED",
                5: "REFUNDED",
                6: "CANCELLED",
                7: "CHARGEBACK",
        }
        PaymentStatus_value = map[string]int32{
                "UNKNOWN_PAYMENT_STATUS": 0,
                "PENDING":                1,
                "PROCESSING":             2,
                "COMPLETED":              3,
                "FAILED":                 4,
                "REFUNDED":               5,
                "CANCELLED":              6,
                "CHARGEBACK":             7,
        }
)

func (x PaymentStatus) Enum() *PaymentStatus <span class="cov0" title="0">{
        p := new(PaymentStatus)
        *p = x
        return p
}</span>

func (x PaymentStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (PaymentStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_enumTypes[1].Descriptor()
}</span>

func (PaymentStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_payment_payment_proto_enumTypes[1]
}</span>

func (x PaymentStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use PaymentStatus.Descriptor instead.
func (PaymentStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{1}
}</span>

// Transaction type enumeration
type TransactionType int32

const (
        TransactionType_UNKNOWN_TRANSACTION_TYPE TransactionType = 0
        TransactionType_PAYMENT                  TransactionType = 1
        TransactionType_REFUND                   TransactionType = 2
        TransactionType_CHARGEBACK_TXN           TransactionType = 3
        TransactionType_AUTHORIZATION            TransactionType = 4
        TransactionType_CAPTURE                  TransactionType = 5
)

// Enum value maps for TransactionType.
var (
        TransactionType_name = map[int32]string{
                0: "UNKNOWN_TRANSACTION_TYPE",
                1: "PAYMENT",
                2: "REFUND",
                3: "CHARGEBACK_TXN",
                4: "AUTHORIZATION",
                5: "CAPTURE",
        }
        TransactionType_value = map[string]int32{
                "UNKNOWN_TRANSACTION_TYPE": 0,
                "PAYMENT":                  1,
                "REFUND":                   2,
                "CHARGEBACK_TXN":           3,
                "AUTHORIZATION":            4,
                "CAPTURE":                  5,
        }
)

func (x TransactionType) Enum() *TransactionType <span class="cov0" title="0">{
        p := new(TransactionType)
        *p = x
        return p
}</span>

func (x TransactionType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TransactionType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_enumTypes[2].Descriptor()
}</span>

func (TransactionType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_payment_payment_proto_enumTypes[2]
}</span>

func (x TransactionType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TransactionType.Descriptor instead.
func (TransactionType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{2}
}</span>

// Fraud risk level enumeration
type FraudRiskLevel int32

const (
        FraudRiskLevel_UNKNOWN_FRAUD_RISK FraudRiskLevel = 0
        FraudRiskLevel_LOW                FraudRiskLevel = 1
        FraudRiskLevel_MEDIUM             FraudRiskLevel = 2
        FraudRiskLevel_HIGH               FraudRiskLevel = 3
)

// Enum value maps for FraudRiskLevel.
var (
        FraudRiskLevel_name = map[int32]string{
                0: "UNKNOWN_FRAUD_RISK",
                1: "LOW",
                2: "MEDIUM",
                3: "HIGH",
        }
        FraudRiskLevel_value = map[string]int32{
                "UNKNOWN_FRAUD_RISK": 0,
                "LOW":                1,
                "MEDIUM":             2,
                "HIGH":               3,
        }
)

func (x FraudRiskLevel) Enum() *FraudRiskLevel <span class="cov0" title="0">{
        p := new(FraudRiskLevel)
        *p = x
        return p
}</span>

func (x FraudRiskLevel) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (FraudRiskLevel) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_enumTypes[3].Descriptor()
}</span>

func (FraudRiskLevel) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_payment_payment_proto_enumTypes[3]
}</span>

func (x FraudRiskLevel) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use FraudRiskLevel.Descriptor instead.
func (FraudRiskLevel) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{3}
}</span>

// Payment represents a payment transaction
type Payment struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        Id                string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        TripId            string                 `protobuf:"bytes,2,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        UserId            string                 `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        DriverId          string                 `protobuf:"bytes,4,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Amount            float64                `protobuf:"fixed64,5,opt,name=amount,proto3" json:"amount,omitempty"`
        Currency          string                 `protobuf:"bytes,6,opt,name=currency,proto3" json:"currency,omitempty"`
        PaymentMethod     PaymentMethod          `protobuf:"varint,7,opt,name=payment_method,json=paymentMethod,proto3,enum=payment.PaymentMethod" json:"payment_method,omitempty"`
        Status            PaymentStatus          `protobuf:"varint,8,opt,name=status,proto3,enum=payment.PaymentStatus" json:"status,omitempty"`
        TransactionType   TransactionType        `protobuf:"varint,9,opt,name=transaction_type,json=transactionType,proto3,enum=payment.TransactionType" json:"transaction_type,omitempty"`
        ProcessorResponse string                 `protobuf:"bytes,10,opt,name=processor_response,json=processorResponse,proto3" json:"processor_response,omitempty"`
        FraudRisk         FraudRiskLevel         `protobuf:"varint,11,opt,name=fraud_risk,json=fraudRisk,proto3,enum=payment.FraudRiskLevel" json:"fraud_risk,omitempty"`
        FraudScores       map[string]float64     `protobuf:"bytes,12,rep,name=fraud_scores,json=fraudScores,proto3" json:"fraud_scores,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
        Metadata          map[string]string      `protobuf:"bytes,13,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        FailureReason     string                 `protobuf:"bytes,14,opt,name=failure_reason,json=failureReason,proto3" json:"failure_reason,omitempty"`
        ProcessedAt       *timestamppb.Timestamp `protobuf:"bytes,15,opt,name=processed_at,json=processedAt,proto3" json:"processed_at,omitempty"`
        CreatedAt         *timestamppb.Timestamp `protobuf:"bytes,16,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt         *timestamppb.Timestamp `protobuf:"bytes,17,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *Payment) Reset() <span class="cov0" title="0">{
        *x = Payment{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Payment) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Payment) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Payment) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Payment.ProtoReflect.Descriptor instead.
func (*Payment) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Payment) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Payment) GetCurrency() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Currency
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetPaymentMethod() PaymentMethod <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentMethod
        }</span>
        <span class="cov0" title="0">return PaymentMethod_UNKNOWN_PAYMENT_METHOD</span>
}

func (x *Payment) GetStatus() PaymentStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return PaymentStatus_UNKNOWN_PAYMENT_STATUS</span>
}

func (x *Payment) GetTransactionType() TransactionType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TransactionType
        }</span>
        <span class="cov0" title="0">return TransactionType_UNKNOWN_TRANSACTION_TYPE</span>
}

func (x *Payment) GetProcessorResponse() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProcessorResponse
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetFraudRisk() FraudRiskLevel <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FraudRisk
        }</span>
        <span class="cov0" title="0">return FraudRiskLevel_UNKNOWN_FRAUD_RISK</span>
}

func (x *Payment) GetFraudScores() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FraudScores
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Payment) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Payment) GetFailureReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FailureReason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Payment) GetProcessedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProcessedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Payment) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Payment) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Payment method details
type PaymentMethodDetails struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        UserId         string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Type           PaymentMethod          `protobuf:"varint,3,opt,name=type,proto3,enum=payment.PaymentMethod" json:"type,omitempty"`
        IsDefault      bool                   `protobuf:"varint,4,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
        Fingerprint    string                 `protobuf:"bytes,5,opt,name=fingerprint,proto3" json:"fingerprint,omitempty"`
        ExpiryDate     *timestamppb.Timestamp `protobuf:"bytes,6,opt,name=expiry_date,json=expiryDate,proto3" json:"expiry_date,omitempty"`
        LastFourDigits string                 `protobuf:"bytes,7,opt,name=last_four_digits,json=lastFourDigits,proto3" json:"last_four_digits,omitempty"`
        BankName       string                 `protobuf:"bytes,8,opt,name=bank_name,json=bankName,proto3" json:"bank_name,omitempty"`
        WalletProvider string                 `protobuf:"bytes,9,opt,name=wallet_provider,json=walletProvider,proto3" json:"wallet_provider,omitempty"`
        Details        map[string]string      `protobuf:"bytes,10,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        CreatedAt      *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt      *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *PaymentMethodDetails) Reset() <span class="cov0" title="0">{
        *x = PaymentMethodDetails{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PaymentMethodDetails) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PaymentMethodDetails) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PaymentMethodDetails) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PaymentMethodDetails.ProtoReflect.Descriptor instead.
func (*PaymentMethodDetails) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PaymentMethodDetails) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PaymentMethodDetails) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PaymentMethodDetails) GetType() PaymentMethod <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return PaymentMethod_UNKNOWN_PAYMENT_METHOD</span>
}

func (x *PaymentMethodDetails) GetIsDefault() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsDefault
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *PaymentMethodDetails) GetFingerprint() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fingerprint
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PaymentMethodDetails) GetExpiryDate() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiryDate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PaymentMethodDetails) GetLastFourDigits() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastFourDigits
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PaymentMethodDetails) GetBankName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BankName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PaymentMethodDetails) GetWalletProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WalletProvider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PaymentMethodDetails) GetDetails() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PaymentMethodDetails) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PaymentMethodDetails) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Fraud detection result
type FraudDetectionResult struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        TransactionId  string                 `protobuf:"bytes,1,opt,name=transaction_id,json=transactionId,proto3" json:"transaction_id,omitempty"`
        RiskLevel      FraudRiskLevel         `protobuf:"varint,2,opt,name=risk_level,json=riskLevel,proto3,enum=payment.FraudRiskLevel" json:"risk_level,omitempty"`
        RiskScore      float64                `protobuf:"fixed64,3,opt,name=risk_score,json=riskScore,proto3" json:"risk_score,omitempty"`
        Reasons        []string               `protobuf:"bytes,4,rep,name=reasons,proto3" json:"reasons,omitempty"`
        Scores         map[string]float64     `protobuf:"bytes,5,rep,name=scores,proto3" json:"scores,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
        RequiresReview bool                   `protobuf:"varint,6,opt,name=requires_review,json=requiresReview,proto3" json:"requires_review,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *FraudDetectionResult) Reset() <span class="cov0" title="0">{
        *x = FraudDetectionResult{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FraudDetectionResult) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FraudDetectionResult) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FraudDetectionResult) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FraudDetectionResult.ProtoReflect.Descriptor instead.
func (*FraudDetectionResult) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FraudDetectionResult) GetTransactionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TransactionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FraudDetectionResult) GetRiskLevel() FraudRiskLevel <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiskLevel
        }</span>
        <span class="cov0" title="0">return FraudRiskLevel_UNKNOWN_FRAUD_RISK</span>
}

func (x *FraudDetectionResult) GetRiskScore() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiskScore
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FraudDetectionResult) GetReasons() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reasons
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FraudDetectionResult) GetScores() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Scores
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FraudDetectionResult) GetRequiresReview() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiresReview
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Request/Response messages
type ProcessPaymentRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        TripId          string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        UserId          string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        DriverId        string                 `protobuf:"bytes,3,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Amount          float64                `protobuf:"fixed64,4,opt,name=amount,proto3" json:"amount,omitempty"`
        Currency        string                 `protobuf:"bytes,5,opt,name=currency,proto3" json:"currency,omitempty"`
        PaymentMethodId string                 `protobuf:"bytes,6,opt,name=payment_method_id,json=paymentMethodId,proto3" json:"payment_method_id,omitempty"`
        Description     string                 `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
        Metadata        map[string]string      `protobuf:"bytes,8,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *ProcessPaymentRequest) Reset() <span class="cov0" title="0">{
        *x = ProcessPaymentRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessPaymentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessPaymentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessPaymentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessPaymentRequest.ProtoReflect.Descriptor instead.
func (*ProcessPaymentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{3}
}</span>

func (x *ProcessPaymentRequest) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentRequest) GetAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ProcessPaymentRequest) GetCurrency() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Currency
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentRequest) GetPaymentMethodId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentMethodId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentRequest) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentRequest) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ProcessPaymentResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Payment       *Payment               `protobuf:"bytes,1,opt,name=payment,proto3" json:"payment,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessPaymentResponse) Reset() <span class="cov0" title="0">{
        *x = ProcessPaymentResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessPaymentResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessPaymentResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessPaymentResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessPaymentResponse.ProtoReflect.Descriptor instead.
func (*ProcessPaymentResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{4}
}</span>

func (x *ProcessPaymentResponse) GetPayment() *Payment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payment
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProcessPaymentResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ProcessPaymentResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessPaymentResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ProcessRefundRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PaymentId     string                 `protobuf:"bytes,1,opt,name=payment_id,json=paymentId,proto3" json:"payment_id,omitempty"`
        Amount        float64                `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount,omitempty"`
        Reason        string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
        RequestedBy   string                 `protobuf:"bytes,4,opt,name=requested_by,json=requestedBy,proto3" json:"requested_by,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessRefundRequest) Reset() <span class="cov0" title="0">{
        *x = ProcessRefundRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessRefundRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessRefundRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessRefundRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessRefundRequest.ProtoReflect.Descriptor instead.
func (*ProcessRefundRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{5}
}</span>

func (x *ProcessRefundRequest) GetPaymentId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessRefundRequest) GetAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ProcessRefundRequest) GetReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessRefundRequest) GetRequestedBy() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequestedBy
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ProcessRefundResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        RefundId      string                 `protobuf:"bytes,3,opt,name=refund_id,json=refundId,proto3" json:"refund_id,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ProcessRefundResponse) Reset() <span class="cov0" title="0">{
        *x = ProcessRefundResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ProcessRefundResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProcessRefundResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProcessRefundResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProcessRefundResponse.ProtoReflect.Descriptor instead.
func (*ProcessRefundResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{6}
}</span>

func (x *ProcessRefundResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *ProcessRefundResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessRefundResponse) GetRefundId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RefundId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProcessRefundResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type AddPaymentMethodRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Type          PaymentMethod          `protobuf:"varint,2,opt,name=type,proto3,enum=payment.PaymentMethod" json:"type,omitempty"`
        Details       map[string]string      `protobuf:"bytes,3,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        IsDefault     bool                   `protobuf:"varint,4,opt,name=is_default,json=isDefault,proto3" json:"is_default,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddPaymentMethodRequest) Reset() <span class="cov0" title="0">{
        *x = AddPaymentMethodRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddPaymentMethodRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddPaymentMethodRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddPaymentMethodRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddPaymentMethodRequest.ProtoReflect.Descriptor instead.
func (*AddPaymentMethodRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{7}
}</span>

func (x *AddPaymentMethodRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddPaymentMethodRequest) GetType() PaymentMethod <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return PaymentMethod_UNKNOWN_PAYMENT_METHOD</span>
}

func (x *AddPaymentMethodRequest) GetDetails() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Details
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AddPaymentMethodRequest) GetIsDefault() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsDefault
        }</span>
        <span class="cov0" title="0">return false</span>
}

type AddPaymentMethodResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PaymentMethod *PaymentMethodDetails  `protobuf:"bytes,1,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AddPaymentMethodResponse) Reset() <span class="cov0" title="0">{
        *x = AddPaymentMethodResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AddPaymentMethodResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AddPaymentMethodResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AddPaymentMethodResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AddPaymentMethodResponse.ProtoReflect.Descriptor instead.
func (*AddPaymentMethodResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{8}
}</span>

func (x *AddPaymentMethodResponse) GetPaymentMethod() *PaymentMethodDetails <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentMethod
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AddPaymentMethodResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *AddPaymentMethodResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AddPaymentMethodResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPaymentRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        PaymentId     string                 `protobuf:"bytes,1,opt,name=payment_id,json=paymentId,proto3" json:"payment_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPaymentRequest) Reset() <span class="cov0" title="0">{
        *x = GetPaymentRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPaymentRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPaymentRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPaymentRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPaymentRequest.ProtoReflect.Descriptor instead.
func (*GetPaymentRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetPaymentRequest) GetPaymentId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetPaymentResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Payment       *Payment               `protobuf:"bytes,1,opt,name=payment,proto3" json:"payment,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPaymentResponse) Reset() <span class="cov0" title="0">{
        *x = GetPaymentResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPaymentResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPaymentResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPaymentResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPaymentResponse.ProtoReflect.Descriptor instead.
func (*GetPaymentResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetPaymentResponse) GetPayment() *Payment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payment
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPaymentResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetUserPaymentMethodsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserPaymentMethodsRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserPaymentMethodsRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserPaymentMethodsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserPaymentMethodsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserPaymentMethodsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserPaymentMethodsRequest.ProtoReflect.Descriptor instead.
func (*GetUserPaymentMethodsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetUserPaymentMethodsRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserPaymentMethodsResponse struct {
        state          protoimpl.MessageState  `protogen:"open.v1"`
        PaymentMethods []*PaymentMethodDetails `protobuf:"bytes,1,rep,name=payment_methods,json=paymentMethods,proto3" json:"payment_methods,omitempty"`
        Count          int32                   `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *GetUserPaymentMethodsResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserPaymentMethodsResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserPaymentMethodsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserPaymentMethodsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserPaymentMethodsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserPaymentMethodsResponse.ProtoReflect.Descriptor instead.
func (*GetUserPaymentMethodsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetUserPaymentMethodsResponse) GetPaymentMethods() []*PaymentMethodDetails <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentMethods
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetUserPaymentMethodsResponse) GetCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserPaymentsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Limit         int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset        int32                  `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserPaymentsRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserPaymentsRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserPaymentsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserPaymentsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserPaymentsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserPaymentsRequest.ProtoReflect.Descriptor instead.
func (*GetUserPaymentsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{13}
}</span>

func (x *GetUserPaymentsRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserPaymentsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetUserPaymentsRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetUserPaymentsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Payments      []*Payment             `protobuf:"bytes,1,rep,name=payments,proto3" json:"payments,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        HasMore       bool                   `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserPaymentsResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserPaymentsResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserPaymentsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserPaymentsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserPaymentsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserPaymentsResponse.ProtoReflect.Descriptor instead.
func (*GetUserPaymentsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{14}
}</span>

func (x *GetUserPaymentsResponse) GetPayments() []*Payment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetUserPaymentsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetUserPaymentsResponse) GetHasMore() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasMore
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetTripPaymentsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TripId        string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTripPaymentsRequest) Reset() <span class="cov0" title="0">{
        *x = GetTripPaymentsRequest{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripPaymentsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripPaymentsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripPaymentsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripPaymentsRequest.ProtoReflect.Descriptor instead.
func (*GetTripPaymentsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{15}
}</span>

func (x *GetTripPaymentsRequest) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTripPaymentsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Payments      []*Payment             `protobuf:"bytes,1,rep,name=payments,proto3" json:"payments,omitempty"`
        Count         int32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTripPaymentsResponse) Reset() <span class="cov0" title="0">{
        *x = GetTripPaymentsResponse{}
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripPaymentsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripPaymentsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripPaymentsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_payment_payment_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripPaymentsResponse.ProtoReflect.Descriptor instead.
func (*GetTripPaymentsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_payment_payment_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetTripPaymentsResponse) GetPayments() []*Payment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Payments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTripPaymentsResponse) GetCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_shared_proto_payment_payment_proto protoreflect.FileDescriptor

const file_shared_proto_payment_payment_proto_rawDesc = "" +
        "\n" +
        "\"shared/proto/payment/payment.proto\x12\apayment\x1a\x1fgoogle/protobuf/timestamp.proto\"\x92\a\n" +
        "\aPayment\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x17\n" +
        "\atrip_id\x18\x02 \x01(\tR\x06tripId\x12\x17\n" +
        "\auser_id\x18\x03 \x01(\tR\x06userId\x12\x1b\n" +
        "\tdriver_id\x18\x04 \x01(\tR\bdriverId\x12\x16\n" +
        "\x06amount\x18\x05 \x01(\x01R\x06amount\x12\x1a\n" +
        "\bcurrency\x18\x06 \x01(\tR\bcurrency\x12=\n" +
        "\x0epayment_method\x18\a \x01(\x0e2\x16.payment.PaymentMethodR\rpaymentMethod\x12.\n" +
        "\x06status\x18\b \x01(\x0e2\x16.payment.PaymentStatusR\x06status\x12C\n" +
        "\x10transaction_type\x18\t \x01(\x0e2\x18.payment.TransactionTypeR\x0ftransactionType\x12-\n" +
        "\x12processor_response\x18\n" +
        " \x01(\tR\x11processorResponse\x126\n" +
        "\n" +
        "fraud_risk\x18\v \x01(\x0e2\x17.payment.FraudRiskLevelR\tfraudRisk\x12D\n" +
        "\ffraud_scores\x18\f \x03(\v2!.payment.Payment.FraudScoresEntryR\vfraudScores\x12:\n" +
        "\bmetadata\x18\r \x03(\v2\x1e.payment.Payment.MetadataEntryR\bmetadata\x12%\n" +
        "\x0efailure_reason\x18\x0e \x01(\tR\rfailureReason\x12=\n" +
        "\fprocessed_at\x18\x0f \x01(\v2\x1a.google.protobuf.TimestampR\vprocessedAt\x129\n" +
        "\n" +
        "created_at\x18\x10 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\x11 \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1a&gt;\n" +
        "\x10FraudScoresEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd1\x04\n" +
        "\x14PaymentMethodDetails\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\tR\x06userId\x12*\n" +
        "\x04type\x18\x03 \x01(\x0e2\x16.payment.PaymentMethodR\x04type\x12\x1d\n" +
        "\n" +
        "is_default\x18\x04 \x01(\bR\tisDefault\x12 \n" +
        "\vfingerprint\x18\x05 \x01(\tR\vfingerprint\x12;\n" +
        "\vexpiry_date\x18\x06 \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "expiryDate\x12(\n" +
        "\x10last_four_digits\x18\a \x01(\tR\x0elastFourDigits\x12\x1b\n" +
        "\tbank_name\x18\b \x01(\tR\bbankName\x12'\n" +
        "\x0fwallet_provider\x18\t \x01(\tR\x0ewalletProvider\x12D\n" +
        "\adetails\x18\n" +
        " \x03(\v2*.payment.PaymentMethodDetails.DetailsEntryR\adetails\x129\n" +
        "\n" +
        "created_at\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x1a:\n" +
        "\fDetailsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xd5\x02\n" +
        "\x14FraudDetectionResult\x12%\n" +
        "\x0etransaction_id\x18\x01 \x01(\tR\rtransactionId\x126\n" +
        "\n" +
        "risk_level\x18\x02 \x01(\x0e2\x17.payment.FraudRiskLevelR\triskLevel\x12\x1d\n" +
        "\n" +
        "risk_score\x18\x03 \x01(\x01R\triskScore\x12\x18\n" +
        "\areasons\x18\x04 \x03(\tR\areasons\x12A\n" +
        "\x06scores\x18\x05 \x03(\v2).payment.FraudDetectionResult.ScoresEntryR\x06scores\x12'\n" +
        "\x0frequires_review\x18\x06 \x01(\bR\x0erequiresReview\x1a9\n" +
        "\vScoresEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\"\xef\x02\n" +
        "\x15ProcessPaymentRequest\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\tR\x06userId\x12\x1b\n" +
        "\tdriver_id\x18\x03 \x01(\tR\bdriverId\x12\x16\n" +
        "\x06amount\x18\x04 \x01(\x01R\x06amount\x12\x1a\n" +
        "\bcurrency\x18\x05 \x01(\tR\bcurrency\x12*\n" +
        "\x11payment_method_id\x18\x06 \x01(\tR\x0fpaymentMethodId\x12 \n" +
        "\vdescription\x18\a \x01(\tR\vdescription\x12H\n" +
        "\bmetadata\x18\b \x03(\v2,.payment.ProcessPaymentRequest.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x90\x01\n" +
        "\x16ProcessPaymentResponse\x12*\n" +
        "\apayment\x18\x01 \x01(\v2\x10.payment.PaymentR\apayment\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\"\x88\x01\n" +
        "\x14ProcessRefundRequest\x12\x1d\n" +
        "\n" +
        "payment_id\x18\x01 \x01(\tR\tpaymentId\x12\x16\n" +
        "\x06amount\x18\x02 \x01(\x01R\x06amount\x12\x16\n" +
        "\x06reason\x18\x03 \x01(\tR\x06reason\x12!\n" +
        "\frequested_by\x18\x04 \x01(\tR\vrequestedBy\"\x80\x01\n" +
        "\x15ProcessRefundResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\x12\x1b\n" +
        "\trefund_id\x18\x03 \x01(\tR\brefundId\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\"\x82\x02\n" +
        "\x17AddPaymentMethodRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\x12*\n" +
        "\x04type\x18\x02 \x01(\x0e2\x16.payment.PaymentMethodR\x04type\x12G\n" +
        "\adetails\x18\x03 \x03(\v2-.payment.AddPaymentMethodRequest.DetailsEntryR\adetails\x12\x1d\n" +
        "\n" +
        "is_default\x18\x04 \x01(\bR\tisDefault\x1a:\n" +
        "\fDetailsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xac\x01\n" +
        "\x18AddPaymentMethodResponse\x12D\n" +
        "\x0epayment_method\x18\x01 \x01(\v2\x1d.payment.PaymentMethodDetailsR\rpaymentMethod\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\"2\n" +
        "\x11GetPaymentRequest\x12\x1d\n" +
        "\n" +
        "payment_id\x18\x01 \x01(\tR\tpaymentId\"V\n" +
        "\x12GetPaymentResponse\x12*\n" +
        "\apayment\x18\x01 \x01(\v2\x10.payment.PaymentR\apayment\x12\x14\n" +
        "\x05found\x18\x02 \x01(\bR\x05found\"7\n" +
        "\x1cGetUserPaymentMethodsRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\"}\n" +
        "\x1dGetUserPaymentMethodsResponse\x12F\n" +
        "\x0fpayment_methods\x18\x01 \x03(\v2\x1d.payment.PaymentMethodDetailsR\x0epaymentMethods\x12\x14\n" +
        "\x05count\x18\x02 \x01(\x05R\x05count\"_\n" +
        "\x16GetUserPaymentsRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\x12\x14\n" +
        "\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06offset\x18\x03 \x01(\x05R\x06offset\"\x83\x01\n" +
        "\x17GetUserPaymentsResponse\x12,\n" +
        "\bpayments\x18\x01 \x03(\v2\x10.payment.PaymentR\bpayments\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x12\x19\n" +
        "\bhas_more\x18\x03 \x01(\bR\ahasMore\"1\n" +
        "\x16GetTripPaymentsRequest\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\"]\n" +
        "\x17GetTripPaymentsResponse\x12,\n" +
        "\bpayments\x18\x01 \x03(\v2\x10.payment.PaymentR\bpayments\x12\x14\n" +
        "\x05count\x18\x02 \x01(\x05R\x05count*}\n" +
        "\rPaymentMethod\x12\x1a\n" +
        "\x16UNKNOWN_PAYMENT_METHOD\x10\x00\x12\x0f\n" +
        "\vCREDIT_CARD\x10\x01\x12\x0e\n" +
        "\n" +
        "DEBIT_CARD\x10\x02\x12\x12\n" +
        "\x0eDIGITAL_WALLET\x10\x03\x12\x11\n" +
        "\rBANK_TRANSFER\x10\x04\x12\b\n" +
        "\x04CASH\x10\x05*\x90\x01\n" +
        "\rPaymentStatus\x12\x1a\n" +
        "\x16UNKNOWN_PAYMENT_STATUS\x10\x00\x12\v\n" +
        "\aPENDING\x10\x01\x12\x0e\n" +
        "\n" +
        "PROCESSING\x10\x02\x12\r\n" +
        "\tCOMPLETED\x10\x03\x12\n" +
        "\n" +
        "\x06FAILED\x10\x04\x12\f\n" +
        "\bREFUNDED\x10\x05\x12\r\n" +
        "\tCANCELLED\x10\x06\x12\x0e\n" +
        "\n" +
        "CHARGEBACK\x10\a*|\n" +
        "\x0fTransactionType\x12\x1c\n" +
        "\x18UNKNOWN_TRANSACTION_TYPE\x10\x00\x12\v\n" +
        "\aPAYMENT\x10\x01\x12\n" +
        "\n" +
        "\x06REFUND\x10\x02\x12\x12\n" +
        "\x0eCHARGEBACK_TXN\x10\x03\x12\x11\n" +
        "\rAUTHORIZATION\x10\x04\x12\v\n" +
        "\aCAPTURE\x10\x05*G\n" +
        "\x0eFraudRiskLevel\x12\x16\n" +
        "\x12UNKNOWN_FRAUD_RISK\x10\x00\x12\a\n" +
        "\x03LOW\x10\x01\x12\n" +
        "\n" +
        "\x06MEDIUM\x10\x02\x12\b\n" +
        "\x04HIGH\x10\x032\xe7\x04\n" +
        "\x0ePaymentService\x12Q\n" +
        "\x0eProcessPayment\x12\x1e.payment.ProcessPaymentRequest\x1a\x1f.payment.ProcessPaymentResponse\x12N\n" +
        "\rProcessRefund\x12\x1d.payment.ProcessRefundRequest\x1a\x1e.payment.ProcessRefundResponse\x12W\n" +
        "\x10AddPaymentMethod\x12 .payment.AddPaymentMethodRequest\x1a!.payment.AddPaymentMethodResponse\x12E\n" +
        "\n" +
        "GetPayment\x12\x1a.payment.GetPaymentRequest\x1a\x1b.payment.GetPaymentResponse\x12f\n" +
        "\x15GetUserPaymentMethods\x12%.payment.GetUserPaymentMethodsRequest\x1a&amp;.payment.GetUserPaymentMethodsResponse\x12T\n" +
        "\x0fGetUserPayments\x12\x1f.payment.GetUserPaymentsRequest\x1a .payment.GetUserPaymentsResponse\x12T\n" +
        "\x0fGetTripPayments\x12\x1f.payment.GetTripPaymentsRequest\x1a .payment.GetTripPaymentsResponseB4Z2github.com/rideshare-platform/shared/proto/paymentb\x06proto3"

var (
        file_shared_proto_payment_payment_proto_rawDescOnce sync.Once
        file_shared_proto_payment_payment_proto_rawDescData []byte
)

func file_shared_proto_payment_payment_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_shared_proto_payment_payment_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_shared_proto_payment_payment_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_payment_payment_proto_rawDesc), len(file_shared_proto_payment_payment_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_shared_proto_payment_payment_proto_rawDescData</span>
}

var file_shared_proto_payment_payment_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_shared_proto_payment_payment_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_shared_proto_payment_payment_proto_goTypes = []any{
        (PaymentMethod)(0),                    // 0: payment.PaymentMethod
        (PaymentStatus)(0),                    // 1: payment.PaymentStatus
        (TransactionType)(0),                  // 2: payment.TransactionType
        (FraudRiskLevel)(0),                   // 3: payment.FraudRiskLevel
        (*Payment)(nil),                       // 4: payment.Payment
        (*PaymentMethodDetails)(nil),          // 5: payment.PaymentMethodDetails
        (*FraudDetectionResult)(nil),          // 6: payment.FraudDetectionResult
        (*ProcessPaymentRequest)(nil),         // 7: payment.ProcessPaymentRequest
        (*ProcessPaymentResponse)(nil),        // 8: payment.ProcessPaymentResponse
        (*ProcessRefundRequest)(nil),          // 9: payment.ProcessRefundRequest
        (*ProcessRefundResponse)(nil),         // 10: payment.ProcessRefundResponse
        (*AddPaymentMethodRequest)(nil),       // 11: payment.AddPaymentMethodRequest
        (*AddPaymentMethodResponse)(nil),      // 12: payment.AddPaymentMethodResponse
        (*GetPaymentRequest)(nil),             // 13: payment.GetPaymentRequest
        (*GetPaymentResponse)(nil),            // 14: payment.GetPaymentResponse
        (*GetUserPaymentMethodsRequest)(nil),  // 15: payment.GetUserPaymentMethodsRequest
        (*GetUserPaymentMethodsResponse)(nil), // 16: payment.GetUserPaymentMethodsResponse
        (*GetUserPaymentsRequest)(nil),        // 17: payment.GetUserPaymentsRequest
        (*GetUserPaymentsResponse)(nil),       // 18: payment.GetUserPaymentsResponse
        (*GetTripPaymentsRequest)(nil),        // 19: payment.GetTripPaymentsRequest
        (*GetTripPaymentsResponse)(nil),       // 20: payment.GetTripPaymentsResponse
        nil,                                   // 21: payment.Payment.FraudScoresEntry
        nil,                                   // 22: payment.Payment.MetadataEntry
        nil,                                   // 23: payment.PaymentMethodDetails.DetailsEntry
        nil,                                   // 24: payment.FraudDetectionResult.ScoresEntry
        nil,                                   // 25: payment.ProcessPaymentRequest.MetadataEntry
        nil,                                   // 26: payment.AddPaymentMethodRequest.DetailsEntry
        (*timestamppb.Timestamp)(nil),         // 27: google.protobuf.Timestamp
}
var file_shared_proto_payment_payment_proto_depIdxs = []int32{
        0,  // 0: payment.Payment.payment_method:type_name -&gt; payment.PaymentMethod
        1,  // 1: payment.Payment.status:type_name -&gt; payment.PaymentStatus
        2,  // 2: payment.Payment.transaction_type:type_name -&gt; payment.TransactionType
        3,  // 3: payment.Payment.fraud_risk:type_name -&gt; payment.FraudRiskLevel
        21, // 4: payment.Payment.fraud_scores:type_name -&gt; payment.Payment.FraudScoresEntry
        22, // 5: payment.Payment.metadata:type_name -&gt; payment.Payment.MetadataEntry
        27, // 6: payment.Payment.processed_at:type_name -&gt; google.protobuf.Timestamp
        27, // 7: payment.Payment.created_at:type_name -&gt; google.protobuf.Timestamp
        27, // 8: payment.Payment.updated_at:type_name -&gt; google.protobuf.Timestamp
        0,  // 9: payment.PaymentMethodDetails.type:type_name -&gt; payment.PaymentMethod
        27, // 10: payment.PaymentMethodDetails.expiry_date:type_name -&gt; google.protobuf.Timestamp
        23, // 11: payment.PaymentMethodDetails.details:type_name -&gt; payment.PaymentMethodDetails.DetailsEntry
        27, // 12: payment.PaymentMethodDetails.created_at:type_name -&gt; google.protobuf.Timestamp
        27, // 13: payment.PaymentMethodDetails.updated_at:type_name -&gt; google.protobuf.Timestamp
        3,  // 14: payment.FraudDetectionResult.risk_level:type_name -&gt; payment.FraudRiskLevel
        24, // 15: payment.FraudDetectionResult.scores:type_name -&gt; payment.FraudDetectionResult.ScoresEntry
        25, // 16: payment.ProcessPaymentRequest.metadata:type_name -&gt; payment.ProcessPaymentRequest.MetadataEntry
        4,  // 17: payment.ProcessPaymentResponse.payment:type_name -&gt; payment.Payment
        0,  // 18: payment.AddPaymentMethodRequest.type:type_name -&gt; payment.PaymentMethod
        26, // 19: payment.AddPaymentMethodRequest.details:type_name -&gt; payment.AddPaymentMethodRequest.DetailsEntry
        5,  // 20: payment.AddPaymentMethodResponse.payment_method:type_name -&gt; payment.PaymentMethodDetails
        4,  // 21: payment.GetPaymentResponse.payment:type_name -&gt; payment.Payment
        5,  // 22: payment.GetUserPaymentMethodsResponse.payment_methods:type_name -&gt; payment.PaymentMethodDetails
        4,  // 23: payment.GetUserPaymentsResponse.payments:type_name -&gt; payment.Payment
        4,  // 24: payment.GetTripPaymentsResponse.payments:type_name -&gt; payment.Payment
        7,  // 25: payment.PaymentService.ProcessPayment:input_type -&gt; payment.ProcessPaymentRequest
        9,  // 26: payment.PaymentService.ProcessRefund:input_type -&gt; payment.ProcessRefundRequest
        11, // 27: payment.PaymentService.AddPaymentMethod:input_type -&gt; payment.AddPaymentMethodRequest
        13, // 28: payment.PaymentService.GetPayment:input_type -&gt; payment.GetPaymentRequest
        15, // 29: payment.PaymentService.GetUserPaymentMethods:input_type -&gt; payment.GetUserPaymentMethodsRequest
        17, // 30: payment.PaymentService.GetUserPayments:input_type -&gt; payment.GetUserPaymentsRequest
        19, // 31: payment.PaymentService.GetTripPayments:input_type -&gt; payment.GetTripPaymentsRequest
        8,  // 32: payment.PaymentService.ProcessPayment:output_type -&gt; payment.ProcessPaymentResponse
        10, // 33: payment.PaymentService.ProcessRefund:output_type -&gt; payment.ProcessRefundResponse
        12, // 34: payment.PaymentService.AddPaymentMethod:output_type -&gt; payment.AddPaymentMethodResponse
        14, // 35: payment.PaymentService.GetPayment:output_type -&gt; payment.GetPaymentResponse
        16, // 36: payment.PaymentService.GetUserPaymentMethods:output_type -&gt; payment.GetUserPaymentMethodsResponse
        18, // 37: payment.PaymentService.GetUserPayments:output_type -&gt; payment.GetUserPaymentsResponse
        20, // 38: payment.PaymentService.GetTripPayments:output_type -&gt; payment.GetTripPaymentsResponse
        32, // [32:39] is the sub-list for method output_type
        25, // [25:32] is the sub-list for method input_type
        25, // [25:25] is the sub-list for extension type_name
        25, // [25:25] is the sub-list for extension extendee
        0,  // [0:25] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_shared_proto_payment_payment_proto_init() }</span>
func file_shared_proto_payment_payment_proto_init() <span class="cov0" title="0">{
        if File_shared_proto_payment_payment_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_payment_payment_proto_rawDesc), len(file_shared_proto_payment_payment_proto_rawDesc)),
                        NumEnums:      4,
                        NumMessages:   23,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_shared_proto_payment_payment_proto_goTypes,
                DependencyIndexes: file_shared_proto_payment_payment_proto_depIdxs,
                EnumInfos:         file_shared_proto_payment_payment_proto_enumTypes,
                MessageInfos:      file_shared_proto_payment_payment_proto_msgTypes,
        }.Build()
        File_shared_proto_payment_payment_proto = out.File
        file_shared_proto_payment_payment_proto_goTypes = nil
        file_shared_proto_payment_payment_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/payment/payment.proto

package payment

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        PaymentService_ProcessPayment_FullMethodName        = "/payment.PaymentService/ProcessPayment"
        PaymentService_ProcessRefund_FullMethodName         = "/payment.PaymentService/ProcessRefund"
        PaymentService_AddPaymentMethod_FullMethodName      = "/payment.PaymentService/AddPaymentMethod"
        PaymentService_GetPayment_FullMethodName            = "/payment.PaymentService/GetPayment"
        PaymentService_GetUserPaymentMethods_FullMethodName = "/payment.PaymentService/GetUserPaymentMethods"
        PaymentService_GetUserPayments_FullMethodName       = "/payment.PaymentService/GetUserPayments"
        PaymentService_GetTripPayments_FullMethodName       = "/payment.PaymentService/GetTripPayments"
)

// PaymentServiceClient is the client API for PaymentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PaymentService defines the gRPC service for payment processing
type PaymentServiceClient interface {
        ProcessPayment(ctx context.Context, in *ProcessPaymentRequest, opts ...grpc.CallOption) (*ProcessPaymentResponse, error)
        ProcessRefund(ctx context.Context, in *ProcessRefundRequest, opts ...grpc.CallOption) (*ProcessRefundResponse, error)
        AddPaymentMethod(ctx context.Context, in *AddPaymentMethodRequest, opts ...grpc.CallOption) (*AddPaymentMethodResponse, error)
        GetPayment(ctx context.Context, in *GetPaymentRequest, opts ...grpc.CallOption) (*GetPaymentResponse, error)
        GetUserPaymentMethods(ctx context.Context, in *GetUserPaymentMethodsRequest, opts ...grpc.CallOption) (*GetUserPaymentMethodsResponse, error)
        GetUserPayments(ctx context.Context, in *GetUserPaymentsRequest, opts ...grpc.CallOption) (*GetUserPaymentsResponse, error)
        GetTripPayments(ctx context.Context, in *GetTripPaymentsRequest, opts ...grpc.CallOption) (*GetTripPaymentsResponse, error)
}

type paymentServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewPaymentServiceClient(cc grpc.ClientConnInterface) PaymentServiceClient <span class="cov0" title="0">{
        return &amp;paymentServiceClient{cc}
}</span>

func (c *paymentServiceClient) ProcessPayment(ctx context.Context, in *ProcessPaymentRequest, opts ...grpc.CallOption) (*ProcessPaymentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ProcessPaymentResponse)
        err := c.cc.Invoke(ctx, PaymentService_ProcessPayment_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *paymentServiceClient) ProcessRefund(ctx context.Context, in *ProcessRefundRequest, opts ...grpc.CallOption) (*ProcessRefundResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ProcessRefundResponse)
        err := c.cc.Invoke(ctx, PaymentService_ProcessRefund_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *paymentServiceClient) AddPaymentMethod(ctx context.Context, in *AddPaymentMethodRequest, opts ...grpc.CallOption) (*AddPaymentMethodResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(AddPaymentMethodResponse)
        err := c.cc.Invoke(ctx, PaymentService_AddPaymentMethod_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *paymentServiceClient) GetPayment(ctx context.Context, in *GetPaymentRequest, opts ...grpc.CallOption) (*GetPaymentResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPaymentResponse)
        err := c.cc.Invoke(ctx, PaymentService_GetPayment_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *paymentServiceClient) GetUserPaymentMethods(ctx context.Context, in *GetUserPaymentMethodsRequest, opts ...grpc.CallOption) (*GetUserPaymentMethodsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserPaymentMethodsResponse)
        err := c.cc.Invoke(ctx, PaymentService_GetUserPaymentMethods_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *paymentServiceClient) GetUserPayments(ctx context.Context, in *GetUserPaymentsRequest, opts ...grpc.CallOption) (*GetUserPaymentsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserPaymentsResponse)
        err := c.cc.Invoke(ctx, PaymentService_GetUserPayments_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *paymentServiceClient) GetTripPayments(ctx context.Context, in *GetTripPaymentsRequest, opts ...grpc.CallOption) (*GetTripPaymentsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTripPaymentsResponse)
        err := c.cc.Invoke(ctx, PaymentService_GetTripPayments_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// PaymentServiceServer is the server API for PaymentService service.
// All implementations must embed UnimplementedPaymentServiceServer
// for forward compatibility.
//
// PaymentService defines the gRPC service for payment processing
type PaymentServiceServer interface {
        ProcessPayment(context.Context, *ProcessPaymentRequest) (*ProcessPaymentResponse, error)
        ProcessRefund(context.Context, *ProcessRefundRequest) (*ProcessRefundResponse, error)
        AddPaymentMethod(context.Context, *AddPaymentMethodRequest) (*AddPaymentMethodResponse, error)
        GetPayment(context.Context, *GetPaymentRequest) (*GetPaymentResponse, error)
        GetUserPaymentMethods(context.Context, *GetUserPaymentMethodsRequest) (*GetUserPaymentMethodsResponse, error)
        GetUserPayments(context.Context, *GetUserPaymentsRequest) (*GetUserPaymentsResponse, error)
        GetTripPayments(context.Context, *GetTripPaymentsRequest) (*GetTripPaymentsResponse, error)
        mustEmbedUnimplementedPaymentServiceServer()
}

// UnimplementedPaymentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPaymentServiceServer struct{}

func (UnimplementedPaymentServiceServer) ProcessPayment(context.Context, *ProcessPaymentRequest) (*ProcessPaymentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ProcessPayment not implemented")
}</span>
func (UnimplementedPaymentServiceServer) ProcessRefund(context.Context, *ProcessRefundRequest) (*ProcessRefundResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ProcessRefund not implemented")
}</span>
func (UnimplementedPaymentServiceServer) AddPaymentMethod(context.Context, *AddPaymentMethodRequest) (*AddPaymentMethodResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method AddPaymentMethod not implemented")
}</span>
func (UnimplementedPaymentServiceServer) GetPayment(context.Context, *GetPaymentRequest) (*GetPaymentResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPayment not implemented")
}</span>
func (UnimplementedPaymentServiceServer) GetUserPaymentMethods(context.Context, *GetUserPaymentMethodsRequest) (*GetUserPaymentMethodsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserPaymentMethods not implemented")
}</span>
func (UnimplementedPaymentServiceServer) GetUserPayments(context.Context, *GetUserPaymentsRequest) (*GetUserPaymentsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserPayments not implemented")
}</span>
func (UnimplementedPaymentServiceServer) GetTripPayments(context.Context, *GetTripPaymentsRequest) (*GetTripPaymentsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTripPayments not implemented")
}</span>
func (UnimplementedPaymentServiceServer) mustEmbedUnimplementedPaymentServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedPaymentServiceServer) testEmbeddedByValue()                        {<span class="cov0" title="0">}</span>

// UnsafePaymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServiceServer will
// result in compilation errors.
type UnsafePaymentServiceServer interface {
        mustEmbedUnimplementedPaymentServiceServer()
}

func RegisterPaymentServiceServer(s grpc.ServiceRegistrar, srv PaymentServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedPaymentServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;PaymentService_ServiceDesc, srv)</span>
}

func _PaymentService_ProcessPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ProcessPaymentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).ProcessPayment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_ProcessPayment_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).ProcessPayment(ctx, req.(*ProcessPaymentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PaymentService_ProcessRefund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ProcessRefundRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).ProcessRefund(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_ProcessRefund_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).ProcessRefund(ctx, req.(*ProcessRefundRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PaymentService_AddPaymentMethod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(AddPaymentMethodRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).AddPaymentMethod(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_AddPaymentMethod_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).AddPaymentMethod(ctx, req.(*AddPaymentMethodRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PaymentService_GetPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPaymentRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetPayment(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_GetPayment_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetPayment(ctx, req.(*GetPaymentRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PaymentService_GetUserPaymentMethods_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserPaymentMethodsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetUserPaymentMethods(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_GetUserPaymentMethods_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetUserPaymentMethods(ctx, req.(*GetUserPaymentMethodsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PaymentService_GetUserPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserPaymentsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetUserPayments(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_GetUserPayments_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetUserPayments(ctx, req.(*GetUserPaymentsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PaymentService_GetTripPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTripPaymentsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetTripPayments(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PaymentService_GetTripPayments_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PaymentServiceServer).GetTripPayments(ctx, req.(*GetTripPaymentsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// PaymentService_ServiceDesc is the grpc.ServiceDesc for PaymentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PaymentService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "payment.PaymentService",
        HandlerType: (*PaymentServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "ProcessPayment",
                        Handler:    _PaymentService_ProcessPayment_Handler,
                },
                {
                        MethodName: "ProcessRefund",
                        Handler:    _PaymentService_ProcessRefund_Handler,
                },
                {
                        MethodName: "AddPaymentMethod",
                        Handler:    _PaymentService_AddPaymentMethod_Handler,
                },
                {
                        MethodName: "GetPayment",
                        Handler:    _PaymentService_GetPayment_Handler,
                },
                {
                        MethodName: "GetUserPaymentMethods",
                        Handler:    _PaymentService_GetUserPaymentMethods_Handler,
                },
                {
                        MethodName: "GetUserPayments",
                        Handler:    _PaymentService_GetUserPayments_Handler,
                },
                {
                        MethodName: "GetTripPayments",
                        Handler:    _PaymentService_GetTripPayments_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "shared/proto/payment/payment.proto",
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v3.21.12
// source: shared/proto/pricing/pricing.proto

package pricing

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Location represents a geographical coordinate
type Location struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Latitude      float64                `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude     float64                `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
        Address       string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Location) Reset() <span class="cov0" title="0">{
        *x = Location{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Location) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Location) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Location) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Location) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Pricing estimate
type PriceEstimate struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        BaseFare        float64                `protobuf:"fixed64,2,opt,name=base_fare,json=baseFare,proto3" json:"base_fare,omitempty"`
        DistanceFare    float64                `protobuf:"fixed64,3,opt,name=distance_fare,json=distanceFare,proto3" json:"distance_fare,omitempty"`
        TimeFare        float64                `protobuf:"fixed64,4,opt,name=time_fare,json=timeFare,proto3" json:"time_fare,omitempty"`
        SurgeMultiplier float64                `protobuf:"fixed64,5,opt,name=surge_multiplier,json=surgeMultiplier,proto3" json:"surge_multiplier,omitempty"`
        SurgeAmount     float64                `protobuf:"fixed64,6,opt,name=surge_amount,json=surgeAmount,proto3" json:"surge_amount,omitempty"`
        DiscountAmount  float64                `protobuf:"fixed64,7,opt,name=discount_amount,json=discountAmount,proto3" json:"discount_amount,omitempty"`
        TotalAmount     float64                `protobuf:"fixed64,8,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
        Currency        string                 `protobuf:"bytes,9,opt,name=currency,proto3" json:"currency,omitempty"`
        Breakdown       *PricingBreakdown      `protobuf:"bytes,10,opt,name=breakdown,proto3" json:"breakdown,omitempty"`
        ValidUntil      *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *PriceEstimate) Reset() <span class="cov0" title="0">{
        *x = PriceEstimate{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PriceEstimate) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PriceEstimate) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PriceEstimate) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PriceEstimate.ProtoReflect.Descriptor instead.
func (*PriceEstimate) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PriceEstimate) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PriceEstimate) GetBaseFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BaseFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetDistanceFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetTimeFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimeFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetSurgeMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurgeMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetSurgeAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurgeAmount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetDiscountAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DiscountAmount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetTotalAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalAmount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PriceEstimate) GetCurrency() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Currency
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PriceEstimate) GetBreakdown() *PricingBreakdown <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Breakdown
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PriceEstimate) GetValidUntil() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ValidUntil
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Detailed pricing breakdown
type PricingBreakdown struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        BaseRate        float64                `protobuf:"fixed64,1,opt,name=base_rate,json=baseRate,proto3" json:"base_rate,omitempty"`
        PerKmRate       float64                `protobuf:"fixed64,2,opt,name=per_km_rate,json=perKmRate,proto3" json:"per_km_rate,omitempty"`
        PerMinuteRate   float64                `protobuf:"fixed64,3,opt,name=per_minute_rate,json=perMinuteRate,proto3" json:"per_minute_rate,omitempty"`
        DistanceKm      float64                `protobuf:"fixed64,4,opt,name=distance_km,json=distanceKm,proto3" json:"distance_km,omitempty"`
        DurationMinutes int32                  `protobuf:"varint,5,opt,name=duration_minutes,json=durationMinutes,proto3" json:"duration_minutes,omitempty"`
        BookingFee      float64                `protobuf:"fixed64,6,opt,name=booking_fee,json=bookingFee,proto3" json:"booking_fee,omitempty"`
        ServiceFee      float64                `protobuf:"fixed64,7,opt,name=service_fee,json=serviceFee,proto3" json:"service_fee,omitempty"`
        Taxes           float64                `protobuf:"fixed64,8,opt,name=taxes,proto3" json:"taxes,omitempty"`
        Tolls           float64                `protobuf:"fixed64,9,opt,name=tolls,proto3" json:"tolls,omitempty"`
        Discounts       []*AppliedDiscount     `protobuf:"bytes,10,rep,name=discounts,proto3" json:"discounts,omitempty"`
        SurgeInfo       *SurgeInfo             `protobuf:"bytes,11,opt,name=surge_info,json=surgeInfo,proto3" json:"surge_info,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *PricingBreakdown) Reset() <span class="cov0" title="0">{
        *x = PricingBreakdown{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PricingBreakdown) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PricingBreakdown) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PricingBreakdown) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PricingBreakdown.ProtoReflect.Descriptor instead.
func (*PricingBreakdown) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{2}
}</span>

func (x *PricingBreakdown) GetBaseRate() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BaseRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetPerKmRate() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PerKmRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetPerMinuteRate() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PerMinuteRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetDurationMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DurationMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetBookingFee() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BookingFee
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetServiceFee() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ServiceFee
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetTaxes() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Taxes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetTolls() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tolls
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingBreakdown) GetDiscounts() []*AppliedDiscount <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Discounts
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PricingBreakdown) GetSurgeInfo() *SurgeInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurgeInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Applied discount information
type AppliedDiscount struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Type          string                 `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"` // "percentage", "fixed_amount", "first_ride"
        Value         float64                `protobuf:"fixed64,4,opt,name=value,proto3" json:"value,omitempty"`
        AmountSaved   float64                `protobuf:"fixed64,5,opt,name=amount_saved,json=amountSaved,proto3" json:"amount_saved,omitempty"`
        Description   string                 `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *AppliedDiscount) Reset() <span class="cov0" title="0">{
        *x = AppliedDiscount{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AppliedDiscount) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AppliedDiscount) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AppliedDiscount) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AppliedDiscount.ProtoReflect.Descriptor instead.
func (*AppliedDiscount) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{3}
}</span>

func (x *AppliedDiscount) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AppliedDiscount) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AppliedDiscount) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *AppliedDiscount) GetValue() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AppliedDiscount) GetAmountSaved() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AmountSaved
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *AppliedDiscount) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Surge pricing information
type SurgeInfo struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        IsActive      bool                   `protobuf:"varint,1,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        Multiplier    float64                `protobuf:"fixed64,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
        Reason        string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
        StartedAt     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
        EndsAt        *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=ends_at,json=endsAt,proto3" json:"ends_at,omitempty"`
        ZoneId        string                 `protobuf:"bytes,6,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SurgeInfo) Reset() <span class="cov0" title="0">{
        *x = SurgeInfo{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SurgeInfo) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SurgeInfo) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SurgeInfo) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SurgeInfo.ProtoReflect.Descriptor instead.
func (*SurgeInfo) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{4}
}</span>

func (x *SurgeInfo) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *SurgeInfo) GetMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Multiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *SurgeInfo) GetReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SurgeInfo) GetStartedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SurgeInfo) GetEndsAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EndsAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SurgeInfo) GetZoneId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZoneId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Dynamic pricing factors
type PricingFactors struct {
        state               protoimpl.MessageState `protogen:"open.v1"`
        DemandMultiplier    float64                `protobuf:"fixed64,1,opt,name=demand_multiplier,json=demandMultiplier,proto3" json:"demand_multiplier,omitempty"`
        SupplyMultiplier    float64                `protobuf:"fixed64,2,opt,name=supply_multiplier,json=supplyMultiplier,proto3" json:"supply_multiplier,omitempty"`
        WeatherMultiplier   float64                `protobuf:"fixed64,3,opt,name=weather_multiplier,json=weatherMultiplier,proto3" json:"weather_multiplier,omitempty"`
        EventMultiplier     float64                `protobuf:"fixed64,4,opt,name=event_multiplier,json=eventMultiplier,proto3" json:"event_multiplier,omitempty"`
        TimeOfDayMultiplier float64                `protobuf:"fixed64,5,opt,name=time_of_day_multiplier,json=timeOfDayMultiplier,proto3" json:"time_of_day_multiplier,omitempty"`
        CustomFactors       map[string]float64     `protobuf:"bytes,6,rep,name=custom_factors,json=customFactors,proto3" json:"custom_factors,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
        unknownFields       protoimpl.UnknownFields
        sizeCache           protoimpl.SizeCache
}

func (x *PricingFactors) Reset() <span class="cov0" title="0">{
        *x = PricingFactors{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PricingFactors) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PricingFactors) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PricingFactors) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PricingFactors.ProtoReflect.Descriptor instead.
func (*PricingFactors) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{5}
}</span>

func (x *PricingFactors) GetDemandMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DemandMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingFactors) GetSupplyMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SupplyMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingFactors) GetWeatherMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WeatherMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingFactors) GetEventMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingFactors) GetTimeOfDayMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimeOfDayMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingFactors) GetCustomFactors() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CustomFactors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Vehicle type with pricing
type VehicleType struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Rates         *PricingRates          `protobuf:"bytes,4,opt,name=rates,proto3" json:"rates,omitempty"`
        Capacity      int32                  `protobuf:"varint,5,opt,name=capacity,proto3" json:"capacity,omitempty"`
        Available     bool                   `protobuf:"varint,6,opt,name=available,proto3" json:"available,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *VehicleType) Reset() <span class="cov0" title="0">{
        *x = VehicleType{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *VehicleType) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*VehicleType) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *VehicleType) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use VehicleType.ProtoReflect.Descriptor instead.
func (*VehicleType) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{6}
}</span>

func (x *VehicleType) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VehicleType) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VehicleType) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *VehicleType) GetRates() *PricingRates <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rates
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *VehicleType) GetCapacity() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Capacity
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *VehicleType) GetAvailable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Available
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Pricing rates for a vehicle type
type PricingRates struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        BaseFare        float64                `protobuf:"fixed64,1,opt,name=base_fare,json=baseFare,proto3" json:"base_fare,omitempty"`
        PerKmRate       float64                `protobuf:"fixed64,2,opt,name=per_km_rate,json=perKmRate,proto3" json:"per_km_rate,omitempty"`
        PerMinuteRate   float64                `protobuf:"fixed64,3,opt,name=per_minute_rate,json=perMinuteRate,proto3" json:"per_minute_rate,omitempty"`
        MinimumFare     float64                `protobuf:"fixed64,4,opt,name=minimum_fare,json=minimumFare,proto3" json:"minimum_fare,omitempty"`
        MaximumFare     float64                `protobuf:"fixed64,5,opt,name=maximum_fare,json=maximumFare,proto3" json:"maximum_fare,omitempty"`
        BookingFee      float64                `protobuf:"fixed64,6,opt,name=booking_fee,json=bookingFee,proto3" json:"booking_fee,omitempty"`
        CancellationFee float64                `protobuf:"fixed64,7,opt,name=cancellation_fee,json=cancellationFee,proto3" json:"cancellation_fee,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *PricingRates) Reset() <span class="cov0" title="0">{
        *x = PricingRates{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PricingRates) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PricingRates) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PricingRates) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PricingRates.ProtoReflect.Descriptor instead.
func (*PricingRates) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{7}
}</span>

func (x *PricingRates) GetBaseFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BaseFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingRates) GetPerKmRate() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PerKmRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingRates) GetPerMinuteRate() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PerMinuteRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingRates) GetMinimumFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinimumFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingRates) GetMaximumFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaximumFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingRates) GetBookingFee() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BookingFee
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingRates) GetCancellationFee() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CancellationFee
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Request/Response messages
type GetPriceEstimateRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        PickupLocation *Location              `protobuf:"bytes,1,opt,name=pickup_location,json=pickupLocation,proto3" json:"pickup_location,omitempty"`
        Destination    *Location              `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
        VehicleType    string                 `protobuf:"bytes,3,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        DepartureTime  *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=departure_time,json=departureTime,proto3" json:"departure_time,omitempty"`
        RiderId        string                 `protobuf:"bytes,5,opt,name=rider_id,json=riderId,proto3" json:"rider_id,omitempty"`
        Options        map[string]string      `protobuf:"bytes,6,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *GetPriceEstimateRequest) Reset() <span class="cov0" title="0">{
        *x = GetPriceEstimateRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPriceEstimateRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPriceEstimateRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPriceEstimateRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPriceEstimateRequest.ProtoReflect.Descriptor instead.
func (*GetPriceEstimateRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{8}
}</span>

func (x *GetPriceEstimateRequest) GetPickupLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PickupLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPriceEstimateRequest) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPriceEstimateRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetPriceEstimateRequest) GetDepartureTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DepartureTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPriceEstimateRequest) GetRiderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetPriceEstimateRequest) GetOptions() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Options
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPriceEstimateResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Estimate      *PriceEstimate         `protobuf:"bytes,1,opt,name=estimate,proto3" json:"estimate,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPriceEstimateResponse) Reset() <span class="cov0" title="0">{
        *x = GetPriceEstimateResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPriceEstimateResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPriceEstimateResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPriceEstimateResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPriceEstimateResponse.ProtoReflect.Descriptor instead.
func (*GetPriceEstimateResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetPriceEstimateResponse) GetEstimate() *PriceEstimate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Estimate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPriceEstimateResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetPriceEstimateResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetPriceEstimateResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetMultipleEstimatesRequest struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        PickupLocation *Location              `protobuf:"bytes,1,opt,name=pickup_location,json=pickupLocation,proto3" json:"pickup_location,omitempty"`
        Destination    *Location              `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
        VehicleTypes   []string               `protobuf:"bytes,3,rep,name=vehicle_types,json=vehicleTypes,proto3" json:"vehicle_types,omitempty"`
        DepartureTime  *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=departure_time,json=departureTime,proto3" json:"departure_time,omitempty"`
        RiderId        string                 `protobuf:"bytes,5,opt,name=rider_id,json=riderId,proto3" json:"rider_id,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *GetMultipleEstimatesRequest) Reset() <span class="cov0" title="0">{
        *x = GetMultipleEstimatesRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMultipleEstimatesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMultipleEstimatesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMultipleEstimatesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMultipleEstimatesRequest.ProtoReflect.Descriptor instead.
func (*GetMultipleEstimatesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetMultipleEstimatesRequest) GetPickupLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PickupLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMultipleEstimatesRequest) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMultipleEstimatesRequest) GetVehicleTypes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleTypes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMultipleEstimatesRequest) GetDepartureTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DepartureTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMultipleEstimatesRequest) GetRiderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetMultipleEstimatesResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Estimates     []*PriceEstimate       `protobuf:"bytes,1,rep,name=estimates,proto3" json:"estimates,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetMultipleEstimatesResponse) Reset() <span class="cov0" title="0">{
        *x = GetMultipleEstimatesResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetMultipleEstimatesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetMultipleEstimatesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetMultipleEstimatesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetMultipleEstimatesResponse.ProtoReflect.Descriptor instead.
func (*GetMultipleEstimatesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetMultipleEstimatesResponse) GetEstimates() []*PriceEstimate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Estimates
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetMultipleEstimatesResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetMultipleEstimatesResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CalculateFinalFareRequest struct {
        state                 protoimpl.MessageState `protogen:"open.v1"`
        TripId                string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        ActualPickup          *Location              `protobuf:"bytes,2,opt,name=actual_pickup,json=actualPickup,proto3" json:"actual_pickup,omitempty"`
        ActualDestination     *Location              `protobuf:"bytes,3,opt,name=actual_destination,json=actualDestination,proto3" json:"actual_destination,omitempty"`
        ActualDistanceKm      float64                `protobuf:"fixed64,4,opt,name=actual_distance_km,json=actualDistanceKm,proto3" json:"actual_distance_km,omitempty"`
        ActualDurationMinutes int32                  `protobuf:"varint,5,opt,name=actual_duration_minutes,json=actualDurationMinutes,proto3" json:"actual_duration_minutes,omitempty"`
        VehicleType           string                 `protobuf:"bytes,6,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        TripStartTime         *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=trip_start_time,json=tripStartTime,proto3" json:"trip_start_time,omitempty"`
        TripEndTime           *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=trip_end_time,json=tripEndTime,proto3" json:"trip_end_time,omitempty"`
        Adjustments           map[string]string      `protobuf:"bytes,9,rep,name=adjustments,proto3" json:"adjustments,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields         protoimpl.UnknownFields
        sizeCache             protoimpl.SizeCache
}

func (x *CalculateFinalFareRequest) Reset() <span class="cov0" title="0">{
        *x = CalculateFinalFareRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CalculateFinalFareRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CalculateFinalFareRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CalculateFinalFareRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CalculateFinalFareRequest.ProtoReflect.Descriptor instead.
func (*CalculateFinalFareRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{12}
}</span>

func (x *CalculateFinalFareRequest) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CalculateFinalFareRequest) GetActualPickup() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualPickup
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareRequest) GetActualDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareRequest) GetActualDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualDistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CalculateFinalFareRequest) GetActualDurationMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualDurationMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CalculateFinalFareRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CalculateFinalFareRequest) GetTripStartTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripStartTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareRequest) GetTripEndTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripEndTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareRequest) GetAdjustments() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Adjustments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CalculateFinalFareResponse struct {
        state            protoimpl.MessageState `protogen:"open.v1"`
        FinalFare        *PriceEstimate         `protobuf:"bytes,1,opt,name=final_fare,json=finalFare,proto3" json:"final_fare,omitempty"`
        OriginalEstimate *PriceEstimate         `protobuf:"bytes,2,opt,name=original_estimate,json=originalEstimate,proto3" json:"original_estimate,omitempty"`
        Adjustments      []*FareAdjustment      `protobuf:"bytes,3,rep,name=adjustments,proto3" json:"adjustments,omitempty"`
        Success          bool                   `protobuf:"varint,4,opt,name=success,proto3" json:"success,omitempty"`
        Message          string                 `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields    protoimpl.UnknownFields
        sizeCache        protoimpl.SizeCache
}

func (x *CalculateFinalFareResponse) Reset() <span class="cov0" title="0">{
        *x = CalculateFinalFareResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CalculateFinalFareResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CalculateFinalFareResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CalculateFinalFareResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CalculateFinalFareResponse.ProtoReflect.Descriptor instead.
func (*CalculateFinalFareResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{13}
}</span>

func (x *CalculateFinalFareResponse) GetFinalFare() *PriceEstimate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FinalFare
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareResponse) GetOriginalEstimate() *PriceEstimate <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalEstimate
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareResponse) GetAdjustments() []*FareAdjustment <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Adjustments
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CalculateFinalFareResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *CalculateFinalFareResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type FareAdjustment struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Type          string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"` // "route_change", "wait_time", "tolls", "cleanup_fee"
        Amount        float64                `protobuf:"fixed64,2,opt,name=amount,proto3" json:"amount,omitempty"`
        Description   string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Reason        string                 `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FareAdjustment) Reset() <span class="cov0" title="0">{
        *x = FareAdjustment{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FareAdjustment) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FareAdjustment) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FareAdjustment) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FareAdjustment.ProtoReflect.Descriptor instead.
func (*FareAdjustment) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{14}
}</span>

func (x *FareAdjustment) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FareAdjustment) GetAmount() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Amount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FareAdjustment) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FareAdjustment) GetReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetSurgePricingRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Location      *Location              `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
        VehicleType   string                 `protobuf:"bytes,2,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetSurgePricingRequest) Reset() <span class="cov0" title="0">{
        *x = GetSurgePricingRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurgePricingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurgePricingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurgePricingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurgePricingRequest.ProtoReflect.Descriptor instead.
func (*GetSurgePricingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{15}
}</span>

func (x *GetSurgePricingRequest) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetSurgePricingRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetSurgePricingResponse struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        SurgeInfo         *SurgeInfo             `protobuf:"bytes,1,opt,name=surge_info,json=surgeInfo,proto3" json:"surge_info,omitempty"`
        CurrentMultiplier float64                `protobuf:"fixed64,2,opt,name=current_multiplier,json=currentMultiplier,proto3" json:"current_multiplier,omitempty"`
        IsActive          bool                   `protobuf:"varint,3,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *GetSurgePricingResponse) Reset() <span class="cov0" title="0">{
        *x = GetSurgePricingResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetSurgePricingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetSurgePricingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetSurgePricingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetSurgePricingResponse.ProtoReflect.Descriptor instead.
func (*GetSurgePricingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetSurgePricingResponse) GetSurgeInfo() *SurgeInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurgeInfo
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetSurgePricingResponse) GetCurrentMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetSurgePricingResponse) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetVehicleTypesRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Location      *Location              `protobuf:"bytes,1,opt,name=location,proto3" json:"location,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVehicleTypesRequest) Reset() <span class="cov0" title="0">{
        *x = GetVehicleTypesRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[17]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVehicleTypesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVehicleTypesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVehicleTypesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[17]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVehicleTypesRequest.ProtoReflect.Descriptor instead.
func (*GetVehicleTypesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{17}
}</span>

func (x *GetVehicleTypesRequest) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetVehicleTypesResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        VehicleTypes  []*VehicleType         `protobuf:"bytes,1,rep,name=vehicle_types,json=vehicleTypes,proto3" json:"vehicle_types,omitempty"`
        Count         int32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetVehicleTypesResponse) Reset() <span class="cov0" title="0">{
        *x = GetVehicleTypesResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[18]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetVehicleTypesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetVehicleTypesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetVehicleTypesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[18]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetVehicleTypesResponse.ProtoReflect.Descriptor instead.
func (*GetVehicleTypesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{18}
}</span>

func (x *GetVehicleTypesResponse) GetVehicleTypes() []*VehicleType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleTypes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetVehicleTypesResponse) GetCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateSurgePricingRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        ZoneId          string                 `protobuf:"bytes,1,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
        Multiplier      float64                `protobuf:"fixed64,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
        Reason          string                 `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
        DurationMinutes int32                  `protobuf:"varint,4,opt,name=duration_minutes,json=durationMinutes,proto3" json:"duration_minutes,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *UpdateSurgePricingRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateSurgePricingRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[19]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateSurgePricingRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateSurgePricingRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateSurgePricingRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[19]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateSurgePricingRequest.ProtoReflect.Descriptor instead.
func (*UpdateSurgePricingRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{19}
}</span>

func (x *UpdateSurgePricingRequest) GetZoneId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZoneId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateSurgePricingRequest) GetMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Multiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UpdateSurgePricingRequest) GetReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateSurgePricingRequest) GetDurationMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DurationMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type UpdateSurgePricingResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        UpdatedSurge  *SurgeInfo             `protobuf:"bytes,3,opt,name=updated_surge,json=updatedSurge,proto3" json:"updated_surge,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateSurgePricingResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateSurgePricingResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[20]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateSurgePricingResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateSurgePricingResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateSurgePricingResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[20]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateSurgePricingResponse.ProtoReflect.Descriptor instead.
func (*UpdateSurgePricingResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{20}
}</span>

func (x *UpdateSurgePricingResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateSurgePricingResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateSurgePricingResponse) GetUpdatedSurge() *SurgeInfo <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedSurge
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPricingStatsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        FromTime      *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=from_time,json=fromTime,proto3" json:"from_time,omitempty"`
        ToTime        *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=to_time,json=toTime,proto3" json:"to_time,omitempty"`
        Region        string                 `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPricingStatsRequest) Reset() <span class="cov0" title="0">{
        *x = GetPricingStatsRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[21]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPricingStatsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPricingStatsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPricingStatsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[21]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPricingStatsRequest.ProtoReflect.Descriptor instead.
func (*GetPricingStatsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{21}
}</span>

func (x *GetPricingStatsRequest) GetFromTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FromTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPricingStatsRequest) GetToTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ToTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPricingStatsRequest) GetRegion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PricingStats struct {
        state                  protoimpl.MessageState `protogen:"open.v1"`
        AverageFare            float64                `protobuf:"fixed64,1,opt,name=average_fare,json=averageFare,proto3" json:"average_fare,omitempty"`
        TotalRevenue           float64                `protobuf:"fixed64,2,opt,name=total_revenue,json=totalRevenue,proto3" json:"total_revenue,omitempty"`
        TotalTrips             int32                  `protobuf:"varint,3,opt,name=total_trips,json=totalTrips,proto3" json:"total_trips,omitempty"`
        AverageSurgeMultiplier float64                `protobuf:"fixed64,4,opt,name=average_surge_multiplier,json=averageSurgeMultiplier,proto3" json:"average_surge_multiplier,omitempty"`
        SurgePeriods           int32                  `protobuf:"varint,5,opt,name=surge_periods,json=surgePeriods,proto3" json:"surge_periods,omitempty"`
        VehicleTypeAverages    map[string]float64     `protobuf:"bytes,6,rep,name=vehicle_type_averages,json=vehicleTypeAverages,proto3" json:"vehicle_type_averages,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"fixed64,2,opt,name=value"`
        DiscountUsage          map[string]int32       `protobuf:"bytes,7,rep,name=discount_usage,json=discountUsage,proto3" json:"discount_usage,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
        unknownFields          protoimpl.UnknownFields
        sizeCache              protoimpl.SizeCache
}

func (x *PricingStats) Reset() <span class="cov0" title="0">{
        *x = PricingStats{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[22]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PricingStats) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PricingStats) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PricingStats) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[22]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PricingStats.ProtoReflect.Descriptor instead.
func (*PricingStats) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{22}
}</span>

func (x *PricingStats) GetAverageFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AverageFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingStats) GetTotalRevenue() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalRevenue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingStats) GetTotalTrips() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalTrips
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingStats) GetAverageSurgeMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AverageSurgeMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingStats) GetSurgePeriods() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurgePeriods
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingStats) GetVehicleTypeAverages() map[string]float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleTypeAverages
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PricingStats) GetDiscountUsage() map[string]int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DiscountUsage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetPricingStatsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Stats         *PricingStats          `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetPricingStatsResponse) Reset() <span class="cov0" title="0">{
        *x = GetPricingStatsResponse{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[23]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetPricingStatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetPricingStatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetPricingStatsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[23]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetPricingStatsResponse.ProtoReflect.Descriptor instead.
func (*GetPricingStatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{23}
}</span>

func (x *GetPricingStatsResponse) GetStats() *PricingStats <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Stats
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetPricingStatsResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Real-time pricing updates
type PricingUpdateEvent struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ZoneId        string                 `protobuf:"bytes,1,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
        VehicleType   string                 `protobuf:"bytes,2,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        OldMultiplier float64                `protobuf:"fixed64,3,opt,name=old_multiplier,json=oldMultiplier,proto3" json:"old_multiplier,omitempty"`
        NewMultiplier float64                `protobuf:"fixed64,4,opt,name=new_multiplier,json=newMultiplier,proto3" json:"new_multiplier,omitempty"`
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Reason        string                 `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *PricingUpdateEvent) Reset() <span class="cov0" title="0">{
        *x = PricingUpdateEvent{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[24]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *PricingUpdateEvent) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PricingUpdateEvent) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PricingUpdateEvent) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[24]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PricingUpdateEvent.ProtoReflect.Descriptor instead.
func (*PricingUpdateEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{24}
}</span>

func (x *PricingUpdateEvent) GetZoneId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZoneId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PricingUpdateEvent) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PricingUpdateEvent) GetOldMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OldMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingUpdateEvent) GetNewMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *PricingUpdateEvent) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PricingUpdateEvent) GetReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type SubscribeToPricingUpdatesRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ZoneIds       []string               `protobuf:"bytes,1,rep,name=zone_ids,json=zoneIds,proto3" json:"zone_ids,omitempty"`
        VehicleTypes  []string               `protobuf:"bytes,2,rep,name=vehicle_types,json=vehicleTypes,proto3" json:"vehicle_types,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToPricingUpdatesRequest) Reset() <span class="cov0" title="0">{
        *x = SubscribeToPricingUpdatesRequest{}
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[25]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SubscribeToPricingUpdatesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubscribeToPricingUpdatesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubscribeToPricingUpdatesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_pricing_pricing_proto_msgTypes[25]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubscribeToPricingUpdatesRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToPricingUpdatesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_pricing_pricing_proto_rawDescGZIP(), []int{25}
}</span>

func (x *SubscribeToPricingUpdatesRequest) GetZoneIds() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ZoneIds
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SubscribeToPricingUpdatesRequest) GetVehicleTypes() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleTypes
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_shared_proto_pricing_pricing_proto protoreflect.FileDescriptor

const file_shared_proto_pricing_pricing_proto_rawDesc = "" +
        "\n" +
        "\"shared/proto/pricing/pricing.proto\x12\apricing\x1a\x1fgoogle/protobuf/timestamp.proto\"^\n" +
        "\bLocation\x12\x1a\n" +
        "\blatitude\x18\x01 \x01(\x01R\blatitude\x12\x1c\n" +
        "\tlongitude\x18\x02 \x01(\x01R\tlongitude\x12\x18\n" +
        "\aaddress\x18\x03 \x01(\tR\aaddress\"\xaa\x03\n" +
        "\rPriceEstimate\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
        "\tbase_fare\x18\x02 \x01(\x01R\bbaseFare\x12#\n" +
        "\rdistance_fare\x18\x03 \x01(\x01R\fdistanceFare\x12\x1b\n" +
        "\ttime_fare\x18\x04 \x01(\x01R\btimeFare\x12)\n" +
        "\x10surge_multiplier\x18\x05 \x01(\x01R\x0fsurgeMultiplier\x12!\n" +
        "\fsurge_amount\x18\x06 \x01(\x01R\vsurgeAmount\x12'\n" +
        "\x0fdiscount_amount\x18\a \x01(\x01R\x0ediscountAmount\x12!\n" +
        "\ftotal_amount\x18\b \x01(\x01R\vtotalAmount\x12\x1a\n" +
        "\bcurrency\x18\t \x01(\tR\bcurrency\x127\n" +
        "\tbreakdown\x18\n" +
        " \x01(\v2\x19.pricing.PricingBreakdownR\tbreakdown\x12;\n" +
        "\vvalid_until\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "validUntil\"\x9c\x03\n" +
        "\x10PricingBreakdown\x12\x1b\n" +
        "\tbase_rate\x18\x01 \x01(\x01R\bbaseRate\x12\x1e\n" +
        "\vper_km_rate\x18\x02 \x01(\x01R\tperKmRate\x12&amp;\n" +
        "\x0fper_minute_rate\x18\x03 \x01(\x01R\rperMinuteRate\x12\x1f\n" +
        "\vdistance_km\x18\x04 \x01(\x01R\n" +
        "distanceKm\x12)\n" +
        "\x10duration_minutes\x18\x05 \x01(\x05R\x0fdurationMinutes\x12\x1f\n" +
        "\vbooking_fee\x18\x06 \x01(\x01R\n" +
        "bookingFee\x12\x1f\n" +
        "\vservice_fee\x18\a \x01(\x01R\n" +
        "serviceFee\x12\x14\n" +
        "\x05taxes\x18\b \x01(\x01R\x05taxes\x12\x14\n" +
        "\x05tolls\x18\t \x01(\x01R\x05tolls\x126\n" +
        "\tdiscounts\x18\n" +
        " \x03(\v2\x18.pricing.AppliedDiscountR\tdiscounts\x121\n" +
        "\n" +
        "surge_info\x18\v \x01(\v2\x12.pricing.SurgeInfoR\tsurgeInfo\"\xa4\x01\n" +
        "\x0fAppliedDiscount\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
        "\x04type\x18\x03 \x01(\tR\x04type\x12\x14\n" +
        "\x05value\x18\x04 \x01(\x01R\x05value\x12!\n" +
        "\famount_saved\x18\x05 \x01(\x01R\vamountSaved\x12 \n" +
        "\vdescription\x18\x06 \x01(\tR\vdescription\"\xe9\x01\n" +
        "\tSurgeInfo\x12\x1b\n" +
        "\tis_active\x18\x01 \x01(\bR\bisActive\x12\x1e\n" +
        "\n" +
        "multiplier\x18\x02 \x01(\x01R\n" +
        "multiplier\x12\x16\n" +
        "\x06reason\x18\x03 \x01(\tR\x06reason\x129\n" +
        "\n" +
        "started_at\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\tstartedAt\x123\n" +
        "\aends_at\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x06endsAt\x12\x17\n" +
        "\azone_id\x18\x06 \x01(\tR\x06zoneId\"\x8e\x03\n" +
        "\x0ePricingFactors\x12+\n" +
        "\x11demand_multiplier\x18\x01 \x01(\x01R\x10demandMultiplier\x12+\n" +
        "\x11supply_multiplier\x18\x02 \x01(\x01R\x10supplyMultiplier\x12-\n" +
        "\x12weather_multiplier\x18\x03 \x01(\x01R\x11weatherMultiplier\x12)\n" +
        "\x10event_multiplier\x18\x04 \x01(\x01R\x0feventMultiplier\x123\n" +
        "\x16time_of_day_multiplier\x18\x05 \x01(\x01R\x13timeOfDayMultiplier\x12Q\n" +
        "\x0ecustom_factors\x18\x06 \x03(\v2*.pricing.PricingFactors.CustomFactorsEntryR\rcustomFactors\x1a@\n" +
        "\x12CustomFactorsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\"\xba\x01\n" +
        "\vVehicleType\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
        "\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
        "\vdescription\x18\x03 \x01(\tR\vdescription\x12+\n" +
        "\x05rates\x18\x04 \x01(\v2\x15.pricing.PricingRatesR\x05rates\x12\x1a\n" +
        "\bcapacity\x18\x05 \x01(\x05R\bcapacity\x12\x1c\n" +
        "\tavailable\x18\x06 \x01(\bR\tavailable\"\x85\x02\n" +
        "\fPricingRates\x12\x1b\n" +
        "\tbase_fare\x18\x01 \x01(\x01R\bbaseFare\x12\x1e\n" +
        "\vper_km_rate\x18\x02 \x01(\x01R\tperKmRate\x12&amp;\n" +
        "\x0fper_minute_rate\x18\x03 \x01(\x01R\rperMinuteRate\x12!\n" +
        "\fminimum_fare\x18\x04 \x01(\x01R\vminimumFare\x12!\n" +
        "\fmaximum_fare\x18\x05 \x01(\x01R\vmaximumFare\x12\x1f\n" +
        "\vbooking_fee\x18\x06 \x01(\x01R\n" +
        "bookingFee\x12)\n" +
        "\x10cancellation_fee\x18\a \x01(\x01R\x0fcancellationFee\"\x90\x03\n" +
        "\x17GetPriceEstimateRequest\x12:\n" +
        "\x0fpickup_location\x18\x01 \x01(\v2\x11.pricing.LocationR\x0epickupLocation\x123\n" +
        "\vdestination\x18\x02 \x01(\v2\x11.pricing.LocationR\vdestination\x12!\n" +
        "\fvehicle_type\x18\x03 \x01(\tR\vvehicleType\x12A\n" +
        "\x0edeparture_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\rdepartureTime\x12\x19\n" +
        "\brider_id\x18\x05 \x01(\tR\ariderId\x12G\n" +
        "\aoptions\x18\x06 \x03(\v2-.pricing.GetPriceEstimateRequest.OptionsEntryR\aoptions\x1a:\n" +
        "\fOptionsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9a\x01\n" +
        "\x18GetPriceEstimateResponse\x122\n" +
        "\bestimate\x18\x01 \x01(\v2\x16.pricing.PriceEstimateR\bestimate\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\"\x91\x02\n" +
        "\x1bGetMultipleEstimatesRequest\x12:\n" +
        "\x0fpickup_location\x18\x01 \x01(\v2\x11.pricing.LocationR\x0epickupLocation\x123\n" +
        "\vdestination\x18\x02 \x01(\v2\x11.pricing.LocationR\vdestination\x12#\n" +
        "\rvehicle_types\x18\x03 \x03(\tR\fvehicleTypes\x12A\n" +
        "\x0edeparture_time\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\rdepartureTime\x12\x19\n" +
        "\brider_id\x18\x05 \x01(\tR\ariderId\"\x88\x01\n" +
        "\x1cGetMultipleEstimatesResponse\x124\n" +
        "\testimates\x18\x01 \x03(\v2\x16.pricing.PriceEstimateR\testimates\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\"\xd2\x04\n" +
        "\x19CalculateFinalFareRequest\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\x126\n" +
        "\ractual_pickup\x18\x02 \x01(\v2\x11.pricing.LocationR\factualPickup\x12@\n" +
        "\x12actual_destination\x18\x03 \x01(\v2\x11.pricing.LocationR\x11actualDestination\x12,\n" +
        "\x12actual_distance_km\x18\x04 \x01(\x01R\x10actualDistanceKm\x126\n" +
        "\x17actual_duration_minutes\x18\x05 \x01(\x05R\x15actualDurationMinutes\x12!\n" +
        "\fvehicle_type\x18\x06 \x01(\tR\vvehicleType\x12B\n" +
        "\x0ftrip_start_time\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\rtripStartTime\x12&gt;\n" +
        "\rtrip_end_time\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\vtripEndTime\x12U\n" +
        "\vadjustments\x18\t \x03(\v23.pricing.CalculateFinalFareRequest.AdjustmentsEntryR\vadjustments\x1a&gt;\n" +
        "\x10AdjustmentsEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x87\x02\n" +
        "\x1aCalculateFinalFareResponse\x125\n" +
        "\n" +
        "final_fare\x18\x01 \x01(\v2\x16.pricing.PriceEstimateR\tfinalFare\x12C\n" +
        "\x11original_estimate\x18\x02 \x01(\v2\x16.pricing.PriceEstimateR\x10originalEstimate\x129\n" +
        "\vadjustments\x18\x03 \x03(\v2\x17.pricing.FareAdjustmentR\vadjustments\x12\x18\n" +
        "\asuccess\x18\x04 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x05 \x01(\tR\amessage\"v\n" +
        "\x0eFareAdjustment\x12\x12\n" +
        "\x04type\x18\x01 \x01(\tR\x04type\x12\x16\n" +
        "\x06amount\x18\x02 \x01(\x01R\x06amount\x12 \n" +
        "\vdescription\x18\x03 \x01(\tR\vdescription\x12\x16\n" +
        "\x06reason\x18\x04 \x01(\tR\x06reason\"j\n" +
        "\x16GetSurgePricingRequest\x12-\n" +
        "\blocation\x18\x01 \x01(\v2\x11.pricing.LocationR\blocation\x12!\n" +
        "\fvehicle_type\x18\x02 \x01(\tR\vvehicleType\"\x98\x01\n" +
        "\x17GetSurgePricingResponse\x121\n" +
        "\n" +
        "surge_info\x18\x01 \x01(\v2\x12.pricing.SurgeInfoR\tsurgeInfo\x12-\n" +
        "\x12current_multiplier\x18\x02 \x01(\x01R\x11currentMultiplier\x12\x1b\n" +
        "\tis_active\x18\x03 \x01(\bR\bisActive\"G\n" +
        "\x16GetVehicleTypesRequest\x12-\n" +
        "\blocation\x18\x01 \x01(\v2\x11.pricing.LocationR\blocation\"j\n" +
        "\x17GetVehicleTypesResponse\x129\n" +
        "\rvehicle_types\x18\x01 \x03(\v2\x14.pricing.VehicleTypeR\fvehicleTypes\x12\x14\n" +
        "\x05count\x18\x02 \x01(\x05R\x05count\"\x97\x01\n" +
        "\x19UpdateSurgePricingRequest\x12\x17\n" +
        "\azone_id\x18\x01 \x01(\tR\x06zoneId\x12\x1e\n" +
        "\n" +
        "multiplier\x18\x02 \x01(\x01R\n" +
        "multiplier\x12\x16\n" +
        "\x06reason\x18\x03 \x01(\tR\x06reason\x12)\n" +
        "\x10duration_minutes\x18\x04 \x01(\x05R\x0fdurationMinutes\"\x89\x01\n" +
        "\x1aUpdateSurgePricingResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\x127\n" +
        "\rupdated_surge\x18\x03 \x01(\v2\x12.pricing.SurgeInfoR\fupdatedSurge\"\x9e\x01\n" +
        "\x16GetPricingStatsRequest\x127\n" +
        "\tfrom_time\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampR\bfromTime\x123\n" +
        "\ato_time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x06toTime\x12\x16\n" +
        "\x06region\x18\x03 \x01(\tR\x06region\"\x95\x04\n" +
        "\fPricingStats\x12!\n" +
        "\faverage_fare\x18\x01 \x01(\x01R\vaverageFare\x12#\n" +
        "\rtotal_revenue\x18\x02 \x01(\x01R\ftotalRevenue\x12\x1f\n" +
        "\vtotal_trips\x18\x03 \x01(\x05R\n" +
        "totalTrips\x128\n" +
        "\x18average_surge_multiplier\x18\x04 \x01(\x01R\x16averageSurgeMultiplier\x12#\n" +
        "\rsurge_periods\x18\x05 \x01(\x05R\fsurgePeriods\x12b\n" +
        "\x15vehicle_type_averages\x18\x06 \x03(\v2..pricing.PricingStats.VehicleTypeAveragesEntryR\x13vehicleTypeAverages\x12O\n" +
        "\x0ediscount_usage\x18\a \x03(\v2(.pricing.PricingStats.DiscountUsageEntryR\rdiscountUsage\x1aF\n" +
        "\x18VehicleTypeAveragesEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x01R\x05value:\x028\x01\x1a@\n" +
        "\x12DiscountUsageEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"`\n" +
        "\x17GetPricingStatsResponse\x12+\n" +
        "\x05stats\x18\x01 \x01(\v2\x15.pricing.PricingStatsR\x05stats\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\"\xf0\x01\n" +
        "\x12PricingUpdateEvent\x12\x17\n" +
        "\azone_id\x18\x01 \x01(\tR\x06zoneId\x12!\n" +
        "\fvehicle_type\x18\x02 \x01(\tR\vvehicleType\x12%\n" +
        "\x0eold_multiplier\x18\x03 \x01(\x01R\roldMultiplier\x12%\n" +
        "\x0enew_multiplier\x18\x04 \x01(\x01R\rnewMultiplier\x128\n" +
        "\ttimestamp\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x16\n" +
        "\x06reason\x18\x06 \x01(\tR\x06reason\"b\n" +
        " SubscribeToPricingUpdatesRequest\x12\x19\n" +
        "\bzone_ids\x18\x01 \x03(\tR\azoneIds\x12#\n" +
        "\rvehicle_types\x18\x02 \x03(\tR\fvehicleTypes2\xf5\x05\n" +
        "\x0ePricingService\x12W\n" +
        "\x10GetPriceEstimate\x12 .pricing.GetPriceEstimateRequest\x1a!.pricing.GetPriceEstimateResponse\x12c\n" +
        "\x14GetMultipleEstimates\x12$.pricing.GetMultipleEstimatesRequest\x1a%.pricing.GetMultipleEstimatesResponse\x12]\n" +
        "\x12CalculateFinalFare\x12\".pricing.CalculateFinalFareRequest\x1a#.pricing.CalculateFinalFareResponse\x12T\n" +
        "\x0fGetSurgePricing\x12\x1f.pricing.GetSurgePricingRequest\x1a .pricing.GetSurgePricingResponse\x12T\n" +
        "\x0fGetVehicleTypes\x12\x1f.pricing.GetVehicleTypesRequest\x1a .pricing.GetVehicleTypesResponse\x12]\n" +
        "\x12UpdateSurgePricing\x12\".pricing.UpdateSurgePricingRequest\x1a#.pricing.UpdateSurgePricingResponse\x12T\n" +
        "\x0fGetPricingStats\x12\x1f.pricing.GetPricingStatsRequest\x1a .pricing.GetPricingStatsResponse\x12e\n" +
        "\x19SubscribeToPricingUpdates\x12).pricing.SubscribeToPricingUpdatesRequest\x1a\x1b.pricing.PricingUpdateEvent0\x01B4Z2github.com/rideshare-platform/shared/proto/pricingb\x06proto3"

var (
        file_shared_proto_pricing_pricing_proto_rawDescOnce sync.Once
        file_shared_proto_pricing_pricing_proto_rawDescData []byte
)

func file_shared_proto_pricing_pricing_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_shared_proto_pricing_pricing_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_shared_proto_pricing_pricing_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_pricing_pricing_proto_rawDesc), len(file_shared_proto_pricing_pricing_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_shared_proto_pricing_pricing_proto_rawDescData</span>
}

var file_shared_proto_pricing_pricing_proto_msgTypes = make([]protoimpl.MessageInfo, 31)
var file_shared_proto_pricing_pricing_proto_goTypes = []any{
        (*Location)(nil),                         // 0: pricing.Location
        (*PriceEstimate)(nil),                    // 1: pricing.PriceEstimate
        (*PricingBreakdown)(nil),                 // 2: pricing.PricingBreakdown
        (*AppliedDiscount)(nil),                  // 3: pricing.AppliedDiscount
        (*SurgeInfo)(nil),                        // 4: pricing.SurgeInfo
        (*PricingFactors)(nil),                   // 5: pricing.PricingFactors
        (*VehicleType)(nil),                      // 6: pricing.VehicleType
        (*PricingRates)(nil),                     // 7: pricing.PricingRates
        (*GetPriceEstimateRequest)(nil),          // 8: pricing.GetPriceEstimateRequest
        (*GetPriceEstimateResponse)(nil),         // 9: pricing.GetPriceEstimateResponse
        (*GetMultipleEstimatesRequest)(nil),      // 10: pricing.GetMultipleEstimatesRequest
        (*GetMultipleEstimatesResponse)(nil),     // 11: pricing.GetMultipleEstimatesResponse
        (*CalculateFinalFareRequest)(nil),        // 12: pricing.CalculateFinalFareRequest
        (*CalculateFinalFareResponse)(nil),       // 13: pricing.CalculateFinalFareResponse
        (*FareAdjustment)(nil),                   // 14: pricing.FareAdjustment
        (*GetSurgePricingRequest)(nil),           // 15: pricing.GetSurgePricingRequest
        (*GetSurgePricingResponse)(nil),          // 16: pricing.GetSurgePricingResponse
        (*GetVehicleTypesRequest)(nil),           // 17: pricing.GetVehicleTypesRequest
        (*GetVehicleTypesResponse)(nil),          // 18: pricing.GetVehicleTypesResponse
        (*UpdateSurgePricingRequest)(nil),        // 19: pricing.UpdateSurgePricingRequest
        (*UpdateSurgePricingResponse)(nil),       // 20: pricing.UpdateSurgePricingResponse
        (*GetPricingStatsRequest)(nil),           // 21: pricing.GetPricingStatsRequest
        (*PricingStats)(nil),                     // 22: pricing.PricingStats
        (*GetPricingStatsResponse)(nil),          // 23: pricing.GetPricingStatsResponse
        (*PricingUpdateEvent)(nil),               // 24: pricing.PricingUpdateEvent
        (*SubscribeToPricingUpdatesRequest)(nil), // 25: pricing.SubscribeToPricingUpdatesRequest
        nil,                                      // 26: pricing.PricingFactors.CustomFactorsEntry
        nil,                                      // 27: pricing.GetPriceEstimateRequest.OptionsEntry
        nil,                                      // 28: pricing.CalculateFinalFareRequest.AdjustmentsEntry
        nil,                                      // 29: pricing.PricingStats.VehicleTypeAveragesEntry
        nil,                                      // 30: pricing.PricingStats.DiscountUsageEntry
        (*timestamppb.Timestamp)(nil),            // 31: google.protobuf.Timestamp
}
var file_shared_proto_pricing_pricing_proto_depIdxs = []int32{
        2,  // 0: pricing.PriceEstimate.breakdown:type_name -&gt; pricing.PricingBreakdown
        31, // 1: pricing.PriceEstimate.valid_until:type_name -&gt; google.protobuf.Timestamp
        3,  // 2: pricing.PricingBreakdown.discounts:type_name -&gt; pricing.AppliedDiscount
        4,  // 3: pricing.PricingBreakdown.surge_info:type_name -&gt; pricing.SurgeInfo
        31, // 4: pricing.SurgeInfo.started_at:type_name -&gt; google.protobuf.Timestamp
        31, // 5: pricing.SurgeInfo.ends_at:type_name -&gt; google.protobuf.Timestamp
        26, // 6: pricing.PricingFactors.custom_factors:type_name -&gt; pricing.PricingFactors.CustomFactorsEntry
        7,  // 7: pricing.VehicleType.rates:type_name -&gt; pricing.PricingRates
        0,  // 8: pricing.GetPriceEstimateRequest.pickup_location:type_name -&gt; pricing.Location
        0,  // 9: pricing.GetPriceEstimateRequest.destination:type_name -&gt; pricing.Location
        31, // 10: pricing.GetPriceEstimateRequest.departure_time:type_name -&gt; google.protobuf.Timestamp
        27, // 11: pricing.GetPriceEstimateRequest.options:type_name -&gt; pricing.GetPriceEstimateRequest.OptionsEntry
        1,  // 12: pricing.GetPriceEstimateResponse.estimate:type_name -&gt; pricing.PriceEstimate
        0,  // 13: pricing.GetMultipleEstimatesRequest.pickup_location:type_name -&gt; pricing.Location
        0,  // 14: pricing.GetMultipleEstimatesRequest.destination:type_name -&gt; pricing.Location
        31, // 15: pricing.GetMultipleEstimatesRequest.departure_time:type_name -&gt; google.protobuf.Timestamp
        1,  // 16: pricing.GetMultipleEstimatesResponse.estimates:type_name -&gt; pricing.PriceEstimate
        0,  // 17: pricing.CalculateFinalFareRequest.actual_pickup:type_name -&gt; pricing.Location
        0,  // 18: pricing.CalculateFinalFareRequest.actual_destination:type_name -&gt; pricing.Location
        31, // 19: pricing.CalculateFinalFareRequest.trip_start_time:type_name -&gt; google.protobuf.Timestamp
        31, // 20: pricing.CalculateFinalFareRequest.trip_end_time:type_name -&gt; google.protobuf.Timestamp
        28, // 21: pricing.CalculateFinalFareRequest.adjustments:type_name -&gt; pricing.CalculateFinalFareRequest.AdjustmentsEntry
        1,  // 22: pricing.CalculateFinalFareResponse.final_fare:type_name -&gt; pricing.PriceEstimate
        1,  // 23: pricing.CalculateFinalFareResponse.original_estimate:type_name -&gt; pricing.PriceEstimate
        14, // 24: pricing.CalculateFinalFareResponse.adjustments:type_name -&gt; pricing.FareAdjustment
        0,  // 25: pricing.GetSurgePricingRequest.location:type_name -&gt; pricing.Location
        4,  // 26: pricing.GetSurgePricingResponse.surge_info:type_name -&gt; pricing.SurgeInfo
        0,  // 27: pricing.GetVehicleTypesRequest.location:type_name -&gt; pricing.Location
        6,  // 28: pricing.GetVehicleTypesResponse.vehicle_types:type_name -&gt; pricing.VehicleType
        4,  // 29: pricing.UpdateSurgePricingResponse.updated_surge:type_name -&gt; pricing.SurgeInfo
        31, // 30: pricing.GetPricingStatsRequest.from_time:type_name -&gt; google.protobuf.Timestamp
        31, // 31: pricing.GetPricingStatsRequest.to_time:type_name -&gt; google.protobuf.Timestamp
        29, // 32: pricing.PricingStats.vehicle_type_averages:type_name -&gt; pricing.PricingStats.VehicleTypeAveragesEntry
        30, // 33: pricing.PricingStats.discount_usage:type_name -&gt; pricing.PricingStats.DiscountUsageEntry
        22, // 34: pricing.GetPricingStatsResponse.stats:type_name -&gt; pricing.PricingStats
        31, // 35: pricing.PricingUpdateEvent.timestamp:type_name -&gt; google.protobuf.Timestamp
        8,  // 36: pricing.PricingService.GetPriceEstimate:input_type -&gt; pricing.GetPriceEstimateRequest
        10, // 37: pricing.PricingService.GetMultipleEstimates:input_type -&gt; pricing.GetMultipleEstimatesRequest
        12, // 38: pricing.PricingService.CalculateFinalFare:input_type -&gt; pricing.CalculateFinalFareRequest
        15, // 39: pricing.PricingService.GetSurgePricing:input_type -&gt; pricing.GetSurgePricingRequest
        17, // 40: pricing.PricingService.GetVehicleTypes:input_type -&gt; pricing.GetVehicleTypesRequest
        19, // 41: pricing.PricingService.UpdateSurgePricing:input_type -&gt; pricing.UpdateSurgePricingRequest
        21, // 42: pricing.PricingService.GetPricingStats:input_type -&gt; pricing.GetPricingStatsRequest
        25, // 43: pricing.PricingService.SubscribeToPricingUpdates:input_type -&gt; pricing.SubscribeToPricingUpdatesRequest
        9,  // 44: pricing.PricingService.GetPriceEstimate:output_type -&gt; pricing.GetPriceEstimateResponse
        11, // 45: pricing.PricingService.GetMultipleEstimates:output_type -&gt; pricing.GetMultipleEstimatesResponse
        13, // 46: pricing.PricingService.CalculateFinalFare:output_type -&gt; pricing.CalculateFinalFareResponse
        16, // 47: pricing.PricingService.GetSurgePricing:output_type -&gt; pricing.GetSurgePricingResponse
        18, // 48: pricing.PricingService.GetVehicleTypes:output_type -&gt; pricing.GetVehicleTypesResponse
        20, // 49: pricing.PricingService.UpdateSurgePricing:output_type -&gt; pricing.UpdateSurgePricingResponse
        23, // 50: pricing.PricingService.GetPricingStats:output_type -&gt; pricing.GetPricingStatsResponse
        24, // 51: pricing.PricingService.SubscribeToPricingUpdates:output_type -&gt; pricing.PricingUpdateEvent
        44, // [44:52] is the sub-list for method output_type
        36, // [36:44] is the sub-list for method input_type
        36, // [36:36] is the sub-list for extension type_name
        36, // [36:36] is the sub-list for extension extendee
        0,  // [0:36] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_shared_proto_pricing_pricing_proto_init() }</span>
func file_shared_proto_pricing_pricing_proto_init() <span class="cov0" title="0">{
        if File_shared_proto_pricing_pricing_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_pricing_pricing_proto_rawDesc), len(file_shared_proto_pricing_pricing_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   31,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_shared_proto_pricing_pricing_proto_goTypes,
                DependencyIndexes: file_shared_proto_pricing_pricing_proto_depIdxs,
                MessageInfos:      file_shared_proto_pricing_pricing_proto_msgTypes,
        }.Build()
        File_shared_proto_pricing_pricing_proto = out.File
        file_shared_proto_pricing_pricing_proto_goTypes = nil
        file_shared_proto_pricing_pricing_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/pricing/pricing.proto

package pricing

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        PricingService_GetPriceEstimate_FullMethodName          = "/pricing.PricingService/GetPriceEstimate"
        PricingService_GetMultipleEstimates_FullMethodName      = "/pricing.PricingService/GetMultipleEstimates"
        PricingService_CalculateFinalFare_FullMethodName        = "/pricing.PricingService/CalculateFinalFare"
        PricingService_GetSurgePricing_FullMethodName           = "/pricing.PricingService/GetSurgePricing"
        PricingService_GetVehicleTypes_FullMethodName           = "/pricing.PricingService/GetVehicleTypes"
        PricingService_UpdateSurgePricing_FullMethodName        = "/pricing.PricingService/UpdateSurgePricing"
        PricingService_GetPricingStats_FullMethodName           = "/pricing.PricingService/GetPricingStats"
        PricingService_SubscribeToPricingUpdates_FullMethodName = "/pricing.PricingService/SubscribeToPricingUpdates"
)

// PricingServiceClient is the client API for PricingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PricingService defines the gRPC service for fare calculation
type PricingServiceClient interface {
        GetPriceEstimate(ctx context.Context, in *GetPriceEstimateRequest, opts ...grpc.CallOption) (*GetPriceEstimateResponse, error)
        GetMultipleEstimates(ctx context.Context, in *GetMultipleEstimatesRequest, opts ...grpc.CallOption) (*GetMultipleEstimatesResponse, error)
        CalculateFinalFare(ctx context.Context, in *CalculateFinalFareRequest, opts ...grpc.CallOption) (*CalculateFinalFareResponse, error)
        GetSurgePricing(ctx context.Context, in *GetSurgePricingRequest, opts ...grpc.CallOption) (*GetSurgePricingResponse, error)
        GetVehicleTypes(ctx context.Context, in *GetVehicleTypesRequest, opts ...grpc.CallOption) (*GetVehicleTypesResponse, error)
        UpdateSurgePricing(ctx context.Context, in *UpdateSurgePricingRequest, opts ...grpc.CallOption) (*UpdateSurgePricingResponse, error)
        GetPricingStats(ctx context.Context, in *GetPricingStatsRequest, opts ...grpc.CallOption) (*GetPricingStatsResponse, error)
        // Real-time features
        SubscribeToPricingUpdates(ctx context.Context, in *SubscribeToPricingUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PricingUpdateEvent], error)
}

type pricingServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewPricingServiceClient(cc grpc.ClientConnInterface) PricingServiceClient <span class="cov0" title="0">{
        return &amp;pricingServiceClient{cc}
}</span>

func (c *pricingServiceClient) GetPriceEstimate(ctx context.Context, in *GetPriceEstimateRequest, opts ...grpc.CallOption) (*GetPriceEstimateResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPriceEstimateResponse)
        err := c.cc.Invoke(ctx, PricingService_GetPriceEstimate_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) GetMultipleEstimates(ctx context.Context, in *GetMultipleEstimatesRequest, opts ...grpc.CallOption) (*GetMultipleEstimatesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetMultipleEstimatesResponse)
        err := c.cc.Invoke(ctx, PricingService_GetMultipleEstimates_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) CalculateFinalFare(ctx context.Context, in *CalculateFinalFareRequest, opts ...grpc.CallOption) (*CalculateFinalFareResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CalculateFinalFareResponse)
        err := c.cc.Invoke(ctx, PricingService_CalculateFinalFare_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) GetSurgePricing(ctx context.Context, in *GetSurgePricingRequest, opts ...grpc.CallOption) (*GetSurgePricingResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetSurgePricingResponse)
        err := c.cc.Invoke(ctx, PricingService_GetSurgePricing_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) GetVehicleTypes(ctx context.Context, in *GetVehicleTypesRequest, opts ...grpc.CallOption) (*GetVehicleTypesResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetVehicleTypesResponse)
        err := c.cc.Invoke(ctx, PricingService_GetVehicleTypes_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) UpdateSurgePricing(ctx context.Context, in *UpdateSurgePricingRequest, opts ...grpc.CallOption) (*UpdateSurgePricingResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateSurgePricingResponse)
        err := c.cc.Invoke(ctx, PricingService_UpdateSurgePricing_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) GetPricingStats(ctx context.Context, in *GetPricingStatsRequest, opts ...grpc.CallOption) (*GetPricingStatsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetPricingStatsResponse)
        err := c.cc.Invoke(ctx, PricingService_GetPricingStats_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *pricingServiceClient) SubscribeToPricingUpdates(ctx context.Context, in *SubscribeToPricingUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[PricingUpdateEvent], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;PricingService_ServiceDesc.Streams[0], PricingService_SubscribeToPricingUpdates_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[SubscribeToPricingUpdatesRequest, PricingUpdateEvent]{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PricingService_SubscribeToPricingUpdatesClient = grpc.ServerStreamingClient[PricingUpdateEvent]

// PricingServiceServer is the server API for PricingService service.
// All implementations must embed UnimplementedPricingServiceServer
// for forward compatibility.
//
// PricingService defines the gRPC service for fare calculation
type PricingServiceServer interface {
        GetPriceEstimate(context.Context, *GetPriceEstimateRequest) (*GetPriceEstimateResponse, error)
        GetMultipleEstimates(context.Context, *GetMultipleEstimatesRequest) (*GetMultipleEstimatesResponse, error)
        CalculateFinalFare(context.Context, *CalculateFinalFareRequest) (*CalculateFinalFareResponse, error)
        GetSurgePricing(context.Context, *GetSurgePricingRequest) (*GetSurgePricingResponse, error)
        GetVehicleTypes(context.Context, *GetVehicleTypesRequest) (*GetVehicleTypesResponse, error)
        UpdateSurgePricing(context.Context, *UpdateSurgePricingRequest) (*UpdateSurgePricingResponse, error)
        GetPricingStats(context.Context, *GetPricingStatsRequest) (*GetPricingStatsResponse, error)
        // Real-time features
        SubscribeToPricingUpdates(*SubscribeToPricingUpdatesRequest, grpc.ServerStreamingServer[PricingUpdateEvent]) error
        mustEmbedUnimplementedPricingServiceServer()
}

// UnimplementedPricingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPricingServiceServer struct{}

func (UnimplementedPricingServiceServer) GetPriceEstimate(context.Context, *GetPriceEstimateRequest) (*GetPriceEstimateResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPriceEstimate not implemented")
}</span>
func (UnimplementedPricingServiceServer) GetMultipleEstimates(context.Context, *GetMultipleEstimatesRequest) (*GetMultipleEstimatesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetMultipleEstimates not implemented")
}</span>
func (UnimplementedPricingServiceServer) CalculateFinalFare(context.Context, *CalculateFinalFareRequest) (*CalculateFinalFareResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CalculateFinalFare not implemented")
}</span>
func (UnimplementedPricingServiceServer) GetSurgePricing(context.Context, *GetSurgePricingRequest) (*GetSurgePricingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetSurgePricing not implemented")
}</span>
func (UnimplementedPricingServiceServer) GetVehicleTypes(context.Context, *GetVehicleTypesRequest) (*GetVehicleTypesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetVehicleTypes not implemented")
}</span>
func (UnimplementedPricingServiceServer) UpdateSurgePricing(context.Context, *UpdateSurgePricingRequest) (*UpdateSurgePricingResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateSurgePricing not implemented")
}</span>
func (UnimplementedPricingServiceServer) GetPricingStats(context.Context, *GetPricingStatsRequest) (*GetPricingStatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetPricingStats not implemented")
}</span>
func (UnimplementedPricingServiceServer) SubscribeToPricingUpdates(*SubscribeToPricingUpdatesRequest, grpc.ServerStreamingServer[PricingUpdateEvent]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SubscribeToPricingUpdates not implemented")
}</span>
func (UnimplementedPricingServiceServer) mustEmbedUnimplementedPricingServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedPricingServiceServer) testEmbeddedByValue()                        {<span class="cov0" title="0">}</span>

// UnsafePricingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PricingServiceServer will
// result in compilation errors.
type UnsafePricingServiceServer interface {
        mustEmbedUnimplementedPricingServiceServer()
}

func RegisterPricingServiceServer(s grpc.ServiceRegistrar, srv PricingServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedPricingServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;PricingService_ServiceDesc, srv)</span>
}

func _PricingService_GetPriceEstimate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPriceEstimateRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetPriceEstimate(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_GetPriceEstimate_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetPriceEstimate(ctx, req.(*GetPriceEstimateRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_GetMultipleEstimates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetMultipleEstimatesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetMultipleEstimates(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_GetMultipleEstimates_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetMultipleEstimates(ctx, req.(*GetMultipleEstimatesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_CalculateFinalFare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CalculateFinalFareRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).CalculateFinalFare(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_CalculateFinalFare_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).CalculateFinalFare(ctx, req.(*CalculateFinalFareRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_GetSurgePricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetSurgePricingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetSurgePricing(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_GetSurgePricing_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetSurgePricing(ctx, req.(*GetSurgePricingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_GetVehicleTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetVehicleTypesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetVehicleTypes(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_GetVehicleTypes_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetVehicleTypes(ctx, req.(*GetVehicleTypesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_UpdateSurgePricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateSurgePricingRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).UpdateSurgePricing(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_UpdateSurgePricing_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).UpdateSurgePricing(ctx, req.(*UpdateSurgePricingRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_GetPricingStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetPricingStatsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetPricingStats(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: PricingService_GetPricingStats_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(PricingServiceServer).GetPricingStats(ctx, req.(*GetPricingStatsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _PricingService_SubscribeToPricingUpdates_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(SubscribeToPricingUpdatesRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(PricingServiceServer).SubscribeToPricingUpdates(m, &amp;grpc.GenericServerStream[SubscribeToPricingUpdatesRequest, PricingUpdateEvent]{ServerStream: stream})</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type PricingService_SubscribeToPricingUpdatesServer = grpc.ServerStreamingServer[PricingUpdateEvent]

// PricingService_ServiceDesc is the grpc.ServiceDesc for PricingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PricingService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "pricing.PricingService",
        HandlerType: (*PricingServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetPriceEstimate",
                        Handler:    _PricingService_GetPriceEstimate_Handler,
                },
                {
                        MethodName: "GetMultipleEstimates",
                        Handler:    _PricingService_GetMultipleEstimates_Handler,
                },
                {
                        MethodName: "CalculateFinalFare",
                        Handler:    _PricingService_CalculateFinalFare_Handler,
                },
                {
                        MethodName: "GetSurgePricing",
                        Handler:    _PricingService_GetSurgePricing_Handler,
                },
                {
                        MethodName: "GetVehicleTypes",
                        Handler:    _PricingService_GetVehicleTypes_Handler,
                },
                {
                        MethodName: "UpdateSurgePricing",
                        Handler:    _PricingService_UpdateSurgePricing_Handler,
                },
                {
                        MethodName: "GetPricingStats",
                        Handler:    _PricingService_GetPricingStats_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "SubscribeToPricingUpdates",
                        Handler:       _PricingService_SubscribeToPricingUpdates_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "shared/proto/pricing/pricing.proto",
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v3.21.12
// source: shared/proto/trip/trip.proto

package trip

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Trip status enumeration
type TripStatus int32

const (
        TripStatus_UNKNOWN_STATUS      TripStatus = 0
        TripStatus_REQUESTED           TripStatus = 1
        TripStatus_MATCHED             TripStatus = 2
        TripStatus_DRIVER_EN_ROUTE     TripStatus = 3
        TripStatus_DRIVER_ARRIVED      TripStatus = 4
        TripStatus_TRIP_STARTED        TripStatus = 5
        TripStatus_IN_PROGRESS         TripStatus = 6
        TripStatus_COMPLETED           TripStatus = 7
        TripStatus_CANCELLED_BY_RIDER  TripStatus = 8
        TripStatus_CANCELLED_BY_DRIVER TripStatus = 9
        TripStatus_FAILED              TripStatus = 10
)

// Enum value maps for TripStatus.
var (
        TripStatus_name = map[int32]string{
                0:  "UNKNOWN_STATUS",
                1:  "REQUESTED",
                2:  "MATCHED",
                3:  "DRIVER_EN_ROUTE",
                4:  "DRIVER_ARRIVED",
                5:  "TRIP_STARTED",
                6:  "IN_PROGRESS",
                7:  "COMPLETED",
                8:  "CANCELLED_BY_RIDER",
                9:  "CANCELLED_BY_DRIVER",
                10: "FAILED",
        }
        TripStatus_value = map[string]int32{
                "UNKNOWN_STATUS":      0,
                "REQUESTED":           1,
                "MATCHED":             2,
                "DRIVER_EN_ROUTE":     3,
                "DRIVER_ARRIVED":      4,
                "TRIP_STARTED":        5,
                "IN_PROGRESS":         6,
                "COMPLETED":           7,
                "CANCELLED_BY_RIDER":  8,
                "CANCELLED_BY_DRIVER": 9,
                "FAILED":              10,
        }
)

func (x TripStatus) Enum() *TripStatus <span class="cov0" title="0">{
        p := new(TripStatus)
        *p = x
        return p
}</span>

func (x TripStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TripStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_enumTypes[0].Descriptor()
}</span>

func (TripStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_trip_trip_proto_enumTypes[0]
}</span>

func (x TripStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TripStatus.Descriptor instead.
func (TripStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{0}
}</span>

// Location represents a geographical coordinate (simplified version)
type Location struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Latitude      float64                `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude     float64                `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
        Address       string                 `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Location) Reset() <span class="cov0" title="0">{
        *x = Location{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Location) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Location) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Location) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Location) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Trip represents a ride request and its lifecycle
type Trip struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        Id              string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        RiderId         string                 `protobuf:"bytes,2,opt,name=rider_id,json=riderId,proto3" json:"rider_id,omitempty"`
        DriverId        string                 `protobuf:"bytes,3,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Status          TripStatus             `protobuf:"varint,4,opt,name=status,proto3,enum=trip.TripStatus" json:"status,omitempty"`
        PickupLocation  *Location              `protobuf:"bytes,5,opt,name=pickup_location,json=pickupLocation,proto3" json:"pickup_location,omitempty"`
        Destination     *Location              `protobuf:"bytes,6,opt,name=destination,proto3" json:"destination,omitempty"`
        EstimatedFare   float64                `protobuf:"fixed64,7,opt,name=estimated_fare,json=estimatedFare,proto3" json:"estimated_fare,omitempty"`
        ActualFare      float64                `protobuf:"fixed64,8,opt,name=actual_fare,json=actualFare,proto3" json:"actual_fare,omitempty"`
        PaymentMethodId string                 `protobuf:"bytes,9,opt,name=payment_method_id,json=paymentMethodId,proto3" json:"payment_method_id,omitempty"`
        RequestedAt     *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
        AcceptedAt      *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=accepted_at,json=acceptedAt,proto3" json:"accepted_at,omitempty"`
        StartedAt       *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
        CompletedAt     *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
        Metadata        *TripMetadata          `protobuf:"bytes,14,opt,name=metadata,proto3" json:"metadata,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Trip) Reset() <span class="cov0" title="0">{
        *x = Trip{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Trip) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Trip) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Trip) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Trip.ProtoReflect.Descriptor instead.
func (*Trip) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{1}
}</span>

func (x *Trip) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetRiderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetStatus() TripStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return TripStatus_UNKNOWN_STATUS</span>
}

func (x *Trip) GetPickupLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PickupLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetEstimatedFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EstimatedFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Trip) GetActualFare() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualFare
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Trip) GetPaymentMethodId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentMethodId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Trip) GetRequestedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequestedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetAcceptedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AcceptedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetStartedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetCompletedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CompletedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Trip) GetMetadata() *TripMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Additional trip metadata
type TripMetadata struct {
        state                    protoimpl.MessageState `protogen:"open.v1"`
        VehicleType              string                 `protobuf:"bytes,1,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        DistanceKm               float64                `protobuf:"fixed64,2,opt,name=distance_km,json=distanceKm,proto3" json:"distance_km,omitempty"`
        EstimatedDurationMinutes int32                  `protobuf:"varint,3,opt,name=estimated_duration_minutes,json=estimatedDurationMinutes,proto3" json:"estimated_duration_minutes,omitempty"`
        ActualDurationMinutes    int32                  `protobuf:"varint,4,opt,name=actual_duration_minutes,json=actualDurationMinutes,proto3" json:"actual_duration_minutes,omitempty"`
        SurgeMultiplier          float64                `protobuf:"fixed64,5,opt,name=surge_multiplier,json=surgeMultiplier,proto3" json:"surge_multiplier,omitempty"`
        CancellationReason       string                 `protobuf:"bytes,6,opt,name=cancellation_reason,json=cancellationReason,proto3" json:"cancellation_reason,omitempty"`
        RiderRating              float64                `protobuf:"fixed64,7,opt,name=rider_rating,json=riderRating,proto3" json:"rider_rating,omitempty"`
        DriverRating             float64                `protobuf:"fixed64,8,opt,name=driver_rating,json=driverRating,proto3" json:"driver_rating,omitempty"`
        unknownFields            protoimpl.UnknownFields
        sizeCache                protoimpl.SizeCache
}

func (x *TripMetadata) Reset() <span class="cov0" title="0">{
        *x = TripMetadata{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TripMetadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TripMetadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TripMetadata) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TripMetadata.ProtoReflect.Descriptor instead.
func (*TripMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{2}
}</span>

func (x *TripMetadata) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TripMetadata) GetDistanceKm() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DistanceKm
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TripMetadata) GetEstimatedDurationMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EstimatedDurationMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TripMetadata) GetActualDurationMinutes() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ActualDurationMinutes
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TripMetadata) GetSurgeMultiplier() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SurgeMultiplier
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TripMetadata) GetCancellationReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CancellationReason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TripMetadata) GetRiderRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiderRating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *TripMetadata) GetDriverRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverRating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Request/Response messages
type CreateTripRequest struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        RiderId         string                 `protobuf:"bytes,1,opt,name=rider_id,json=riderId,proto3" json:"rider_id,omitempty"`
        PickupLocation  *Location              `protobuf:"bytes,2,opt,name=pickup_location,json=pickupLocation,proto3" json:"pickup_location,omitempty"`
        Destination     *Location              `protobuf:"bytes,3,opt,name=destination,proto3" json:"destination,omitempty"`
        VehicleType     string                 `protobuf:"bytes,4,opt,name=vehicle_type,json=vehicleType,proto3" json:"vehicle_type,omitempty"`
        PaymentMethodId string                 `protobuf:"bytes,5,opt,name=payment_method_id,json=paymentMethodId,proto3" json:"payment_method_id,omitempty"`
        Metadata        *TripMetadata          `protobuf:"bytes,6,opt,name=metadata,proto3" json:"metadata,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *CreateTripRequest) Reset() <span class="cov0" title="0">{
        *x = CreateTripRequest{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTripRequest.ProtoReflect.Descriptor instead.
func (*CreateTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CreateTripRequest) GetRiderId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RiderId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTripRequest) GetPickupLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PickupLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateTripRequest) GetDestination() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateTripRequest) GetVehicleType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTripRequest) GetPaymentMethodId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PaymentMethodId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTripRequest) GetMetadata() *TripMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type CreateTripResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Trip          *Trip                  `protobuf:"bytes,1,opt,name=trip,proto3" json:"trip,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateTripResponse) Reset() <span class="cov0" title="0">{
        *x = CreateTripResponse{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateTripResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateTripResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateTripResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateTripResponse.ProtoReflect.Descriptor instead.
func (*CreateTripResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateTripResponse) GetTrip() *Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateTripResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *CreateTripResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateTripResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetTripRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TripId        string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTripRequest) Reset() <span class="cov0" title="0">{
        *x = GetTripRequest{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripRequest.ProtoReflect.Descriptor instead.
func (*GetTripRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{5}
}</span>

func (x *GetTripRequest) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetTripResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Trip          *Trip                  `protobuf:"bytes,1,opt,name=trip,proto3" json:"trip,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetTripResponse) Reset() <span class="cov0" title="0">{
        *x = GetTripResponse{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetTripResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTripResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTripResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTripResponse.ProtoReflect.Descriptor instead.
func (*GetTripResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetTripResponse) GetTrip() *Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetTripResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

type UpdateTripStatusRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TripId        string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        Status        TripStatus             `protobuf:"varint,2,opt,name=status,proto3,enum=trip.TripStatus" json:"status,omitempty"`
        DriverId      string                 `protobuf:"bytes,3,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Reason        string                 `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateTripStatusRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateTripStatusRequest{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateTripStatusRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTripStatusRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTripStatusRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTripStatusRequest.ProtoReflect.Descriptor instead.
func (*UpdateTripStatusRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{7}
}</span>

func (x *UpdateTripStatusRequest) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTripStatusRequest) GetStatus() TripStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return TripStatus_UNKNOWN_STATUS</span>
}

func (x *UpdateTripStatusRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateTripStatusRequest) GetReason() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reason
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type UpdateTripStatusResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Trip          *Trip                  `protobuf:"bytes,1,opt,name=trip,proto3" json:"trip,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateTripStatusResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateTripStatusResponse{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateTripStatusResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateTripStatusResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateTripStatusResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateTripStatusResponse.ProtoReflect.Descriptor instead.
func (*UpdateTripStatusResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{8}
}</span>

func (x *UpdateTripStatusResponse) GetTrip() *Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trip
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateTripStatusResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateTripStatusResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserTripsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        UserId        string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        Role          string                 `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"` // "rider" or "driver"
        Limit         int32                  `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset        int32                  `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
        Status        TripStatus             `protobuf:"varint,5,opt,name=status,proto3,enum=trip.TripStatus" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserTripsRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserTripsRequest{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserTripsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserTripsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserTripsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserTripsRequest.ProtoReflect.Descriptor instead.
func (*GetUserTripsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{9}
}</span>

func (x *GetUserTripsRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserTripsRequest) GetRole() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetUserTripsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetUserTripsRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetUserTripsRequest) GetStatus() TripStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return TripStatus_UNKNOWN_STATUS</span>
}

type GetUserTripsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Trips         []*Trip                `protobuf:"bytes,1,rep,name=trips,proto3" json:"trips,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        HasMore       bool                   `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserTripsResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserTripsResponse{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserTripsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserTripsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserTripsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserTripsResponse.ProtoReflect.Descriptor instead.
func (*GetUserTripsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{10}
}</span>

func (x *GetUserTripsResponse) GetTrips() []*Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trips
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetUserTripsResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *GetUserTripsResponse) GetHasMore() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasMore
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetActiveTripsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Region        string                 `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
        Limit         int32                  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetActiveTripsRequest) Reset() <span class="cov0" title="0">{
        *x = GetActiveTripsRequest{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetActiveTripsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetActiveTripsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetActiveTripsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetActiveTripsRequest.ProtoReflect.Descriptor instead.
func (*GetActiveTripsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{11}
}</span>

func (x *GetActiveTripsRequest) GetRegion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetActiveTripsRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GetActiveTripsResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Trips         []*Trip                `protobuf:"bytes,1,rep,name=trips,proto3" json:"trips,omitempty"`
        Count         int32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetActiveTripsResponse) Reset() <span class="cov0" title="0">{
        *x = GetActiveTripsResponse{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetActiveTripsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetActiveTripsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetActiveTripsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetActiveTripsResponse.ProtoReflect.Descriptor instead.
func (*GetActiveTripsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{12}
}</span>

func (x *GetActiveTripsResponse) GetTrips() []*Trip <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trips
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetActiveTripsResponse) GetCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Count
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Real-time trip updates
type TripUpdateEvent struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        TripId          string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        OldStatus       TripStatus             `protobuf:"varint,2,opt,name=old_status,json=oldStatus,proto3,enum=trip.TripStatus" json:"old_status,omitempty"`
        NewStatus       TripStatus             `protobuf:"varint,3,opt,name=new_status,json=newStatus,proto3,enum=trip.TripStatus" json:"new_status,omitempty"`
        CurrentLocation *Location              `protobuf:"bytes,4,opt,name=current_location,json=currentLocation,proto3" json:"current_location,omitempty"`
        Timestamp       *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Metadata        map[string]string      `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *TripUpdateEvent) Reset() <span class="cov0" title="0">{
        *x = TripUpdateEvent{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *TripUpdateEvent) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TripUpdateEvent) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TripUpdateEvent) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TripUpdateEvent.ProtoReflect.Descriptor instead.
func (*TripUpdateEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{13}
}</span>

func (x *TripUpdateEvent) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TripUpdateEvent) GetOldStatus() TripStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OldStatus
        }</span>
        <span class="cov0" title="0">return TripStatus_UNKNOWN_STATUS</span>
}

func (x *TripUpdateEvent) GetNewStatus() TripStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NewStatus
        }</span>
        <span class="cov0" title="0">return TripStatus_UNKNOWN_STATUS</span>
}

func (x *TripUpdateEvent) GetCurrentLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TripUpdateEvent) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TripUpdateEvent) GetMetadata() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SubscribeToTripUpdatesRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        TripId        string                 `protobuf:"bytes,1,opt,name=trip_id,json=tripId,proto3" json:"trip_id,omitempty"`
        UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToTripUpdatesRequest) Reset() <span class="cov0" title="0">{
        *x = SubscribeToTripUpdatesRequest{}
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *SubscribeToTripUpdatesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubscribeToTripUpdatesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubscribeToTripUpdatesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_trip_trip_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubscribeToTripUpdatesRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToTripUpdatesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_trip_trip_proto_rawDescGZIP(), []int{14}
}</span>

func (x *SubscribeToTripUpdatesRequest) GetTripId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TripId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SubscribeToTripUpdatesRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_shared_proto_trip_trip_proto protoreflect.FileDescriptor

const file_shared_proto_trip_trip_proto_rawDesc = "" +
        "\n" +
        "\x1cshared/proto/trip/trip.proto\x12\x04trip\x1a\x1fgoogle/protobuf/timestamp.proto\"^\n" +
        "\bLocation\x12\x1a\n" +
        "\blatitude\x18\x01 \x01(\x01R\blatitude\x12\x1c\n" +
        "\tlongitude\x18\x02 \x01(\x01R\tlongitude\x12\x18\n" +
        "\aaddress\x18\x03 \x01(\tR\aaddress\"\xfd\x04\n" +
        "\x04Trip\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x19\n" +
        "\brider_id\x18\x02 \x01(\tR\ariderId\x12\x1b\n" +
        "\tdriver_id\x18\x03 \x01(\tR\bdriverId\x12(\n" +
        "\x06status\x18\x04 \x01(\x0e2\x10.trip.TripStatusR\x06status\x127\n" +
        "\x0fpickup_location\x18\x05 \x01(\v2\x0e.trip.LocationR\x0epickupLocation\x120\n" +
        "\vdestination\x18\x06 \x01(\v2\x0e.trip.LocationR\vdestination\x12%\n" +
        "\x0eestimated_fare\x18\a \x01(\x01R\restimatedFare\x12\x1f\n" +
        "\vactual_fare\x18\b \x01(\x01R\n" +
        "actualFare\x12*\n" +
        "\x11payment_method_id\x18\t \x01(\tR\x0fpaymentMethodId\x12=\n" +
        "\frequested_at\x18\n" +
        " \x01(\v2\x1a.google.protobuf.TimestampR\vrequestedAt\x12;\n" +
        "\vaccepted_at\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "acceptedAt\x129\n" +
        "\n" +
        "started_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\tstartedAt\x12=\n" +
        "\fcompleted_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\vcompletedAt\x12.\n" +
        "\bmetadata\x18\x0e \x01(\v2\x12.trip.TripMetadataR\bmetadata\"\xec\x02\n" +
        "\fTripMetadata\x12!\n" +
        "\fvehicle_type\x18\x01 \x01(\tR\vvehicleType\x12\x1f\n" +
        "\vdistance_km\x18\x02 \x01(\x01R\n" +
        "distanceKm\x12&lt;\n" +
        "\x1aestimated_duration_minutes\x18\x03 \x01(\x05R\x18estimatedDurationMinutes\x126\n" +
        "\x17actual_duration_minutes\x18\x04 \x01(\x05R\x15actualDurationMinutes\x12)\n" +
        "\x10surge_multiplier\x18\x05 \x01(\x01R\x0fsurgeMultiplier\x12/\n" +
        "\x13cancellation_reason\x18\x06 \x01(\tR\x12cancellationReason\x12!\n" +
        "\frider_rating\x18\a \x01(\x01R\vriderRating\x12#\n" +
        "\rdriver_rating\x18\b \x01(\x01R\fdriverRating\"\x98\x02\n" +
        "\x11CreateTripRequest\x12\x19\n" +
        "\brider_id\x18\x01 \x01(\tR\ariderId\x127\n" +
        "\x0fpickup_location\x18\x02 \x01(\v2\x0e.trip.LocationR\x0epickupLocation\x120\n" +
        "\vdestination\x18\x03 \x01(\v2\x0e.trip.LocationR\vdestination\x12!\n" +
        "\fvehicle_type\x18\x04 \x01(\tR\vvehicleType\x12*\n" +
        "\x11payment_method_id\x18\x05 \x01(\tR\x0fpaymentMethodId\x12.\n" +
        "\bmetadata\x18\x06 \x01(\v2\x12.trip.TripMetadataR\bmetadata\"\x80\x01\n" +
        "\x12CreateTripResponse\x12\x1e\n" +
        "\x04trip\x18\x01 \x01(\v2\n" +
        ".trip.TripR\x04trip\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\")\n" +
        "\x0eGetTripRequest\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\"G\n" +
        "\x0fGetTripResponse\x12\x1e\n" +
        "\x04trip\x18\x01 \x01(\v2\n" +
        ".trip.TripR\x04trip\x12\x14\n" +
        "\x05found\x18\x02 \x01(\bR\x05found\"\x91\x01\n" +
        "\x17UpdateTripStatusRequest\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\x12(\n" +
        "\x06status\x18\x02 \x01(\x0e2\x10.trip.TripStatusR\x06status\x12\x1b\n" +
        "\tdriver_id\x18\x03 \x01(\tR\bdriverId\x12\x16\n" +
        "\x06reason\x18\x04 \x01(\tR\x06reason\"n\n" +
        "\x18UpdateTripStatusResponse\x12\x1e\n" +
        "\x04trip\x18\x01 \x01(\v2\n" +
        ".trip.TripR\x04trip\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\"\x9a\x01\n" +
        "\x13GetUserTripsRequest\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\x12\x12\n" +
        "\x04role\x18\x02 \x01(\tR\x04role\x12\x14\n" +
        "\x05limit\x18\x03 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06offset\x18\x04 \x01(\x05R\x06offset\x12(\n" +
        "\x06status\x18\x05 \x01(\x0e2\x10.trip.TripStatusR\x06status\"t\n" +
        "\x14GetUserTripsResponse\x12 \n" +
        "\x05trips\x18\x01 \x03(\v2\n" +
        ".trip.TripR\x05trips\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x12\x19\n" +
        "\bhas_more\x18\x03 \x01(\bR\ahasMore\"E\n" +
        "\x15GetActiveTripsRequest\x12\x16\n" +
        "\x06region\x18\x01 \x01(\tR\x06region\x12\x14\n" +
        "\x05limit\x18\x02 \x01(\x05R\x05limit\"P\n" +
        "\x16GetActiveTripsResponse\x12 \n" +
        "\x05trips\x18\x01 \x03(\v2\n" +
        ".trip.TripR\x05trips\x12\x14\n" +
        "\x05count\x18\x02 \x01(\x05R\x05count\"\xff\x02\n" +
        "\x0fTripUpdateEvent\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\x12/\n" +
        "\n" +
        "old_status\x18\x02 \x01(\x0e2\x10.trip.TripStatusR\toldStatus\x12/\n" +
        "\n" +
        "new_status\x18\x03 \x01(\x0e2\x10.trip.TripStatusR\tnewStatus\x129\n" +
        "\x10current_location\x18\x04 \x01(\v2\x0e.trip.LocationR\x0fcurrentLocation\x128\n" +
        "\ttimestamp\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12?\n" +
        "\bmetadata\x18\x06 \x03(\v2#.trip.TripUpdateEvent.MetadataEntryR\bmetadata\x1a;\n" +
        "\rMetadataEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"Q\n" +
        "\x1dSubscribeToTripUpdatesRequest\x12\x17\n" +
        "\atrip_id\x18\x01 \x01(\tR\x06tripId\x12\x17\n" +
        "\auser_id\x18\x02 \x01(\tR\x06userId*\xd4\x01\n" +
        "\n" +
        "TripStatus\x12\x12\n" +
        "\x0eUNKNOWN_STATUS\x10\x00\x12\r\n" +
        "\tREQUESTED\x10\x01\x12\v\n" +
        "\aMATCHED\x10\x02\x12\x13\n" +
        "\x0fDRIVER_EN_ROUTE\x10\x03\x12\x12\n" +
        "\x0eDRIVER_ARRIVED\x10\x04\x12\x10\n" +
        "\fTRIP_STARTED\x10\x05\x12\x0f\n" +
        "\vIN_PROGRESS\x10\x06\x12\r\n" +
        "\tCOMPLETED\x10\a\x12\x16\n" +
        "\x12CANCELLED_BY_RIDER\x10\b\x12\x17\n" +
        "\x13CANCELLED_BY_DRIVER\x10\t\x12\n" +
        "\n" +
        "\x06FAILED\x10\n" +
        "2\xc5\x03\n" +
        "\vTripService\x12?\n" +
        "\n" +
        "CreateTrip\x12\x17.trip.CreateTripRequest\x1a\x18.trip.CreateTripResponse\x126\n" +
        "\aGetTrip\x12\x14.trip.GetTripRequest\x1a\x15.trip.GetTripResponse\x12Q\n" +
        "\x10UpdateTripStatus\x12\x1d.trip.UpdateTripStatusRequest\x1a\x1e.trip.UpdateTripStatusResponse\x12E\n" +
        "\fGetUserTrips\x12\x19.trip.GetUserTripsRequest\x1a\x1a.trip.GetUserTripsResponse\x12K\n" +
        "\x0eGetActiveTrips\x12\x1b.trip.GetActiveTripsRequest\x1a\x1c.trip.GetActiveTripsResponse\x12V\n" +
        "\x16SubscribeToTripUpdates\x12#.trip.SubscribeToTripUpdatesRequest\x1a\x15.trip.TripUpdateEvent0\x01B1Z/github.com/rideshare-platform/shared/proto/tripb\x06proto3"

var (
        file_shared_proto_trip_trip_proto_rawDescOnce sync.Once
        file_shared_proto_trip_trip_proto_rawDescData []byte
)

func file_shared_proto_trip_trip_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_shared_proto_trip_trip_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_shared_proto_trip_trip_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_trip_trip_proto_rawDesc), len(file_shared_proto_trip_trip_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_shared_proto_trip_trip_proto_rawDescData</span>
}

var file_shared_proto_trip_trip_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_shared_proto_trip_trip_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_shared_proto_trip_trip_proto_goTypes = []any{
        (TripStatus)(0),                       // 0: trip.TripStatus
        (*Location)(nil),                      // 1: trip.Location
        (*Trip)(nil),                          // 2: trip.Trip
        (*TripMetadata)(nil),                  // 3: trip.TripMetadata
        (*CreateTripRequest)(nil),             // 4: trip.CreateTripRequest
        (*CreateTripResponse)(nil),            // 5: trip.CreateTripResponse
        (*GetTripRequest)(nil),                // 6: trip.GetTripRequest
        (*GetTripResponse)(nil),               // 7: trip.GetTripResponse
        (*UpdateTripStatusRequest)(nil),       // 8: trip.UpdateTripStatusRequest
        (*UpdateTripStatusResponse)(nil),      // 9: trip.UpdateTripStatusResponse
        (*GetUserTripsRequest)(nil),           // 10: trip.GetUserTripsRequest
        (*GetUserTripsResponse)(nil),          // 11: trip.GetUserTripsResponse
        (*GetActiveTripsRequest)(nil),         // 12: trip.GetActiveTripsRequest
        (*GetActiveTripsResponse)(nil),        // 13: trip.GetActiveTripsResponse
        (*TripUpdateEvent)(nil),               // 14: trip.TripUpdateEvent
        (*SubscribeToTripUpdatesRequest)(nil), // 15: trip.SubscribeToTripUpdatesRequest
        nil,                                   // 16: trip.TripUpdateEvent.MetadataEntry
        (*timestamppb.Timestamp)(nil),         // 17: google.protobuf.Timestamp
}
var file_shared_proto_trip_trip_proto_depIdxs = []int32{
        0,  // 0: trip.Trip.status:type_name -&gt; trip.TripStatus
        1,  // 1: trip.Trip.pickup_location:type_name -&gt; trip.Location
        1,  // 2: trip.Trip.destination:type_name -&gt; trip.Location
        17, // 3: trip.Trip.requested_at:type_name -&gt; google.protobuf.Timestamp
        17, // 4: trip.Trip.accepted_at:type_name -&gt; google.protobuf.Timestamp
        17, // 5: trip.Trip.started_at:type_name -&gt; google.protobuf.Timestamp
        17, // 6: trip.Trip.completed_at:type_name -&gt; google.protobuf.Timestamp
        3,  // 7: trip.Trip.metadata:type_name -&gt; trip.TripMetadata
        1,  // 8: trip.CreateTripRequest.pickup_location:type_name -&gt; trip.Location
        1,  // 9: trip.CreateTripRequest.destination:type_name -&gt; trip.Location
        3,  // 10: trip.CreateTripRequest.metadata:type_name -&gt; trip.TripMetadata
        2,  // 11: trip.CreateTripResponse.trip:type_name -&gt; trip.Trip
        2,  // 12: trip.GetTripResponse.trip:type_name -&gt; trip.Trip
        0,  // 13: trip.UpdateTripStatusRequest.status:type_name -&gt; trip.TripStatus
        2,  // 14: trip.UpdateTripStatusResponse.trip:type_name -&gt; trip.Trip
        0,  // 15: trip.GetUserTripsRequest.status:type_name -&gt; trip.TripStatus
        2,  // 16: trip.GetUserTripsResponse.trips:type_name -&gt; trip.Trip
        2,  // 17: trip.GetActiveTripsResponse.trips:type_name -&gt; trip.Trip
        0,  // 18: trip.TripUpdateEvent.old_status:type_name -&gt; trip.TripStatus
        0,  // 19: trip.TripUpdateEvent.new_status:type_name -&gt; trip.TripStatus
        1,  // 20: trip.TripUpdateEvent.current_location:type_name -&gt; trip.Location
        17, // 21: trip.TripUpdateEvent.timestamp:type_name -&gt; google.protobuf.Timestamp
        16, // 22: trip.TripUpdateEvent.metadata:type_name -&gt; trip.TripUpdateEvent.MetadataEntry
        4,  // 23: trip.TripService.CreateTrip:input_type -&gt; trip.CreateTripRequest
        6,  // 24: trip.TripService.GetTrip:input_type -&gt; trip.GetTripRequest
        8,  // 25: trip.TripService.UpdateTripStatus:input_type -&gt; trip.UpdateTripStatusRequest
        10, // 26: trip.TripService.GetUserTrips:input_type -&gt; trip.GetUserTripsRequest
        12, // 27: trip.TripService.GetActiveTrips:input_type -&gt; trip.GetActiveTripsRequest
        15, // 28: trip.TripService.SubscribeToTripUpdates:input_type -&gt; trip.SubscribeToTripUpdatesRequest
        5,  // 29: trip.TripService.CreateTrip:output_type -&gt; trip.CreateTripResponse
        7,  // 30: trip.TripService.GetTrip:output_type -&gt; trip.GetTripResponse
        9,  // 31: trip.TripService.UpdateTripStatus:output_type -&gt; trip.UpdateTripStatusResponse
        11, // 32: trip.TripService.GetUserTrips:output_type -&gt; trip.GetUserTripsResponse
        13, // 33: trip.TripService.GetActiveTrips:output_type -&gt; trip.GetActiveTripsResponse
        14, // 34: trip.TripService.SubscribeToTripUpdates:output_type -&gt; trip.TripUpdateEvent
        29, // [29:35] is the sub-list for method output_type
        23, // [23:29] is the sub-list for method input_type
        23, // [23:23] is the sub-list for extension type_name
        23, // [23:23] is the sub-list for extension extendee
        0,  // [0:23] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_shared_proto_trip_trip_proto_init() }</span>
func file_shared_proto_trip_trip_proto_init() <span class="cov0" title="0">{
        if File_shared_proto_trip_trip_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_trip_trip_proto_rawDesc), len(file_shared_proto_trip_trip_proto_rawDesc)),
                        NumEnums:      1,
                        NumMessages:   16,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_shared_proto_trip_trip_proto_goTypes,
                DependencyIndexes: file_shared_proto_trip_trip_proto_depIdxs,
                EnumInfos:         file_shared_proto_trip_trip_proto_enumTypes,
                MessageInfos:      file_shared_proto_trip_trip_proto_msgTypes,
        }.Build()
        File_shared_proto_trip_trip_proto = out.File
        file_shared_proto_trip_trip_proto_goTypes = nil
        file_shared_proto_trip_trip_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/trip/trip.proto

package trip

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        TripService_CreateTrip_FullMethodName             = "/trip.TripService/CreateTrip"
        TripService_GetTrip_FullMethodName                = "/trip.TripService/GetTrip"
        TripService_UpdateTripStatus_FullMethodName       = "/trip.TripService/UpdateTripStatus"
        TripService_GetUserTrips_FullMethodName           = "/trip.TripService/GetUserTrips"
        TripService_GetActiveTrips_FullMethodName         = "/trip.TripService/GetActiveTrips"
        TripService_SubscribeToTripUpdates_FullMethodName = "/trip.TripService/SubscribeToTripUpdates"
)

// TripServiceClient is the client API for TripService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// TripService defines the gRPC service for trip management
type TripServiceClient interface {
        CreateTrip(ctx context.Context, in *CreateTripRequest, opts ...grpc.CallOption) (*CreateTripResponse, error)
        GetTrip(ctx context.Context, in *GetTripRequest, opts ...grpc.CallOption) (*GetTripResponse, error)
        UpdateTripStatus(ctx context.Context, in *UpdateTripStatusRequest, opts ...grpc.CallOption) (*UpdateTripStatusResponse, error)
        GetUserTrips(ctx context.Context, in *GetUserTripsRequest, opts ...grpc.CallOption) (*GetUserTripsResponse, error)
        GetActiveTrips(ctx context.Context, in *GetActiveTripsRequest, opts ...grpc.CallOption) (*GetActiveTripsResponse, error)
        // Real-time features
        SubscribeToTripUpdates(ctx context.Context, in *SubscribeToTripUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TripUpdateEvent], error)
}

type tripServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTripServiceClient(cc grpc.ClientConnInterface) TripServiceClient <span class="cov0" title="0">{
        return &amp;tripServiceClient{cc}
}</span>

func (c *tripServiceClient) CreateTrip(ctx context.Context, in *CreateTripRequest, opts ...grpc.CallOption) (*CreateTripResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateTripResponse)
        err := c.cc.Invoke(ctx, TripService_CreateTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripServiceClient) GetTrip(ctx context.Context, in *GetTripRequest, opts ...grpc.CallOption) (*GetTripResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetTripResponse)
        err := c.cc.Invoke(ctx, TripService_GetTrip_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripServiceClient) UpdateTripStatus(ctx context.Context, in *UpdateTripStatusRequest, opts ...grpc.CallOption) (*UpdateTripStatusResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateTripStatusResponse)
        err := c.cc.Invoke(ctx, TripService_UpdateTripStatus_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripServiceClient) GetUserTrips(ctx context.Context, in *GetUserTripsRequest, opts ...grpc.CallOption) (*GetUserTripsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserTripsResponse)
        err := c.cc.Invoke(ctx, TripService_GetUserTrips_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripServiceClient) GetActiveTrips(ctx context.Context, in *GetActiveTripsRequest, opts ...grpc.CallOption) (*GetActiveTripsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetActiveTripsResponse)
        err := c.cc.Invoke(ctx, TripService_GetActiveTrips_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *tripServiceClient) SubscribeToTripUpdates(ctx context.Context, in *SubscribeToTripUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TripUpdateEvent], error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        stream, err := c.cc.NewStream(ctx, &amp;TripService_ServiceDesc.Streams[0], TripService_SubscribeToTripUpdates_FullMethodName, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;grpc.GenericClientStream[SubscribeToTripUpdatesRequest, TripUpdateEvent]{ClientStream: stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TripService_SubscribeToTripUpdatesClient = grpc.ServerStreamingClient[TripUpdateEvent]

// TripServiceServer is the server API for TripService service.
// All implementations must embed UnimplementedTripServiceServer
// for forward compatibility.
//
// TripService defines the gRPC service for trip management
type TripServiceServer interface {
        CreateTrip(context.Context, *CreateTripRequest) (*CreateTripResponse, error)
        GetTrip(context.Context, *GetTripRequest) (*GetTripResponse, error)
        UpdateTripStatus(context.Context, *UpdateTripStatusRequest) (*UpdateTripStatusResponse, error)
        GetUserTrips(context.Context, *GetUserTripsRequest) (*GetUserTripsResponse, error)
        GetActiveTrips(context.Context, *GetActiveTripsRequest) (*GetActiveTripsResponse, error)
        // Real-time features
        SubscribeToTripUpdates(*SubscribeToTripUpdatesRequest, grpc.ServerStreamingServer[TripUpdateEvent]) error
        mustEmbedUnimplementedTripServiceServer()
}

// UnimplementedTripServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTripServiceServer struct{}

func (UnimplementedTripServiceServer) CreateTrip(context.Context, *CreateTripRequest) (*CreateTripResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateTrip not implemented")
}</span>
func (UnimplementedTripServiceServer) GetTrip(context.Context, *GetTripRequest) (*GetTripResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTrip not implemented")
}</span>
func (UnimplementedTripServiceServer) UpdateTripStatus(context.Context, *UpdateTripStatusRequest) (*UpdateTripStatusResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateTripStatus not implemented")
}</span>
func (UnimplementedTripServiceServer) GetUserTrips(context.Context, *GetUserTripsRequest) (*GetUserTripsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUserTrips not implemented")
}</span>
func (UnimplementedTripServiceServer) GetActiveTrips(context.Context, *GetActiveTripsRequest) (*GetActiveTripsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetActiveTrips not implemented")
}</span>
func (UnimplementedTripServiceServer) SubscribeToTripUpdates(*SubscribeToTripUpdatesRequest, grpc.ServerStreamingServer[TripUpdateEvent]) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method SubscribeToTripUpdates not implemented")
}</span>
func (UnimplementedTripServiceServer) mustEmbedUnimplementedTripServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedTripServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeTripServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TripServiceServer will
// result in compilation errors.
type UnsafeTripServiceServer interface {
        mustEmbedUnimplementedTripServiceServer()
}

func RegisterTripServiceServer(s grpc.ServiceRegistrar, srv TripServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedTripServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;TripService_ServiceDesc, srv)</span>
}

func _TripService_CreateTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).CreateTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TripService_CreateTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).CreateTrip(ctx, req.(*CreateTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TripService_GetTrip_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTripRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).GetTrip(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TripService_GetTrip_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).GetTrip(ctx, req.(*GetTripRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TripService_UpdateTripStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateTripStatusRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).UpdateTripStatus(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TripService_UpdateTripStatus_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).UpdateTripStatus(ctx, req.(*UpdateTripStatusRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TripService_GetUserTrips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserTripsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).GetUserTrips(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TripService_GetUserTrips_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).GetUserTrips(ctx, req.(*GetUserTripsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TripService_GetActiveTrips_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetActiveTripsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).GetActiveTrips(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TripService_GetActiveTrips_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TripServiceServer).GetActiveTrips(ctx, req.(*GetActiveTripsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TripService_SubscribeToTripUpdates_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(SubscribeToTripUpdatesRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(TripServiceServer).SubscribeToTripUpdates(m, &amp;grpc.GenericServerStream[SubscribeToTripUpdatesRequest, TripUpdateEvent]{ServerStream: stream})</span>
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TripService_SubscribeToTripUpdatesServer = grpc.ServerStreamingServer[TripUpdateEvent]

// TripService_ServiceDesc is the grpc.ServiceDesc for TripService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TripService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "trip.TripService",
        HandlerType: (*TripServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateTrip",
                        Handler:    _TripService_CreateTrip_Handler,
                },
                {
                        MethodName: "GetTrip",
                        Handler:    _TripService_GetTrip_Handler,
                },
                {
                        MethodName: "UpdateTripStatus",
                        Handler:    _TripService_UpdateTripStatus_Handler,
                },
                {
                        MethodName: "GetUserTrips",
                        Handler:    _TripService_GetUserTrips_Handler,
                },
                {
                        MethodName: "GetActiveTrips",
                        Handler:    _TripService_GetActiveTrips_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "SubscribeToTripUpdates",
                        Handler:       _TripService_SubscribeToTripUpdates_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "shared/proto/trip/trip.proto",
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.8
//         protoc        v3.21.12
// source: shared/proto/user/user.proto

package user

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// User roles
type UserRole int32

const (
        UserRole_UNKNOWN_ROLE UserRole = 0
        UserRole_RIDER        UserRole = 1
        UserRole_DRIVER       UserRole = 2
        UserRole_ADMIN        UserRole = 3
)

// Enum value maps for UserRole.
var (
        UserRole_name = map[int32]string{
                0: "UNKNOWN_ROLE",
                1: "RIDER",
                2: "DRIVER",
                3: "ADMIN",
        }
        UserRole_value = map[string]int32{
                "UNKNOWN_ROLE": 0,
                "RIDER":        1,
                "DRIVER":       2,
                "ADMIN":        3,
        }
)

func (x UserRole) Enum() *UserRole <span class="cov0" title="0">{
        p := new(UserRole)
        *p = x
        return p
}</span>

func (x UserRole) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (UserRole) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_enumTypes[0].Descriptor()
}</span>

func (UserRole) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_user_user_proto_enumTypes[0]
}</span>

func (x UserRole) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use UserRole.Descriptor instead.
func (UserRole) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{0}
}</span>

// User status
type UserStatus int32

const (
        UserStatus_UNKNOWN_STATUS UserStatus = 0
        UserStatus_ACTIVE         UserStatus = 1
        UserStatus_INACTIVE       UserStatus = 2
        UserStatus_SUSPENDED      UserStatus = 3
        UserStatus_BANNED         UserStatus = 4
)

// Enum value maps for UserStatus.
var (
        UserStatus_name = map[int32]string{
                0: "UNKNOWN_STATUS",
                1: "ACTIVE",
                2: "INACTIVE",
                3: "SUSPENDED",
                4: "BANNED",
        }
        UserStatus_value = map[string]int32{
                "UNKNOWN_STATUS": 0,
                "ACTIVE":         1,
                "INACTIVE":       2,
                "SUSPENDED":      3,
                "BANNED":         4,
        }
)

func (x UserStatus) Enum() *UserStatus <span class="cov0" title="0">{
        p := new(UserStatus)
        *p = x
        return p
}</span>

func (x UserStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (UserStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_enumTypes[1].Descriptor()
}</span>

func (UserStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_user_user_proto_enumTypes[1]
}</span>

func (x UserStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use UserStatus.Descriptor instead.
func (UserStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{1}
}</span>

type DriverStatus int32

const (
        DriverStatus_UNKNOWN_DRIVER_STATUS DriverStatus = 0
        DriverStatus_OFFLINE               DriverStatus = 1
        DriverStatus_ONLINE                DriverStatus = 2
        DriverStatus_ON_TRIP               DriverStatus = 3
        DriverStatus_BREAK                 DriverStatus = 4
)

// Enum value maps for DriverStatus.
var (
        DriverStatus_name = map[int32]string{
                0: "UNKNOWN_DRIVER_STATUS",
                1: "OFFLINE",
                2: "ONLINE",
                3: "ON_TRIP",
                4: "BREAK",
        }
        DriverStatus_value = map[string]int32{
                "UNKNOWN_DRIVER_STATUS": 0,
                "OFFLINE":               1,
                "ONLINE":                2,
                "ON_TRIP":               3,
                "BREAK":                 4,
        }
)

func (x DriverStatus) Enum() *DriverStatus <span class="cov0" title="0">{
        p := new(DriverStatus)
        *p = x
        return p
}</span>

func (x DriverStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (DriverStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_enumTypes[2].Descriptor()
}</span>

func (DriverStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_shared_proto_user_user_proto_enumTypes[2]
}</span>

func (x DriverStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use DriverStatus.Descriptor instead.
func (DriverStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{2}
}</span>

// Location represents a geographical coordinate (duplicated for independence)
type Location struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Latitude      float64                `protobuf:"fixed64,1,opt,name=latitude,proto3" json:"latitude,omitempty"`
        Longitude     float64                `protobuf:"fixed64,2,opt,name=longitude,proto3" json:"longitude,omitempty"`
        Accuracy      float64                `protobuf:"fixed64,3,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
        Timestamp     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Address       string                 `protobuf:"bytes,5,opt,name=address,proto3" json:"address,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Location) Reset() <span class="cov0" title="0">{
        *x = Location{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Location) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Location) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Location) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Location.ProtoReflect.Descriptor instead.
func (*Location) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Location) GetLatitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Latitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetLongitude() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Longitude
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetAccuracy() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Accuracy
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Location) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Location) GetAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Address
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// User represents a platform user (rider or driver)
type User struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        Email         string                 `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
        Phone         string                 `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
        FirstName     string                 `protobuf:"bytes,4,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
        LastName      string                 `protobuf:"bytes,5,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
        Role          UserRole               `protobuf:"varint,6,opt,name=role,proto3,enum=user.UserRole" json:"role,omitempty"`
        Status        UserStatus             `protobuf:"varint,7,opt,name=status,proto3,enum=user.UserStatus" json:"status,omitempty"`
        CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
        UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
        Profile       *UserProfile           `protobuf:"bytes,10,opt,name=profile,proto3" json:"profile,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{1}
}</span>

func (x *User) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetPhone() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Phone
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetFirstName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FirstName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetLastName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetRole() UserRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return UserRole_UNKNOWN_ROLE</span>
}

func (x *User) GetStatus() UserStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return UserStatus_UNKNOWN_STATUS</span>
}

func (x *User) GetCreatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetUpdatedAt() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdatedAt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetProfile() *UserProfile <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Profile
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Extended user profile information
type UserProfile struct {
        state             protoimpl.MessageState `protogen:"open.v1"`
        AvatarUrl         string                 `protobuf:"bytes,1,opt,name=avatar_url,json=avatarUrl,proto3" json:"avatar_url,omitempty"`
        DateOfBirth       string                 `protobuf:"bytes,2,opt,name=date_of_birth,json=dateOfBirth,proto3" json:"date_of_birth,omitempty"`
        Gender            string                 `protobuf:"bytes,3,opt,name=gender,proto3" json:"gender,omitempty"`
        PreferredLanguage string                 `protobuf:"bytes,4,opt,name=preferred_language,json=preferredLanguage,proto3" json:"preferred_language,omitempty"`
        Rating            float64                `protobuf:"fixed64,5,opt,name=rating,proto3" json:"rating,omitempty"`
        TotalTrips        int32                  `protobuf:"varint,6,opt,name=total_trips,json=totalTrips,proto3" json:"total_trips,omitempty"`
        EmailVerified     bool                   `protobuf:"varint,7,opt,name=email_verified,json=emailVerified,proto3" json:"email_verified,omitempty"`
        PhoneVerified     bool                   `protobuf:"varint,8,opt,name=phone_verified,json=phoneVerified,proto3" json:"phone_verified,omitempty"`
        Preferences       *UserPreferences       `protobuf:"bytes,9,opt,name=preferences,proto3" json:"preferences,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *UserProfile) Reset() <span class="cov0" title="0">{
        *x = UserProfile{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserProfile) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserProfile) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserProfile) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserProfile.ProtoReflect.Descriptor instead.
func (*UserProfile) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{2}
}</span>

func (x *UserProfile) GetAvatarUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AvatarUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserProfile) GetDateOfBirth() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DateOfBirth
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserProfile) GetGender() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Gender
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserProfile) GetPreferredLanguage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PreferredLanguage
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserProfile) GetRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfile) GetTotalTrips() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalTrips
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *UserProfile) GetEmailVerified() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EmailVerified
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UserProfile) GetPhoneVerified() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PhoneVerified
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UserProfile) GetPreferences() *UserPreferences <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Preferences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// User preferences
type UserPreferences struct {
        state                 protoimpl.MessageState `protogen:"open.v1"`
        AllowNotifications    bool                   `protobuf:"varint,1,opt,name=allow_notifications,json=allowNotifications,proto3" json:"allow_notifications,omitempty"`
        ShareLocation         bool                   `protobuf:"varint,2,opt,name=share_location,json=shareLocation,proto3" json:"share_location,omitempty"`
        DefaultPaymentMethod  string                 `protobuf:"bytes,3,opt,name=default_payment_method,json=defaultPaymentMethod,proto3" json:"default_payment_method,omitempty"`
        QuietRides            bool                   `protobuf:"varint,4,opt,name=quiet_rides,json=quietRides,proto3" json:"quiet_rides,omitempty"`
        AccessibilityFeatures bool                   `protobuf:"varint,5,opt,name=accessibility_features,json=accessibilityFeatures,proto3" json:"accessibility_features,omitempty"`
        unknownFields         protoimpl.UnknownFields
        sizeCache             protoimpl.SizeCache
}

func (x *UserPreferences) Reset() <span class="cov0" title="0">{
        *x = UserPreferences{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UserPreferences) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserPreferences) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserPreferences) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserPreferences.ProtoReflect.Descriptor instead.
func (*UserPreferences) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{3}
}</span>

func (x *UserPreferences) GetAllowNotifications() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AllowNotifications
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UserPreferences) GetShareLocation() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShareLocation
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UserPreferences) GetDefaultPaymentMethod() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultPaymentMethod
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserPreferences) GetQuietRides() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.QuietRides
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UserPreferences) GetAccessibilityFeatures() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AccessibilityFeatures
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Requests and responses
type CreateUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Email         string                 `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
        Phone         string                 `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
        FirstName     string                 `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
        LastName      string                 `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
        Role          UserRole               `protobuf:"varint,5,opt,name=role,proto3,enum=user.UserRole" json:"role,omitempty"`
        Password      string                 `protobuf:"bytes,6,opt,name=password,proto3" json:"password,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateUserRequest) Reset() <span class="cov0" title="0">{
        *x = CreateUserRequest{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserRequest.ProtoReflect.Descriptor instead.
func (*CreateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CreateUserRequest) GetEmail() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Email
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetPhone() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Phone
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetFirstName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FirstName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetLastName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserRequest) GetRole() UserRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return UserRole_UNKNOWN_ROLE</span>
}

func (x *CreateUserRequest) GetPassword() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Password
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CreateUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        Errors        []string               `protobuf:"bytes,4,rep,name=errors,proto3" json:"errors,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateUserResponse) Reset() <span class="cov0" title="0">{
        *x = CreateUserResponse{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateUserResponse.ProtoReflect.Descriptor instead.
func (*CreateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{5}
}</span>

func (x *CreateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CreateUserResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *CreateUserResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateUserResponse) GetErrors() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Errors
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserRequest) Reset() <span class="cov0" title="0">{
        *x = GetUserRequest{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserRequest.ProtoReflect.Descriptor instead.
func (*GetUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetUserRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetUserResponse) Reset() <span class="cov0" title="0">{
        *x = GetUserResponse{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetUserResponse.ProtoReflect.Descriptor instead.
func (*GetUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetUserResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

type UpdateUserRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
        User          *User                  `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
        UpdateFields  []string               `protobuf:"bytes,3,rep,name=update_fields,json=updateFields,proto3" json:"update_fields,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateUserRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateUserRequest{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[8]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateUserRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[8]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserRequest.ProtoReflect.Descriptor instead.
func (*UpdateUserRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{8}
}</span>

func (x *UpdateUserRequest) GetId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateUserRequest) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateUserRequest) GetUpdateFields() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UpdateFields
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateUserResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        User          *User                  `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
        Success       bool                   `protobuf:"varint,2,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateUserResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateUserResponse{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[9]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateUserResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateUserResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateUserResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[9]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateUserResponse.ProtoReflect.Descriptor instead.
func (*UpdateUserResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{9}
}</span>

func (x *UpdateUserResponse) GetUser() *User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.User
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateUserResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateUserResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ListUsersRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Role          UserRole               `protobuf:"varint,1,opt,name=role,proto3,enum=user.UserRole" json:"role,omitempty"`
        Status        UserStatus             `protobuf:"varint,2,opt,name=status,proto3,enum=user.UserStatus" json:"status,omitempty"`
        Limit         int32                  `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
        Offset        int32                  `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListUsersRequest) Reset() <span class="cov0" title="0">{
        *x = ListUsersRequest{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[10]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListUsersRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListUsersRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListUsersRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[10]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListUsersRequest.ProtoReflect.Descriptor instead.
func (*ListUsersRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{10}
}</span>

func (x *ListUsersRequest) GetRole() UserRole <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Role
        }</span>
        <span class="cov0" title="0">return UserRole_UNKNOWN_ROLE</span>
}

func (x *ListUsersRequest) GetStatus() UserStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return UserStatus_UNKNOWN_STATUS</span>
}

func (x *ListUsersRequest) GetLimit() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Limit
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListUsersRequest) GetOffset() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Offset
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type ListUsersResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Users         []*User                `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
        TotalCount    int32                  `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
        HasMore       bool                   `protobuf:"varint,3,opt,name=has_more,json=hasMore,proto3" json:"has_more,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ListUsersResponse) Reset() <span class="cov0" title="0">{
        *x = ListUsersResponse{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[11]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ListUsersResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ListUsersResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ListUsersResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[11]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ListUsersResponse.ProtoReflect.Descriptor instead.
func (*ListUsersResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{11}
}</span>

func (x *ListUsersResponse) GetUsers() []*User <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Users
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ListUsersResponse) GetTotalCount() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalCount
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *ListUsersResponse) GetHasMore() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.HasMore
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Driver-specific messages
type Driver struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        UserId          string                 `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        LicenseNumber   string                 `protobuf:"bytes,2,opt,name=license_number,json=licenseNumber,proto3" json:"license_number,omitempty"`
        LicenseExpiry   *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=license_expiry,json=licenseExpiry,proto3" json:"license_expiry,omitempty"`
        Status          DriverStatus           `protobuf:"varint,4,opt,name=status,proto3,enum=user.DriverStatus" json:"status,omitempty"`
        CurrentLocation *Location              `protobuf:"bytes,5,opt,name=current_location,json=currentLocation,proto3" json:"current_location,omitempty"`
        Rating          float64                `protobuf:"fixed64,6,opt,name=rating,proto3" json:"rating,omitempty"`
        TotalTrips      int32                  `protobuf:"varint,7,opt,name=total_trips,json=totalTrips,proto3" json:"total_trips,omitempty"`
        VehicleId       string                 `protobuf:"bytes,8,opt,name=vehicle_id,json=vehicleId,proto3" json:"vehicle_id,omitempty"`
        IsAvailable     bool                   `protobuf:"varint,9,opt,name=is_available,json=isAvailable,proto3" json:"is_available,omitempty"`
        LastActive      *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=last_active,json=lastActive,proto3" json:"last_active,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *Driver) Reset() <span class="cov0" title="0">{
        *x = Driver{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[12]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Driver) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Driver) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Driver) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[12]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Driver.ProtoReflect.Descriptor instead.
func (*Driver) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{12}
}</span>

func (x *Driver) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetLicenseNumber() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LicenseNumber
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetLicenseExpiry() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LicenseExpiry
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Driver) GetStatus() DriverStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return DriverStatus_UNKNOWN_DRIVER_STATUS</span>
}

func (x *Driver) GetCurrentLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CurrentLocation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Driver) GetRating() float64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Rating
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Driver) GetTotalTrips() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalTrips
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Driver) GetVehicleId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VehicleId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Driver) GetIsAvailable() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsAvailable
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Driver) GetLastActive() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastActive
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type UpdateDriverLocationRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        Location      *Location              `protobuf:"bytes,2,opt,name=location,proto3" json:"location,omitempty"`
        Status        DriverStatus           `protobuf:"varint,3,opt,name=status,proto3,enum=user.DriverStatus" json:"status,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateDriverLocationRequest) Reset() <span class="cov0" title="0">{
        *x = UpdateDriverLocationRequest{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[13]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateDriverLocationRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateDriverLocationRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateDriverLocationRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[13]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateDriverLocationRequest.ProtoReflect.Descriptor instead.
func (*UpdateDriverLocationRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{13}
}</span>

func (x *UpdateDriverLocationRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UpdateDriverLocationRequest) GetLocation() *Location <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Location
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UpdateDriverLocationRequest) GetStatus() DriverStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return DriverStatus_UNKNOWN_DRIVER_STATUS</span>
}

type UpdateDriverLocationResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *UpdateDriverLocationResponse) Reset() <span class="cov0" title="0">{
        *x = UpdateDriverLocationResponse{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[14]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *UpdateDriverLocationResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UpdateDriverLocationResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UpdateDriverLocationResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[14]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UpdateDriverLocationResponse.ProtoReflect.Descriptor instead.
func (*UpdateDriverLocationResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{14}
}</span>

func (x *UpdateDriverLocationResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *UpdateDriverLocationResponse) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetDriverRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        DriverId      string                 `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetDriverRequest) Reset() <span class="cov0" title="0">{
        *x = GetDriverRequest{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[15]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetDriverRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetDriverRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetDriverRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[15]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetDriverRequest.ProtoReflect.Descriptor instead.
func (*GetDriverRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{15}
}</span>

func (x *GetDriverRequest) GetDriverId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DriverId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetDriverResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Driver        *Driver                `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetDriverResponse) Reset() <span class="cov0" title="0">{
        *x = GetDriverResponse{}
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[16]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetDriverResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetDriverResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetDriverResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_shared_proto_user_user_proto_msgTypes[16]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetDriverResponse.ProtoReflect.Descriptor instead.
func (*GetDriverResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_shared_proto_user_user_proto_rawDescGZIP(), []int{16}
}</span>

func (x *GetDriverResponse) GetDriver() *Driver <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Driver
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetDriverResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_shared_proto_user_user_proto protoreflect.FileDescriptor

const file_shared_proto_user_user_proto_rawDesc = "" +
        "\n" +
        "\x1cshared/proto/user/user.proto\x12\x04user\x1a\x1fgoogle/protobuf/timestamp.proto\"\xb4\x01\n" +
        "\bLocation\x12\x1a\n" +
        "\blatitude\x18\x01 \x01(\x01R\blatitude\x12\x1c\n" +
        "\tlongitude\x18\x02 \x01(\x01R\tlongitude\x12\x1a\n" +
        "\baccuracy\x18\x03 \x01(\x01R\baccuracy\x128\n" +
        "\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12\x18\n" +
        "\aaddress\x18\x05 \x01(\tR\aaddress\"\xef\x02\n" +
        "\x04User\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
        "\x05email\x18\x02 \x01(\tR\x05email\x12\x14\n" +
        "\x05phone\x18\x03 \x01(\tR\x05phone\x12\x1d\n" +
        "\n" +
        "first_name\x18\x04 \x01(\tR\tfirstName\x12\x1b\n" +
        "\tlast_name\x18\x05 \x01(\tR\blastName\x12\"\n" +
        "\x04role\x18\x06 \x01(\x0e2\x0e.user.UserRoleR\x04role\x12(\n" +
        "\x06status\x18\a \x01(\x0e2\x10.user.UserStatusR\x06status\x129\n" +
        "\n" +
        "created_at\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
        "\n" +
        "updated_at\x18\t \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12+\n" +
        "\aprofile\x18\n" +
        " \x01(\v2\x11.user.UserProfileR\aprofile\"\xd7\x02\n" +
        "\vUserProfile\x12\x1d\n" +
        "\n" +
        "avatar_url\x18\x01 \x01(\tR\tavatarUrl\x12\"\n" +
        "\rdate_of_birth\x18\x02 \x01(\tR\vdateOfBirth\x12\x16\n" +
        "\x06gender\x18\x03 \x01(\tR\x06gender\x12-\n" +
        "\x12preferred_language\x18\x04 \x01(\tR\x11preferredLanguage\x12\x16\n" +
        "\x06rating\x18\x05 \x01(\x01R\x06rating\x12\x1f\n" +
        "\vtotal_trips\x18\x06 \x01(\x05R\n" +
        "totalTrips\x12%\n" +
        "\x0eemail_verified\x18\a \x01(\bR\remailVerified\x12%\n" +
        "\x0ephone_verified\x18\b \x01(\bR\rphoneVerified\x127\n" +
        "\vpreferences\x18\t \x01(\v2\x15.user.UserPreferencesR\vpreferences\"\xf7\x01\n" +
        "\x0fUserPreferences\x12/\n" +
        "\x13allow_notifications\x18\x01 \x01(\bR\x12allowNotifications\x12%\n" +
        "\x0eshare_location\x18\x02 \x01(\bR\rshareLocation\x124\n" +
        "\x16default_payment_method\x18\x03 \x01(\tR\x14defaultPaymentMethod\x12\x1f\n" +
        "\vquiet_rides\x18\x04 \x01(\bR\n" +
        "quietRides\x125\n" +
        "\x16accessibility_features\x18\x05 \x01(\bR\x15accessibilityFeatures\"\xbb\x01\n" +
        "\x11CreateUserRequest\x12\x14\n" +
        "\x05email\x18\x01 \x01(\tR\x05email\x12\x14\n" +
        "\x05phone\x18\x02 \x01(\tR\x05phone\x12\x1d\n" +
        "\n" +
        "first_name\x18\x03 \x01(\tR\tfirstName\x12\x1b\n" +
        "\tlast_name\x18\x04 \x01(\tR\blastName\x12\"\n" +
        "\x04role\x18\x05 \x01(\x0e2\x0e.user.UserRoleR\x04role\x12\x1a\n" +
        "\bpassword\x18\x06 \x01(\tR\bpassword\"\x80\x01\n" +
        "\x12CreateUserResponse\x12\x1e\n" +
        "\x04user\x18\x01 \x01(\v2\n" +
        ".user.UserR\x04user\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\x12\x16\n" +
        "\x06errors\x18\x04 \x03(\tR\x06errors\" \n" +
        "\x0eGetUserRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\"G\n" +
        "\x0fGetUserResponse\x12\x1e\n" +
        "\x04user\x18\x01 \x01(\v2\n" +
        ".user.UserR\x04user\x12\x14\n" +
        "\x05found\x18\x02 \x01(\bR\x05found\"h\n" +
        "\x11UpdateUserRequest\x12\x0e\n" +
        "\x02id\x18\x01 \x01(\tR\x02id\x12\x1e\n" +
        "\x04user\x18\x02 \x01(\v2\n" +
        ".user.UserR\x04user\x12#\n" +
        "\rupdate_fields\x18\x03 \x03(\tR\fupdateFields\"h\n" +
        "\x12UpdateUserResponse\x12\x1e\n" +
        "\x04user\x18\x01 \x01(\v2\n" +
        ".user.UserR\x04user\x12\x18\n" +
        "\asuccess\x18\x02 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x03 \x01(\tR\amessage\"\x8e\x01\n" +
        "\x10ListUsersRequest\x12\"\n" +
        "\x04role\x18\x01 \x01(\x0e2\x0e.user.UserRoleR\x04role\x12(\n" +
        "\x06status\x18\x02 \x01(\x0e2\x10.user.UserStatusR\x06status\x12\x14\n" +
        "\x05limit\x18\x03 \x01(\x05R\x05limit\x12\x16\n" +
        "\x06offset\x18\x04 \x01(\x05R\x06offset\"q\n" +
        "\x11ListUsersResponse\x12 \n" +
        "\x05users\x18\x01 \x03(\v2\n" +
        ".user.UserR\x05users\x12\x1f\n" +
        "\vtotal_count\x18\x02 \x01(\x05R\n" +
        "totalCount\x12\x19\n" +
        "\bhas_more\x18\x03 \x01(\bR\ahasMore\"\xaa\x03\n" +
        "\x06Driver\x12\x17\n" +
        "\auser_id\x18\x01 \x01(\tR\x06userId\x12%\n" +
        "\x0elicense_number\x18\x02 \x01(\tR\rlicenseNumber\x12A\n" +
        "\x0elicense_expiry\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\rlicenseExpiry\x12*\n" +
        "\x06status\x18\x04 \x01(\x0e2\x12.user.DriverStatusR\x06status\x129\n" +
        "\x10current_location\x18\x05 \x01(\v2\x0e.user.LocationR\x0fcurrentLocation\x12\x16\n" +
        "\x06rating\x18\x06 \x01(\x01R\x06rating\x12\x1f\n" +
        "\vtotal_trips\x18\a \x01(\x05R\n" +
        "totalTrips\x12\x1d\n" +
        "\n" +
        "vehicle_id\x18\b \x01(\tR\tvehicleId\x12!\n" +
        "\fis_available\x18\t \x01(\bR\visAvailable\x12;\n" +
        "\vlast_active\x18\n" +
        " \x01(\v2\x1a.google.protobuf.TimestampR\n" +
        "lastActive\"\x92\x01\n" +
        "\x1bUpdateDriverLocationRequest\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\x12*\n" +
        "\blocation\x18\x02 \x01(\v2\x0e.user.LocationR\blocation\x12*\n" +
        "\x06status\x18\x03 \x01(\x0e2\x12.user.DriverStatusR\x06status\"R\n" +
        "\x1cUpdateDriverLocationResponse\x12\x18\n" +
        "\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
        "\amessage\x18\x02 \x01(\tR\amessage\"/\n" +
        "\x10GetDriverRequest\x12\x1b\n" +
        "\tdriver_id\x18\x01 \x01(\tR\bdriverId\"O\n" +
        "\x11GetDriverResponse\x12$\n" +
        "\x06driver\x18\x01 \x01(\v2\f.user.DriverR\x06driver\x12\x14\n" +
        "\x05found\x18\x02 \x01(\bR\x05found*&gt;\n" +
        "\bUserRole\x12\x10\n" +
        "\fUNKNOWN_ROLE\x10\x00\x12\t\n" +
        "\x05RIDER\x10\x01\x12\n" +
        "\n" +
        "\x06DRIVER\x10\x02\x12\t\n" +
        "\x05ADMIN\x10\x03*U\n" +
        "\n" +
        "UserStatus\x12\x12\n" +
        "\x0eUNKNOWN_STATUS\x10\x00\x12\n" +
        "\n" +
        "\x06ACTIVE\x10\x01\x12\f\n" +
        "\bINACTIVE\x10\x02\x12\r\n" +
        "\tSUSPENDED\x10\x03\x12\n" +
        "\n" +
        "\x06BANNED\x10\x04*Z\n" +
        "\fDriverStatus\x12\x19\n" +
        "\x15UNKNOWN_DRIVER_STATUS\x10\x00\x12\v\n" +
        "\aOFFLINE\x10\x01\x12\n" +
        "\n" +
        "\x06ONLINE\x10\x02\x12\v\n" +
        "\aON_TRIP\x10\x03\x12\t\n" +
        "\x05BREAK\x10\x042\xa2\x03\n" +
        "\vUserService\x12?\n" +
        "\n" +
        "CreateUser\x12\x17.user.CreateUserRequest\x1a\x18.user.CreateUserResponse\x126\n" +
        "\aGetUser\x12\x14.user.GetUserRequest\x1a\x15.user.GetUserResponse\x12?\n" +
        "\n" +
        "UpdateUser\x12\x17.user.UpdateUserRequest\x1a\x18.user.UpdateUserResponse\x12&lt;\n" +
        "\tListUsers\x12\x16.user.ListUsersRequest\x1a\x17.user.ListUsersResponse\x12]\n" +
        "\x14UpdateDriverLocation\x12!.user.UpdateDriverLocationRequest\x1a\".user.UpdateDriverLocationResponse\x12&lt;\n" +
        "\tGetDriver\x12\x16.user.GetDriverRequest\x1a\x17.user.GetDriverResponseB1Z/github.com/rideshare-platform/shared/proto/userb\x06proto3"

var (
        file_shared_proto_user_user_proto_rawDescOnce sync.Once
        file_shared_proto_user_user_proto_rawDescData []byte
)

func file_shared_proto_user_user_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_shared_proto_user_user_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_shared_proto_user_user_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_shared_proto_user_user_proto_rawDesc), len(file_shared_proto_user_user_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_shared_proto_user_user_proto_rawDescData</span>
}

var file_shared_proto_user_user_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_shared_proto_user_user_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_shared_proto_user_user_proto_goTypes = []any{
        (UserRole)(0),                        // 0: user.UserRole
        (UserStatus)(0),                      // 1: user.UserStatus
        (DriverStatus)(0),                    // 2: user.DriverStatus
        (*Location)(nil),                     // 3: user.Location
        (*User)(nil),                         // 4: user.User
        (*UserProfile)(nil),                  // 5: user.UserProfile
        (*UserPreferences)(nil),              // 6: user.UserPreferences
        (*CreateUserRequest)(nil),            // 7: user.CreateUserRequest
        (*CreateUserResponse)(nil),           // 8: user.CreateUserResponse
        (*GetUserRequest)(nil),               // 9: user.GetUserRequest
        (*GetUserResponse)(nil),              // 10: user.GetUserResponse
        (*UpdateUserRequest)(nil),            // 11: user.UpdateUserRequest
        (*UpdateUserResponse)(nil),           // 12: user.UpdateUserResponse
        (*ListUsersRequest)(nil),             // 13: user.ListUsersRequest
        (*ListUsersResponse)(nil),            // 14: user.ListUsersResponse
        (*Driver)(nil),                       // 15: user.Driver
        (*UpdateDriverLocationRequest)(nil),  // 16: user.UpdateDriverLocationRequest
        (*UpdateDriverLocationResponse)(nil), // 17: user.UpdateDriverLocationResponse
        (*GetDriverRequest)(nil),             // 18: user.GetDriverRequest
        (*GetDriverResponse)(nil),            // 19: user.GetDriverResponse
        (*timestamppb.Timestamp)(nil),        // 20: google.protobuf.Timestamp
}
var file_shared_proto_user_user_proto_depIdxs = []int32{
        20, // 0: user.Location.timestamp:type_name -&gt; google.protobuf.Timestamp
        0,  // 1: user.User.role:type_name -&gt; user.UserRole
        1,  // 2: user.User.status:type_name -&gt; user.UserStatus
        20, // 3: user.User.created_at:type_name -&gt; google.protobuf.Timestamp
        20, // 4: user.User.updated_at:type_name -&gt; google.protobuf.Timestamp
        5,  // 5: user.User.profile:type_name -&gt; user.UserProfile
        6,  // 6: user.UserProfile.preferences:type_name -&gt; user.UserPreferences
        0,  // 7: user.CreateUserRequest.role:type_name -&gt; user.UserRole
        4,  // 8: user.CreateUserResponse.user:type_name -&gt; user.User
        4,  // 9: user.GetUserResponse.user:type_name -&gt; user.User
        4,  // 10: user.UpdateUserRequest.user:type_name -&gt; user.User
        4,  // 11: user.UpdateUserResponse.user:type_name -&gt; user.User
        0,  // 12: user.ListUsersRequest.role:type_name -&gt; user.UserRole
        1,  // 13: user.ListUsersRequest.status:type_name -&gt; user.UserStatus
        4,  // 14: user.ListUsersResponse.users:type_name -&gt; user.User
        20, // 15: user.Driver.license_expiry:type_name -&gt; google.protobuf.Timestamp
        2,  // 16: user.Driver.status:type_name -&gt; user.DriverStatus
        3,  // 17: user.Driver.current_location:type_name -&gt; user.Location
        20, // 18: user.Driver.last_active:type_name -&gt; google.protobuf.Timestamp
        3,  // 19: user.UpdateDriverLocationRequest.location:type_name -&gt; user.Location
        2,  // 20: user.UpdateDriverLocationRequest.status:type_name -&gt; user.DriverStatus
        15, // 21: user.GetDriverResponse.driver:type_name -&gt; user.Driver
        7,  // 22: user.UserService.CreateUser:input_type -&gt; user.CreateUserRequest
        9,  // 23: user.UserService.GetUser:input_type -&gt; user.GetUserRequest
        11, // 24: user.UserService.UpdateUser:input_type -&gt; user.UpdateUserRequest
        13, // 25: user.UserService.ListUsers:input_type -&gt; user.ListUsersRequest
        16, // 26: user.UserService.UpdateDriverLocation:input_type -&gt; user.UpdateDriverLocationRequest
        18, // 27: user.UserService.GetDriver:input_type -&gt; user.GetDriverRequest
        8,  // 28: user.UserService.CreateUser:output_type -&gt; user.CreateUserResponse
        10, // 29: user.UserService.GetUser:output_type -&gt; user.GetUserResponse
        12, // 30: user.UserService.UpdateUser:output_type -&gt; user.UpdateUserResponse
        14, // 31: user.UserService.ListUsers:output_type -&gt; user.ListUsersResponse
        17, // 32: user.UserService.UpdateDriverLocation:output_type -&gt; user.UpdateDriverLocationResponse
        19, // 33: user.UserService.GetDriver:output_type -&gt; user.GetDriverResponse
        28, // [28:34] is the sub-list for method output_type
        22, // [22:28] is the sub-list for method input_type
        22, // [22:22] is the sub-list for extension type_name
        22, // [22:22] is the sub-list for extension extendee
        0,  // [0:22] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_shared_proto_user_user_proto_init() }</span>
func file_shared_proto_user_user_proto_init() <span class="cov0" title="0">{
        if File_shared_proto_user_user_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_shared_proto_user_user_proto_rawDesc), len(file_shared_proto_user_user_proto_rawDesc)),
                        NumEnums:      3,
                        NumMessages:   17,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_shared_proto_user_user_proto_goTypes,
                DependencyIndexes: file_shared_proto_user_user_proto_depIdxs,
                EnumInfos:         file_shared_proto_user_user_proto_enumTypes,
                MessageInfos:      file_shared_proto_user_user_proto_msgTypes,
        }.Build()
        File_shared_proto_user_user_proto = out.File
        file_shared_proto_user_user_proto_goTypes = nil
        file_shared_proto_user_user_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/user/user.proto

package user

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        UserService_CreateUser_FullMethodName           = "/user.UserService/CreateUser"
        UserService_GetUser_FullMethodName              = "/user.UserService/GetUser"
        UserService_UpdateUser_FullMethodName           = "/user.UserService/UpdateUser"
        UserService_ListUsers_FullMethodName            = "/user.UserService/ListUsers"
        UserService_UpdateDriverLocation_FullMethodName = "/user.UserService/UpdateDriverLocation"
        UserService_GetDriver_FullMethodName            = "/user.UserService/GetDriver"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// UserService defines the gRPC service for user management
type UserServiceClient interface {
        CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
        GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
        UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error)
        ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
        // Driver-specific methods
        UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error)
        GetDriver(ctx context.Context, in *GetDriverRequest, opts ...grpc.CallOption) (*GetDriverResponse, error)
}

type userServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient <span class="cov0" title="0">{
        return &amp;userServiceClient{cc}
}</span>

func (c *userServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateUserResponse)
        err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetUserResponse)
        err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateUserResponse)
        err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ListUsersResponse)
        err := c.cc.Invoke(ctx, UserService_ListUsers_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(UpdateDriverLocationResponse)
        err := c.cc.Invoke(ctx, UserService_UpdateDriverLocation_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *userServiceClient) GetDriver(ctx context.Context, in *GetDriverRequest, opts ...grpc.CallOption) (*GetDriverResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetDriverResponse)
        err := c.cc.Invoke(ctx, UserService_GetDriver_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// UserService defines the gRPC service for user management
type UserServiceServer interface {
        CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
        GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
        UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error)
        ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
        // Driver-specific methods
        UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error)
        GetDriver(context.Context, *GetDriverRequest) (*GetDriverResponse, error)
        mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}</span>
func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UpdateUserRequest) (*UpdateUserResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}</span>
func (UnimplementedUserServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}</span>
func (UnimplementedUserServiceServer) UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method UpdateDriverLocation not implemented")
}</span>
func (UnimplementedUserServiceServer) GetDriver(context.Context, *GetDriverRequest) (*GetDriverResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetDriver not implemented")
}</span>
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {<span class="cov0" title="0">}</span>

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
        mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedUserServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;UserService_ServiceDesc, srv)</span>
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).CreateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_CreateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).CreateUser(ctx, req.(*CreateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateUserRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdateUser_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateUser(ctx, req.(*UpdateUserRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ListUsersRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).ListUsers(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_ListUsers_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_UpdateDriverLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(UpdateDriverLocationRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateDriverLocation(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_UpdateDriverLocation_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).UpdateDriverLocation(ctx, req.(*UpdateDriverLocationRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _UserService_GetDriver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetDriverRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetDriver(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: UserService_GetDriver_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(UserServiceServer).GetDriver(ctx, req.(*GetDriverRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "user.UserService",
        HandlerType: (*UserServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateUser",
                        Handler:    _UserService_CreateUser_Handler,
                },
                {
                        MethodName: "GetUser",
                        Handler:    _UserService_GetUser_Handler,
                },
                {
                        MethodName: "UpdateUser",
                        Handler:    _UserService_UpdateUser_Handler,
                },
                {
                        MethodName: "ListUsers",
                        Handler:    _UserService_ListUsers_Handler,
                },
                {
                        MethodName: "UpdateDriverLocation",
                        Handler:    _UserService_UpdateDriverLocation_Handler,
                },
                {
                        MethodName: "GetDriver",
                        Handler:    _UserService_GetDriver_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "shared/proto/user/user.proto",
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package utils

import (
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/google/uuid"
)

// GenerateID generates a new UUID string
func GenerateID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>

// GenerateShortID generates a shorter ID (8 characters)
func GenerateShortID() string <span class="cov0" title="0">{
        bytes := make([]byte, 4)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>

// GenerateSessionID generates a session ID
func GenerateSessionID() string <span class="cov0" title="0">{
        return GenerateID()
}</span>

// GenerateJTI generates a JWT ID
func GenerateJTI() string <span class="cov0" title="0">{
        return GenerateShortID()
}</span>

// GenerateCorrelationID generates a correlation ID for request tracing
func GenerateCorrelationID() string <span class="cov0" title="0">{
        return GenerateID()
}</span>

// GenerateOrderID generates an order ID with timestamp prefix
func GenerateOrderID() string <span class="cov0" title="0">{
        timestamp := time.Now().Unix()
        shortID := GenerateShortID()
        return fmt.Sprintf("%d-%s", timestamp, shortID)
}</span>

// GenerateTransactionID generates a transaction ID
func GenerateTransactionID() string <span class="cov0" title="0">{
        return GenerateOrderID()
}</span>

// IsValidUUID checks if a string is a valid UUID
func IsValidUUID(id string) bool <span class="cov0" title="0">{
        _, err := uuid.Parse(id)
        return err == nil
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

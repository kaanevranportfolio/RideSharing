// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: shared/proto/geo/geo.proto

package geopb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	GeospatialService_CalculateDistance_FullMethodName          = "/geo.GeospatialService/CalculateDistance"
	GeospatialService_CalculateETA_FullMethodName               = "/geo.GeospatialService/CalculateETA"
	GeospatialService_FindNearbyDrivers_FullMethodName          = "/geo.GeospatialService/FindNearbyDrivers"
	GeospatialService_UpdateDriverLocation_FullMethodName       = "/geo.GeospatialService/UpdateDriverLocation"
	GeospatialService_GenerateGeohash_FullMethodName            = "/geo.GeospatialService/GenerateGeohash"
	GeospatialService_OptimizeRoute_FullMethodName              = "/geo.GeospatialService/OptimizeRoute"
	GeospatialService_SubscribeToDriverLocations_FullMethodName = "/geo.GeospatialService/SubscribeToDriverLocations"
	GeospatialService_StartLocationTracking_FullMethodName      = "/geo.GeospatialService/StartLocationTracking"
)

// GeospatialServiceClient is the client API for GeospatialService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Geospatial service definition
type GeospatialServiceClient interface {
	// Calculate distance between two points
	CalculateDistance(ctx context.Context, in *DistanceRequest, opts ...grpc.CallOption) (*DistanceResponse, error)
	// Calculate ETA and route
	CalculateETA(ctx context.Context, in *ETARequest, opts ...grpc.CallOption) (*ETAResponse, error)
	// Find nearby drivers
	FindNearbyDrivers(ctx context.Context, in *NearbyDriversRequest, opts ...grpc.CallOption) (*NearbyDriversResponse, error)
	// Update driver location
	UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error)
	// Generate geohash for location
	GenerateGeohash(ctx context.Context, in *GeohashRequest, opts ...grpc.CallOption) (*GeohashResponse, error)
	// Optimize route with multiple waypoints
	OptimizeRoute(ctx context.Context, in *RouteOptimizationRequest, opts ...grpc.CallOption) (*RouteOptimizationResponse, error)
	// Real-time driver location streaming
	SubscribeToDriverLocations(ctx context.Context, in *SubscribeToDriverLocationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DriverLocationEvent], error)
	// Start location tracking session for a driver
	StartLocationTracking(ctx context.Context, in *StartLocationTrackingRequest, opts ...grpc.CallOption) (*StartLocationTrackingResponse, error)
}

type geospatialServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGeospatialServiceClient(cc grpc.ClientConnInterface) GeospatialServiceClient {
	return &geospatialServiceClient{cc}
}

func (c *geospatialServiceClient) CalculateDistance(ctx context.Context, in *DistanceRequest, opts ...grpc.CallOption) (*DistanceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DistanceResponse)
	err := c.cc.Invoke(ctx, GeospatialService_CalculateDistance_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geospatialServiceClient) CalculateETA(ctx context.Context, in *ETARequest, opts ...grpc.CallOption) (*ETAResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ETAResponse)
	err := c.cc.Invoke(ctx, GeospatialService_CalculateETA_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geospatialServiceClient) FindNearbyDrivers(ctx context.Context, in *NearbyDriversRequest, opts ...grpc.CallOption) (*NearbyDriversResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NearbyDriversResponse)
	err := c.cc.Invoke(ctx, GeospatialService_FindNearbyDrivers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geospatialServiceClient) UpdateDriverLocation(ctx context.Context, in *UpdateDriverLocationRequest, opts ...grpc.CallOption) (*UpdateDriverLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateDriverLocationResponse)
	err := c.cc.Invoke(ctx, GeospatialService_UpdateDriverLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geospatialServiceClient) GenerateGeohash(ctx context.Context, in *GeohashRequest, opts ...grpc.CallOption) (*GeohashResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeohashResponse)
	err := c.cc.Invoke(ctx, GeospatialService_GenerateGeohash_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geospatialServiceClient) OptimizeRoute(ctx context.Context, in *RouteOptimizationRequest, opts ...grpc.CallOption) (*RouteOptimizationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RouteOptimizationResponse)
	err := c.cc.Invoke(ctx, GeospatialService_OptimizeRoute_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *geospatialServiceClient) SubscribeToDriverLocations(ctx context.Context, in *SubscribeToDriverLocationRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DriverLocationEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GeospatialService_ServiceDesc.Streams[0], GeospatialService_SubscribeToDriverLocations_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToDriverLocationRequest, DriverLocationEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GeospatialService_SubscribeToDriverLocationsClient = grpc.ServerStreamingClient[DriverLocationEvent]

func (c *geospatialServiceClient) StartLocationTracking(ctx context.Context, in *StartLocationTrackingRequest, opts ...grpc.CallOption) (*StartLocationTrackingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartLocationTrackingResponse)
	err := c.cc.Invoke(ctx, GeospatialService_StartLocationTracking_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GeospatialServiceServer is the server API for GeospatialService service.
// All implementations must embed UnimplementedGeospatialServiceServer
// for forward compatibility.
//
// Geospatial service definition
type GeospatialServiceServer interface {
	// Calculate distance between two points
	CalculateDistance(context.Context, *DistanceRequest) (*DistanceResponse, error)
	// Calculate ETA and route
	CalculateETA(context.Context, *ETARequest) (*ETAResponse, error)
	// Find nearby drivers
	FindNearbyDrivers(context.Context, *NearbyDriversRequest) (*NearbyDriversResponse, error)
	// Update driver location
	UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error)
	// Generate geohash for location
	GenerateGeohash(context.Context, *GeohashRequest) (*GeohashResponse, error)
	// Optimize route with multiple waypoints
	OptimizeRoute(context.Context, *RouteOptimizationRequest) (*RouteOptimizationResponse, error)
	// Real-time driver location streaming
	SubscribeToDriverLocations(*SubscribeToDriverLocationRequest, grpc.ServerStreamingServer[DriverLocationEvent]) error
	// Start location tracking session for a driver
	StartLocationTracking(context.Context, *StartLocationTrackingRequest) (*StartLocationTrackingResponse, error)
	mustEmbedUnimplementedGeospatialServiceServer()
}

// UnimplementedGeospatialServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGeospatialServiceServer struct{}

func (UnimplementedGeospatialServiceServer) CalculateDistance(context.Context, *DistanceRequest) (*DistanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateDistance not implemented")
}
func (UnimplementedGeospatialServiceServer) CalculateETA(context.Context, *ETARequest) (*ETAResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateETA not implemented")
}
func (UnimplementedGeospatialServiceServer) FindNearbyDrivers(context.Context, *NearbyDriversRequest) (*NearbyDriversResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindNearbyDrivers not implemented")
}
func (UnimplementedGeospatialServiceServer) UpdateDriverLocation(context.Context, *UpdateDriverLocationRequest) (*UpdateDriverLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDriverLocation not implemented")
}
func (UnimplementedGeospatialServiceServer) GenerateGeohash(context.Context, *GeohashRequest) (*GeohashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateGeohash not implemented")
}
func (UnimplementedGeospatialServiceServer) OptimizeRoute(context.Context, *RouteOptimizationRequest) (*RouteOptimizationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OptimizeRoute not implemented")
}
func (UnimplementedGeospatialServiceServer) SubscribeToDriverLocations(*SubscribeToDriverLocationRequest, grpc.ServerStreamingServer[DriverLocationEvent]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToDriverLocations not implemented")
}
func (UnimplementedGeospatialServiceServer) StartLocationTracking(context.Context, *StartLocationTrackingRequest) (*StartLocationTrackingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartLocationTracking not implemented")
}
func (UnimplementedGeospatialServiceServer) mustEmbedUnimplementedGeospatialServiceServer() {}
func (UnimplementedGeospatialServiceServer) testEmbeddedByValue()                           {}

// UnsafeGeospatialServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GeospatialServiceServer will
// result in compilation errors.
type UnsafeGeospatialServiceServer interface {
	mustEmbedUnimplementedGeospatialServiceServer()
}

func RegisterGeospatialServiceServer(s grpc.ServiceRegistrar, srv GeospatialServiceServer) {
	// If the following call pancis, it indicates UnimplementedGeospatialServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GeospatialService_ServiceDesc, srv)
}

func _GeospatialService_CalculateDistance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DistanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).CalculateDistance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_CalculateDistance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).CalculateDistance(ctx, req.(*DistanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeospatialService_CalculateETA_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ETARequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).CalculateETA(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_CalculateETA_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).CalculateETA(ctx, req.(*ETARequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeospatialService_FindNearbyDrivers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NearbyDriversRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).FindNearbyDrivers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_FindNearbyDrivers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).FindNearbyDrivers(ctx, req.(*NearbyDriversRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeospatialService_UpdateDriverLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDriverLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).UpdateDriverLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_UpdateDriverLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).UpdateDriverLocation(ctx, req.(*UpdateDriverLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeospatialService_GenerateGeohash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeohashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).GenerateGeohash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_GenerateGeohash_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).GenerateGeohash(ctx, req.(*GeohashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeospatialService_OptimizeRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteOptimizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).OptimizeRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_OptimizeRoute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).OptimizeRoute(ctx, req.(*RouteOptimizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GeospatialService_SubscribeToDriverLocations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToDriverLocationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GeospatialServiceServer).SubscribeToDriverLocations(m, &grpc.GenericServerStream[SubscribeToDriverLocationRequest, DriverLocationEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GeospatialService_SubscribeToDriverLocationsServer = grpc.ServerStreamingServer[DriverLocationEvent]

func _GeospatialService_StartLocationTracking_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartLocationTrackingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GeospatialServiceServer).StartLocationTracking(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GeospatialService_StartLocationTracking_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GeospatialServiceServer).StartLocationTracking(ctx, req.(*StartLocationTrackingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GeospatialService_ServiceDesc is the grpc.ServiceDesc for GeospatialService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GeospatialService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "geo.GeospatialService",
	HandlerType: (*GeospatialServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CalculateDistance",
			Handler:    _GeospatialService_CalculateDistance_Handler,
		},
		{
			MethodName: "CalculateETA",
			Handler:    _GeospatialService_CalculateETA_Handler,
		},
		{
			MethodName: "FindNearbyDrivers",
			Handler:    _GeospatialService_FindNearbyDrivers_Handler,
		},
		{
			MethodName: "UpdateDriverLocation",
			Handler:    _GeospatialService_UpdateDriverLocation_Handler,
		},
		{
			MethodName: "GenerateGeohash",
			Handler:    _GeospatialService_GenerateGeohash_Handler,
		},
		{
			MethodName: "OptimizeRoute",
			Handler:    _GeospatialService_OptimizeRoute_Handler,
		},
		{
			MethodName: "StartLocationTracking",
			Handler:    _GeospatialService_StartLocationTracking_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToDriverLocations",
			Handler:       _GeospatialService_SubscribeToDriverLocations_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "shared/proto/geo/geo.proto",
}

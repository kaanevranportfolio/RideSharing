package handler

import (
	"context"
	"fmt"
	"time"

	"github.com/rideshare-platform/services/geo-service/internal/service"
	"github.com/rideshare-platform/shared/logger"
	"github.com/rideshare-platform/shared/models"
	pb "github.com/rideshare-platform/shared/proto/geo"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// GeoHandler implements the GeospatialService gRPC interface
type GeoHandler struct {
	pb.UnimplementedGeospatialServiceServer
	geoService *service.GeospatialService
	logger     *logger.Logger
}

// NewGeoHandler creates a new geo handler
func NewGeoHandler(geoService *service.GeospatialService, log *logger.Logger) *GeoHandler {
	return &GeoHandler{
		geoService: geoService,
		logger:     log,
	}
}

// CalculateDistance calculates the distance between two points
func (h *GeoHandler) CalculateDistance(ctx context.Context, req *pb.DistanceRequest) (*pb.DistanceResponse, error) {
	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"origin_lat":      req.Origin.Latitude,
		"origin_lng":      req.Origin.Longitude,
		"destination_lat": req.Destination.Latitude,
		"destination_lng": req.Destination.Longitude,
		"method":          req.CalculationMethod,
	}).Debug("Distance calculation request received")

	// Convert protobuf locations to domain models
	origin := models.Location{
		Latitude:  req.Origin.Latitude,
		Longitude: req.Origin.Longitude,
		Timestamp: req.Origin.Timestamp.AsTime(),
	}

	destination := models.Location{
		Latitude:  req.Destination.Latitude,
		Longitude: req.Destination.Longitude,
		Timestamp: req.Destination.Timestamp.AsTime(),
	}

	// Call service
	result, err := h.geoService.CalculateDistance(ctx, origin, destination, req.CalculationMethod)
	if err != nil {
		h.logger.WithContext(ctx).WithError(err).Error("Failed to calculate distance")
		return nil, fmt.Errorf("failed to calculate distance: %w", err)
	}

	// Convert to protobuf response
	response := &pb.DistanceResponse{
		DistanceMeters:    result.DistanceMeters,
		DistanceKm:        result.DistanceKm,
		BearingDegrees:    result.BearingDegrees,
		CalculationMethod: result.CalculationMethod,
	}

	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"distance_km": result.DistanceKm,
		"bearing":     result.BearingDegrees,
		"method":      result.CalculationMethod,
	}).Debug("Distance calculation completed")

	return response, nil
}

// CalculateETA calculates estimated time of arrival
func (h *GeoHandler) CalculateETA(ctx context.Context, req *pb.ETARequest) (*pb.ETAResponse, error) {
	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"origin_lat":      req.Origin.Latitude,
		"origin_lng":      req.Origin.Longitude,
		"destination_lat": req.Destination.Latitude,
		"destination_lng": req.Destination.Longitude,
		"vehicle_type":    req.VehicleType,
		"include_traffic": req.IncludeTraffic,
	}).Debug("ETA calculation request received")

	// Convert protobuf locations to domain models
	origin := models.Location{
		Latitude:  req.Origin.Latitude,
		Longitude: req.Origin.Longitude,
		Timestamp: req.Origin.Timestamp.AsTime(),
	}

	destination := models.Location{
		Latitude:  req.Destination.Latitude,
		Longitude: req.Destination.Longitude,
		Timestamp: req.Destination.Timestamp.AsTime(),
	}

	departureTime := req.DepartureTime.AsTime()
	if departureTime.IsZero() {
		departureTime = time.Now()
	}

	// Call service
	result, err := h.geoService.CalculateETA(ctx, origin, destination, req.VehicleType, departureTime, req.IncludeTraffic)
	if err != nil {
		h.logger.WithContext(ctx).WithError(err).Error("Failed to calculate ETA")
		return nil, fmt.Errorf("failed to calculate ETA: %w", err)
	}

	// Convert waypoints to protobuf
	var waypoints []*pb.Location
	for _, wp := range result.Waypoints {
		waypoints = append(waypoints, &pb.Location{
			Latitude:  wp.Latitude,
			Longitude: wp.Longitude,
			Timestamp: timestamppb.New(wp.Timestamp),
		})
	}

	// Convert to protobuf response
	response := &pb.ETAResponse{
		DurationSeconds:  int32(result.DurationSeconds),
		DistanceMeters:   result.DistanceMeters,
		RouteSummary:     result.RouteSummary,
		Waypoints:        waypoints,
		EstimatedArrival: timestamppb.New(result.EstimatedArrival),
	}

	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"duration_minutes": result.DurationSeconds / 60,
		"distance_km":      result.DistanceMeters / 1000,
		"vehicle_type":     req.VehicleType,
	}).Debug("ETA calculation completed")

	return response, nil
}

// FindNearbyDrivers finds drivers near a location
func (h *GeoHandler) FindNearbyDrivers(ctx context.Context, req *pb.NearbyDriversRequest) (*pb.NearbyDriversResponse, error) {
	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"center_lat":     req.Center.Latitude,
		"center_lng":     req.Center.Longitude,
		"radius_km":      req.RadiusKm,
		"limit":          req.Limit,
		"vehicle_types":  req.VehicleTypes,
		"only_available": req.OnlyAvailable,
	}).Debug("Find nearby drivers request received")

	// Convert protobuf location to domain model
	center := models.Location{
		Latitude:  req.Center.Latitude,
		Longitude: req.Center.Longitude,
		Timestamp: req.Center.Timestamp.AsTime(),
	}

	// Call service
	drivers, err := h.geoService.FindNearbyDrivers(ctx, center, float64(req.RadiusKm), int(req.Limit), req.VehicleTypes, req.OnlyAvailable)
	if err != nil {
		h.logger.WithContext(ctx).WithError(err).Error("Failed to find nearby drivers")
		return nil, fmt.Errorf("failed to find nearby drivers: %w", err)
	}

	// Convert to protobuf response
	var pbDrivers []*pb.DriverLocation
	for _, driver := range drivers {
		pbDrivers = append(pbDrivers, &pb.DriverLocation{
			DriverId:  driver.DriverID,
			VehicleId: driver.VehicleID,
			Location: &pb.Location{
				Latitude:  driver.Location.Latitude,
				Longitude: driver.Location.Longitude,
				Timestamp: timestamppb.New(driver.Location.Timestamp),
			},
			DistanceFromCenter: driver.DistanceFromCenter,
			Status:             driver.Status,
			VehicleType:        driver.VehicleType,
			Rating:             driver.Rating,
		})
	}

	response := &pb.NearbyDriversResponse{
		Drivers:        pbDrivers,
		TotalCount:     int32(len(drivers)),
		SearchRadiusKm: req.RadiusKm,
	}

	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"drivers_found": len(drivers),
		"radius_km":     req.RadiusKm,
	}).Debug("Find nearby drivers completed")

	return response, nil
}

// UpdateDriverLocation updates a driver's location
func (h *GeoHandler) UpdateDriverLocation(ctx context.Context, req *pb.UpdateDriverLocationRequest) (*pb.UpdateDriverLocationResponse, error) {
	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"driver_id":  req.DriverId,
		"vehicle_id": req.VehicleId,
		"latitude":   req.Location.Latitude,
		"longitude":  req.Location.Longitude,
		"status":     req.Status,
	}).Debug("Update driver location request received")

	// Convert protobuf location to domain model
	location := models.Location{
		Latitude:  req.Location.Latitude,
		Longitude: req.Location.Longitude,
		Timestamp: req.Location.Timestamp.AsTime(),
	}

	// Call service
	err := h.geoService.UpdateDriverLocation(ctx, req.DriverId, location, req.Status, req.VehicleId)
	if err != nil {
		h.logger.WithContext(ctx).WithError(err).Error("Failed to update driver location")
		return &pb.UpdateDriverLocationResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to update driver location: %v", err),
		}, nil
	}

	response := &pb.UpdateDriverLocationResponse{
		Success:   true,
		Message:   "Driver location updated successfully",
		UpdatedAt: timestamppb.New(time.Now()),
	}

	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"driver_id":  req.DriverId,
		"vehicle_id": req.VehicleId,
	}).Debug("Update driver location completed")

	return response, nil
}

// GenerateGeohash generates a geohash for a location
func (h *GeoHandler) GenerateGeohash(ctx context.Context, req *pb.GeohashRequest) (*pb.GeohashResponse, error) {
	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"latitude":  req.Location.Latitude,
		"longitude": req.Location.Longitude,
		"precision": req.Precision,
	}).Debug("Generate geohash request received")

	// Convert protobuf location to domain model
	location := models.Location{
		Latitude:  req.Location.Latitude,
		Longitude: req.Location.Longitude,
		Timestamp: req.Location.Timestamp.AsTime(),
	}

	// Call service
	geohash, err := h.geoService.GenerateGeohash(ctx, location, int(req.Precision))
	if err != nil {
		h.logger.WithContext(ctx).WithError(err).Error("Failed to generate geohash")
		return nil, fmt.Errorf("failed to generate geohash: %w", err)
	}

	// Calculate geohash bounds (simplified)
	centerLat := req.Location.Latitude
	centerLng := req.Location.Longitude
	precision := req.Precision

	// Rough approximation of geohash cell size
	latError := 180.0 / (1 << uint(precision*5/2))
	lngError := 360.0 / (1 << uint((precision*5+1)/2))

	response := &pb.GeohashResponse{
		Geohash: geohash,
		Center: &pb.Location{
			Latitude:  centerLat,
			Longitude: centerLng,
			Timestamp: timestamppb.New(time.Now()),
		},
		WidthMeters:  lngError * 111000, // Rough conversion to meters
		HeightMeters: latError * 111000,
	}

	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"geohash":   geohash,
		"precision": precision,
	}).Debug("Generate geohash completed")

	return response, nil
}

// OptimizeRoute optimizes a route with multiple waypoints
func (h *GeoHandler) OptimizeRoute(ctx context.Context, req *pb.RouteOptimizationRequest) (*pb.RouteOptimizationResponse, error) {
	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"start_lat":         req.Start.Latitude,
		"start_lng":         req.Start.Longitude,
		"end_lat":           req.End.Latitude,
		"end_lng":           req.End.Longitude,
		"waypoint_count":    len(req.Waypoints),
		"optimization_type": req.OptimizationType,
		"vehicle_type":      req.VehicleType,
	}).Debug("Route optimization request received")

	// This is a simplified implementation
	// In production, you'd implement sophisticated route optimization algorithms

	// Convert waypoints to domain models
	var waypoints []models.Location
	for _, wp := range req.Waypoints {
		waypoints = append(waypoints, models.Location{
			Latitude:  wp.Latitude,
			Longitude: wp.Longitude,
			Timestamp: wp.Timestamp.AsTime(),
		})
	}

	// Simple route optimization (just return waypoints in order)
	var optimizedRoute []*pb.Location

	// Add start point
	optimizedRoute = append(optimizedRoute, &pb.Location{
		Latitude:  req.Start.Latitude,
		Longitude: req.Start.Longitude,
		Timestamp: timestamppb.New(time.Now()),
	})

	// Add waypoints (in a real implementation, these would be optimized)
	for _, wp := range req.Waypoints {
		optimizedRoute = append(optimizedRoute, wp)
	}

	// Add end point
	optimizedRoute = append(optimizedRoute, &pb.Location{
		Latitude:  req.End.Latitude,
		Longitude: req.End.Longitude,
		Timestamp: timestamppb.New(time.Now()),
	})

	// Calculate total distance (simplified)
	totalDistance := 0.0
	for i := 1; i < len(optimizedRoute); i++ {
		prev := models.Location{
			Latitude:  optimizedRoute[i-1].Latitude,
			Longitude: optimizedRoute[i-1].Longitude,
		}
		curr := models.Location{
			Latitude:  optimizedRoute[i].Latitude,
			Longitude: optimizedRoute[i].Longitude,
		}

		if distCalc, err := h.geoService.CalculateDistance(ctx, prev, curr, "haversine"); err == nil {
			totalDistance += distCalc.DistanceMeters
		}
	}

	// Estimate duration based on vehicle type
	speed := 50.0 // Default speed in km/h
	if req.VehicleType == "bike" {
		speed = 20.0
	} else if req.VehicleType == "walking" {
		speed = 5.0
	}

	totalDuration := int32((totalDistance / 1000) / speed * 3600) // Convert to seconds

	response := &pb.RouteOptimizationResponse{
		OptimizedRoute:          optimizedRoute,
		TotalDistanceMeters:     totalDistance,
		TotalDurationSeconds:    totalDuration,
		FuelConsumptionEstimate: totalDistance / 1000 * 0.08, // Rough estimate: 8L/100km
		OptimizationType:        req.OptimizationType,
	}

	h.logger.WithContext(ctx).WithFields(logger.Fields{
		"total_distance_km":  totalDistance / 1000,
		"total_duration_min": totalDuration / 60,
		"optimization_type":  req.OptimizationType,
	}).Debug("Route optimization completed")

	return response, nil
}
